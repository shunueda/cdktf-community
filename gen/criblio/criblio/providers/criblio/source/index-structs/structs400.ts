import * as cdktf from 'cdktf';
import { SourceInputHttpRawAuthTokensExt,
sourceInputHttpRawAuthTokensExtToTerraform,
sourceInputHttpRawAuthTokensExtToHclTerraform,
SourceInputHttpRawAuthTokensExtList } from './structs0'
export interface SourceInputHttpRawConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputHttpRawConnectionsToTerraform(struct?: SourceInputHttpRawConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputHttpRawConnectionsToHclTerraform(struct?: SourceInputHttpRawConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputHttpRawConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputHttpRawConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputHttpRawConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputHttpRawConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputHttpRawConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputHttpRawConnectionsOutputReference {
    return new SourceInputHttpRawConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputHttpRawMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputHttpRawMetadataToTerraform(struct?: SourceInputHttpRawMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputHttpRawMetadataToHclTerraform(struct?: SourceInputHttpRawMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputHttpRawMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputHttpRawMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputHttpRawMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputHttpRawMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputHttpRawMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputHttpRawMetadataOutputReference {
    return new SourceInputHttpRawMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputHttpRawPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputHttpRawPqToTerraform(struct?: SourceInputHttpRawPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputHttpRawPqToHclTerraform(struct?: SourceInputHttpRawPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputHttpRawPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputHttpRawPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputHttpRawPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputHttpRawTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputHttpRawTlsToTerraform(struct?: SourceInputHttpRawTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputHttpRawTlsToHclTerraform(struct?: SourceInputHttpRawTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputHttpRawTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputHttpRawTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputHttpRawTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputHttpRaw {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#activity_log_sample_rate Source#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all. Default: ["*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allowed_methods Source#allowed_methods}
  */
  readonly allowedMethods?: string[];
  /**
  * List of URI paths accepted by this input, wildcards are supported, e.g /api/v* /hook. Defaults to allow all. Default: ["*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allowed_paths Source#allowed_paths}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly allowedPaths?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_tokens Source#auth_tokens}
  */
  readonly authTokens?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_tokens_ext Source#auth_tokens_ext}
  */
  readonly authTokensExt?: SourceInputHttpRawAuthTokensExt[] | cdktf.IResolvable;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#capture_headers Source#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputHttpRawConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_health_check Source#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_allowlist_regex Source#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_denylist_regex Source#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_timeout Source#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_req Source#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_requests_per_socket Source#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputHttpRawMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputHttpRawPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputHttpRawTls;
  /**
  * must be "http_raw"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputHttpRawToTerraform(struct?: SourceInputHttpRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    allowed_methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedMethods),
    allowed_paths: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedPaths),
    auth_tokens: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.authTokens),
    auth_tokens_ext: cdktf.listMapper(sourceInputHttpRawAuthTokensExtToTerraform, false)(struct!.authTokensExt),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(sourceInputHttpRawConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(sourceInputHttpRawMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputHttpRawPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: sourceInputHttpRawTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputHttpRawToHclTerraform(struct?: SourceInputHttpRaw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    allowed_methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedMethods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allowed_paths: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedPaths),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.authTokens),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens_ext: {
      value: cdktf.listMapperHcl(sourceInputHttpRawAuthTokensExtToHclTerraform, false)(struct!.authTokensExt),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputHttpRawAuthTokensExtList",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputHttpRawConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputHttpRawConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputHttpRawMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputHttpRawMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputHttpRawPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputHttpRawPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: sourceInputHttpRawTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputHttpRawTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputHttpRawOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputHttpRaw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._allowedMethods !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedMethods = this._allowedMethods;
    }
    if (this._allowedPaths !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedPaths = this._allowedPaths;
    }
    if (this._authTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens;
    }
    if (this._authTokensExt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokensExt = this._authTokensExt?.internalValue;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputHttpRaw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._allowedMethods = undefined;
      this._allowedPaths = undefined;
      this._authTokens = undefined;
      this._authTokensExt.internalValue = undefined;
      this._breakerRulesets = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._allowedMethods = value.allowedMethods;
      this._allowedPaths = value.allowedPaths;
      this._authTokens = value.authTokens;
      this._authTokensExt.internalValue = value.authTokensExt;
      this._breakerRulesets = value.breakerRulesets;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // allowed_methods - computed: true, optional: true, required: false
  private _allowedMethods?: string[]; 
  public get allowedMethods() {
    return this.getListAttribute('allowed_methods');
  }
  public set allowedMethods(value: string[]) {
    this._allowedMethods = value;
  }
  public resetAllowedMethods() {
    this._allowedMethods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedMethodsInput() {
    return this._allowedMethods;
  }

  // allowed_paths - computed: true, optional: true, required: false
  private _allowedPaths?: string[]; 
  public get allowedPaths() {
    return this.getListAttribute('allowed_paths');
  }
  public set allowedPaths(value: string[]) {
    this._allowedPaths = value;
  }
  public resetAllowedPaths() {
    this._allowedPaths = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedPathsInput() {
    return this._allowedPaths;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens?: string[]; 
  public get authTokens() {
    return this.getListAttribute('auth_tokens');
  }
  public set authTokens(value: string[]) {
    this._authTokens = value;
  }
  public resetAuthTokens() {
    this._authTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens;
  }

  // auth_tokens_ext - computed: false, optional: true, required: false
  private _authTokensExt = new SourceInputHttpRawAuthTokensExtList(this, "auth_tokens_ext", false);
  public get authTokensExt() {
    return this._authTokensExt;
  }
  public putAuthTokensExt(value: SourceInputHttpRawAuthTokensExt[] | cdktf.IResolvable) {
    this._authTokensExt.internalValue = value;
  }
  public resetAuthTokensExt() {
    this._authTokensExt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensExtInput() {
    return this._authTokensExt.internalValue;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputHttpRawConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputHttpRawConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputHttpRawMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputHttpRawMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputHttpRawPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputHttpRawPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputHttpRawTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputHttpRawTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputJournalFilesConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputJournalFilesConnectionsToTerraform(struct?: SourceInputJournalFilesConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputJournalFilesConnectionsToHclTerraform(struct?: SourceInputJournalFilesConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputJournalFilesConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputJournalFilesConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputJournalFilesConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputJournalFilesConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputJournalFilesConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputJournalFilesConnectionsOutputReference {
    return new SourceInputJournalFilesConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputJournalFilesMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputJournalFilesMetadataToTerraform(struct?: SourceInputJournalFilesMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputJournalFilesMetadataToHclTerraform(struct?: SourceInputJournalFilesMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputJournalFilesMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputJournalFilesMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputJournalFilesMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputJournalFilesMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputJournalFilesMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputJournalFilesMetadataOutputReference {
    return new SourceInputJournalFilesMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputJournalFilesPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputJournalFilesPqToTerraform(struct?: SourceInputJournalFilesPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputJournalFilesPqToHclTerraform(struct?: SourceInputJournalFilesPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputJournalFilesPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputJournalFilesPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputJournalFilesPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputJournalFilesRules {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to Journal objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#filter Source#filter}
  */
  readonly filter: string;
}

export function sourceInputJournalFilesRulesToTerraform(struct?: SourceInputJournalFilesRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function sourceInputJournalFilesRulesToHclTerraform(struct?: SourceInputJournalFilesRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputJournalFilesRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputJournalFilesRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputJournalFilesRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class SourceInputJournalFilesRulesList extends cdktf.ComplexList {
  public internalValue? : SourceInputJournalFilesRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputJournalFilesRulesOutputReference {
    return new SourceInputJournalFilesRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputJournalFiles {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputJournalFilesConnections[] | cdktf.IResolvable;
  /**
  * Skip log messages that are not part of the current boot session. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#current_boot Source#current_boot}
  */
  readonly currentBoot?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Time, in seconds, between scanning for journals. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * The full path of discovered journals are matched against this wildcard list. Default: ["system"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#journals Source#journals}
  */
  readonly journals?: string[];
  /**
  * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_age_dur Source#max_age_dur}
  */
  readonly maxAgeDur?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputJournalFilesMetadata[] | cdktf.IResolvable;
  /**
  * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputJournalFilesPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#rules Source#rules}
  */
  readonly rules?: SourceInputJournalFilesRules[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "journal_files"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputJournalFilesToTerraform(struct?: SourceInputJournalFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputJournalFilesConnectionsToTerraform, false)(struct!.connections),
    current_boot: cdktf.booleanToTerraform(struct!.currentBoot),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    journals: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.journals),
    max_age_dur: cdktf.stringToTerraform(struct!.maxAgeDur),
    metadata: cdktf.listMapper(sourceInputJournalFilesMetadataToTerraform, false)(struct!.metadata),
    path: cdktf.stringToTerraform(struct!.path),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputJournalFilesPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    rules: cdktf.listMapper(sourceInputJournalFilesRulesToTerraform, false)(struct!.rules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputJournalFilesToHclTerraform(struct?: SourceInputJournalFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputJournalFilesConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputJournalFilesConnectionsList",
    },
    current_boot: {
      value: cdktf.booleanToHclTerraform(struct!.currentBoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    journals: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.journals),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_age_dur: {
      value: cdktf.stringToHclTerraform(struct!.maxAgeDur),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputJournalFilesMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputJournalFilesMetadataList",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputJournalFilesPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputJournalFilesPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rules: {
      value: cdktf.listMapperHcl(sourceInputJournalFilesRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputJournalFilesRulesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputJournalFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputJournalFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._currentBoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.currentBoot = this._currentBoot;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._journals !== undefined) {
      hasAnyValues = true;
      internalValueResult.journals = this._journals;
    }
    if (this._maxAgeDur !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxAgeDur = this._maxAgeDur;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputJournalFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._currentBoot = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._journals = undefined;
      this._maxAgeDur = undefined;
      this._metadata.internalValue = undefined;
      this._path = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._currentBoot = value.currentBoot;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._journals = value.journals;
      this._maxAgeDur = value.maxAgeDur;
      this._metadata.internalValue = value.metadata;
      this._path = value.path;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rules.internalValue = value.rules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputJournalFilesConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputJournalFilesConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // current_boot - computed: true, optional: true, required: false
  private _currentBoot?: boolean | cdktf.IResolvable; 
  public get currentBoot() {
    return this.getBooleanAttribute('current_boot');
  }
  public set currentBoot(value: boolean | cdktf.IResolvable) {
    this._currentBoot = value;
  }
  public resetCurrentBoot() {
    this._currentBoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get currentBootInput() {
    return this._currentBoot;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // journals - computed: true, optional: true, required: false
  private _journals?: string[]; 
  public get journals() {
    return this.getListAttribute('journals');
  }
  public set journals(value: string[]) {
    this._journals = value;
  }
  public resetJournals() {
    this._journals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get journalsInput() {
    return this._journals;
  }

  // max_age_dur - computed: false, optional: true, required: false
  private _maxAgeDur?: string; 
  public get maxAgeDur() {
    return this.getStringAttribute('max_age_dur');
  }
  public set maxAgeDur(value: string) {
    this._maxAgeDur = value;
  }
  public resetMaxAgeDur() {
    this._maxAgeDur = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxAgeDurInput() {
    return this._maxAgeDur;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputJournalFilesMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputJournalFilesMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputJournalFilesPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputJournalFilesPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new SourceInputJournalFilesRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: SourceInputJournalFilesRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputKafkaConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputKafkaConnectionsToTerraform(struct?: SourceInputKafkaConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputKafkaConnectionsToHclTerraform(struct?: SourceInputKafkaConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKafkaConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafkaConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputKafkaConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputKafkaConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKafkaConnectionsOutputReference {
    return new SourceInputKafkaConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKafkaKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#credentials_secret Source#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function sourceInputKafkaKafkaSchemaRegistryAuthToTerraform(struct?: SourceInputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function sourceInputKafkaKafkaSchemaRegistryAuthToHclTerraform(struct?: SourceInputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface SourceInputKafkaKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#servername Source#servername}
  */
  readonly servername?: string;
}

export function sourceInputKafkaKafkaSchemaRegistryTlsToTerraform(struct?: SourceInputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function sourceInputKafkaKafkaSchemaRegistryTlsToHclTerraform(struct?: SourceInputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface SourceInputKafkaKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth Source#auth}
  */
  readonly auth?: SourceInputKafkaKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connection_timeout Source#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_retries Source#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#schema_registry_url Source#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputKafkaKafkaSchemaRegistryTls;
}

export function sourceInputKafkaKafkaSchemaRegistryToTerraform(struct?: SourceInputKafkaKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: sourceInputKafkaKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: sourceInputKafkaKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function sourceInputKafkaKafkaSchemaRegistryToHclTerraform(struct?: SourceInputKafkaKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: sourceInputKafkaKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKafkaKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: sourceInputKafkaKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKafkaKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKafkaKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafkaKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new SourceInputKafkaKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: SourceInputKafkaKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputKafkaKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputKafkaKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface SourceInputKafkaMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputKafkaMetadataToTerraform(struct?: SourceInputKafkaMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputKafkaMetadataToHclTerraform(struct?: SourceInputKafkaMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKafkaMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafkaMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputKafkaMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputKafkaMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKafkaMetadataOutputReference {
    return new SourceInputKafkaMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKafkaPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputKafkaPqToTerraform(struct?: SourceInputKafkaPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputKafkaPqToHclTerraform(struct?: SourceInputKafkaPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKafkaPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafkaPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputKafkaSasl {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mechanism Source#mechanism}
  */
  readonly mechanism?: string;
}

export function sourceInputKafkaSaslToTerraform(struct?: SourceInputKafkaSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function sourceInputKafkaSaslToHclTerraform(struct?: SourceInputKafkaSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKafkaSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafkaSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface SourceInputKafkaTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#servername Source#servername}
  */
  readonly servername?: string;
}

export function sourceInputKafkaTlsToTerraform(struct?: SourceInputKafkaTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function sourceInputKafkaTlsToHclTerraform(struct?: SourceInputKafkaTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKafkaTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafkaTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface SourceInputKafka {
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#authentication_timeout Source#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auto_commit_interval Source#auto_commit_interval}
  */
  readonly autoCommitInterval?: number;
  /**
  * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auto_commit_threshold Source#auto_commit_threshold}
  */
  readonly autoCommitThreshold?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#backoff_rate Source#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#brokers Source#brokers}
  */
  readonly brokers: string[];
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connection_timeout Source#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputKafkaConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#from_beginning Source#from_beginning}
  */
  readonly fromBeginning?: boolean | cdktf.IResolvable;
  /**
  * The consumer group to which this instance belongs. Defaults to 'Cribl'. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#group_id Source#group_id}
  */
  readonly groupId?: string;
  /**
  * Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
  *     Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
  * Default: 3000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#heartbeat_interval Source#heartbeat_interval}
  */
  readonly heartbeatInterval?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#initial_backoff Source#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#kafka_schema_registry Source#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: SourceInputKafkaKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_back_off Source#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_bytes Source#max_bytes}
  */
  readonly maxBytes?: number;
  /**
  * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_bytes_per_partition Source#max_bytes_per_partition}
  */
  readonly maxBytesPerPartition?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_retries Source#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum number of network errors before the consumer re-creates a socket. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_socket_errors Source#max_socket_errors}
  */
  readonly maxSocketErrors?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputKafkaMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputKafkaPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reauthentication_threshold Source#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum allowed time for each worker to join the group after a rebalance begins.
  *     If the timeout is exceeded, the coordinator broker will remove the worker from the group.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
  * Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#rebalance_timeout Source#rebalance_timeout}
  */
  readonly rebalanceTimeout?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#sasl Source#sasl}
  */
  readonly sasl?: SourceInputKafkaSasl;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Timeout used to detect client failures when using Kafka's group-management facilities.
  *     If the client sends no heartbeats to the broker before the timeout expires, 
  *     the broker will remove the client from the group and initiate a rebalance.
  *     Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
  * Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#session_timeout Source#session_timeout}
  */
  readonly sessionTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputKafkaTls;
  /**
  * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#topics Source#topics}
  */
  readonly topics?: string[];
  /**
  * must be "kafka"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputKafkaToTerraform(struct?: SourceInputKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    auto_commit_interval: cdktf.numberToTerraform(struct!.autoCommitInterval),
    auto_commit_threshold: cdktf.numberToTerraform(struct!.autoCommitThreshold),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    connections: cdktf.listMapper(sourceInputKafkaConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    from_beginning: cdktf.booleanToTerraform(struct!.fromBeginning),
    group_id: cdktf.stringToTerraform(struct!.groupId),
    heartbeat_interval: cdktf.numberToTerraform(struct!.heartbeatInterval),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: sourceInputKafkaKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_bytes: cdktf.numberToTerraform(struct!.maxBytes),
    max_bytes_per_partition: cdktf.numberToTerraform(struct!.maxBytesPerPartition),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    max_socket_errors: cdktf.numberToTerraform(struct!.maxSocketErrors),
    metadata: cdktf.listMapper(sourceInputKafkaMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputKafkaPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    rebalance_timeout: cdktf.numberToTerraform(struct!.rebalanceTimeout),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: sourceInputKafkaSaslToTerraform(struct!.sasl),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    session_timeout: cdktf.numberToTerraform(struct!.sessionTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: sourceInputKafkaTlsToTerraform(struct!.tls),
    topics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.topics),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputKafkaToHclTerraform(struct?: SourceInputKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_interval: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_threshold: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputKafkaConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKafkaConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from_beginning: {
      value: cdktf.booleanToHclTerraform(struct!.fromBeginning),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_id: {
      value: cdktf.stringToHclTerraform(struct!.groupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.numberToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: sourceInputKafkaKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKafkaKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes_per_partition: {
      value: cdktf.numberToHclTerraform(struct!.maxBytesPerPartition),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_socket_errors: {
      value: cdktf.numberToHclTerraform(struct!.maxSocketErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputKafkaMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKafkaMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputKafkaPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKafkaPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rebalance_timeout: {
      value: cdktf.numberToHclTerraform(struct!.rebalanceTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: sourceInputKafkaSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKafkaSasl",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    session_timeout: {
      value: cdktf.numberToHclTerraform(struct!.sessionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: sourceInputKafkaTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKafkaTls",
    },
    topics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.topics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKafkaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKafka | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._autoCommitInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitInterval = this._autoCommitInterval;
    }
    if (this._autoCommitThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitThreshold = this._autoCommitThreshold;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fromBeginning !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromBeginning = this._fromBeginning;
    }
    if (this._groupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupId = this._groupId;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytes = this._maxBytes;
    }
    if (this._maxBytesPerPartition !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytesPerPartition = this._maxBytesPerPartition;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._maxSocketErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSocketErrors = this._maxSocketErrors;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._rebalanceTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.rebalanceTimeout = this._rebalanceTimeout;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._sessionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTimeout = this._sessionTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topics !== undefined) {
      hasAnyValues = true;
      internalValueResult.topics = this._topics;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKafka | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authenticationTimeout = undefined;
      this._autoCommitInterval = undefined;
      this._autoCommitThreshold = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._connectionTimeout = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._fromBeginning = undefined;
      this._groupId = undefined;
      this._heartbeatInterval = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxBytes = undefined;
      this._maxBytesPerPartition = undefined;
      this._maxRetries = undefined;
      this._maxSocketErrors = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._reauthenticationThreshold = undefined;
      this._rebalanceTimeout = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._sessionTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._topics = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authenticationTimeout = value.authenticationTimeout;
      this._autoCommitInterval = value.autoCommitInterval;
      this._autoCommitThreshold = value.autoCommitThreshold;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._connectionTimeout = value.connectionTimeout;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._fromBeginning = value.fromBeginning;
      this._groupId = value.groupId;
      this._heartbeatInterval = value.heartbeatInterval;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxBytes = value.maxBytes;
      this._maxBytesPerPartition = value.maxBytesPerPartition;
      this._maxRetries = value.maxRetries;
      this._maxSocketErrors = value.maxSocketErrors;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._rebalanceTimeout = value.rebalanceTimeout;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._sendToRoutes = value.sendToRoutes;
      this._sessionTimeout = value.sessionTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._topics = value.topics;
      this._type = value.type;
    }
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // auto_commit_interval - computed: false, optional: true, required: false
  private _autoCommitInterval?: number; 
  public get autoCommitInterval() {
    return this.getNumberAttribute('auto_commit_interval');
  }
  public set autoCommitInterval(value: number) {
    this._autoCommitInterval = value;
  }
  public resetAutoCommitInterval() {
    this._autoCommitInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitIntervalInput() {
    return this._autoCommitInterval;
  }

  // auto_commit_threshold - computed: false, optional: true, required: false
  private _autoCommitThreshold?: number; 
  public get autoCommitThreshold() {
    return this.getNumberAttribute('auto_commit_threshold');
  }
  public set autoCommitThreshold(value: number) {
    this._autoCommitThreshold = value;
  }
  public resetAutoCommitThreshold() {
    this._autoCommitThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitThresholdInput() {
    return this._autoCommitThreshold;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputKafkaConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputKafkaConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // from_beginning - computed: true, optional: true, required: false
  private _fromBeginning?: boolean | cdktf.IResolvable; 
  public get fromBeginning() {
    return this.getBooleanAttribute('from_beginning');
  }
  public set fromBeginning(value: boolean | cdktf.IResolvable) {
    this._fromBeginning = value;
  }
  public resetFromBeginning() {
    this._fromBeginning = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromBeginningInput() {
    return this._fromBeginning;
  }

  // group_id - computed: true, optional: true, required: false
  private _groupId?: string; 
  public get groupId() {
    return this.getStringAttribute('group_id');
  }
  public set groupId(value: string) {
    this._groupId = value;
  }
  public resetGroupId() {
    this._groupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIdInput() {
    return this._groupId;
  }

  // heartbeat_interval - computed: true, optional: true, required: false
  private _heartbeatInterval?: number; 
  public get heartbeatInterval() {
    return this.getNumberAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: number) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new SourceInputKafkaKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: SourceInputKafkaKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_bytes - computed: true, optional: true, required: false
  private _maxBytes?: number; 
  public get maxBytes() {
    return this.getNumberAttribute('max_bytes');
  }
  public set maxBytes(value: number) {
    this._maxBytes = value;
  }
  public resetMaxBytes() {
    this._maxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesInput() {
    return this._maxBytes;
  }

  // max_bytes_per_partition - computed: true, optional: true, required: false
  private _maxBytesPerPartition?: number; 
  public get maxBytesPerPartition() {
    return this.getNumberAttribute('max_bytes_per_partition');
  }
  public set maxBytesPerPartition(value: number) {
    this._maxBytesPerPartition = value;
  }
  public resetMaxBytesPerPartition() {
    this._maxBytesPerPartition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesPerPartitionInput() {
    return this._maxBytesPerPartition;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // max_socket_errors - computed: true, optional: true, required: false
  private _maxSocketErrors?: number; 
  public get maxSocketErrors() {
    return this.getNumberAttribute('max_socket_errors');
  }
  public set maxSocketErrors(value: number) {
    this._maxSocketErrors = value;
  }
  public resetMaxSocketErrors() {
    this._maxSocketErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSocketErrorsInput() {
    return this._maxSocketErrors;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputKafkaMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputKafkaMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputKafkaPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputKafkaPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // rebalance_timeout - computed: true, optional: true, required: false
  private _rebalanceTimeout?: number; 
  public get rebalanceTimeout() {
    return this.getNumberAttribute('rebalance_timeout');
  }
  public set rebalanceTimeout(value: number) {
    this._rebalanceTimeout = value;
  }
  public resetRebalanceTimeout() {
    this._rebalanceTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rebalanceTimeoutInput() {
    return this._rebalanceTimeout;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new SourceInputKafkaSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: SourceInputKafkaSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // session_timeout - computed: true, optional: true, required: false
  private _sessionTimeout?: number; 
  public get sessionTimeout() {
    return this.getNumberAttribute('session_timeout');
  }
  public set sessionTimeout(value: number) {
    this._sessionTimeout = value;
  }
  public resetSessionTimeout() {
    this._sessionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTimeoutInput() {
    return this._sessionTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputKafkaTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputKafkaTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topics - computed: true, optional: true, required: false
  private _topics?: string[]; 
  public get topics() {
    return this.getListAttribute('topics');
  }
  public set topics(value: string[]) {
    this._topics = value;
  }
  public resetTopics() {
    this._topics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicsInput() {
    return this._topics;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputKinesisConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputKinesisConnectionsToTerraform(struct?: SourceInputKinesisConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputKinesisConnectionsToHclTerraform(struct?: SourceInputKinesisConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKinesisConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKinesisConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKinesisConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputKinesisConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputKinesisConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKinesisConnectionsOutputReference {
    return new SourceInputKinesisConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKinesisMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputKinesisMetadataToTerraform(struct?: SourceInputKinesisMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputKinesisMetadataToHclTerraform(struct?: SourceInputKinesisMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKinesisMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKinesisMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKinesisMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputKinesisMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputKinesisMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKinesisMetadataOutputReference {
    return new SourceInputKinesisMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKinesisPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputKinesisPqToTerraform(struct?: SourceInputKinesisPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputKinesisPqToHclTerraform(struct?: SourceInputKinesisPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKinesisPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKinesisPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKinesisPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputKinesis {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_arn Source#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_external_id Source#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#avoid_duplicates Source#avoid_duplicates}
  */
  readonly avoidDuplicates?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_api_key Source#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_authentication_method Source#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret Source#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret_key Source#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputKinesisConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#duration_seconds Source#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Kinesis stream. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_assume_role Source#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Maximum number of records per getRecords call. Default: 5000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#get_records_limit Source#get_records_limit}
  */
  readonly fetchRecordsLimit?: number;
  /**
  * Maximum number of records, across all shards, to pull down at once per Worker Process. Default: 20000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#get_records_limit_total Source#get_records_limit_total}
  */
  readonly fetchRecordsLimitTotal?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes. Default: "ConsistentHashing"; must be one of ["ConsistentHashing", "RoundRobin"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#load_balancing_algorithm Source#load_balancing_algorithm}
  */
  readonly loadBalancingAlgorithm?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputKinesisMetadata[] | cdktf.IResolvable;
  /**
  * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected. Default: "cribl"; must be one of ["cribl", "ndjson", "cloudwatch", "line"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#payload_format Source#payload_format}
  */
  readonly payloadFormat?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputKinesisPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Region where the Kinesis stream is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#region Source#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reuse_connections Source#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Time interval in minutes between consecutive service calls. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#service_interval Source#service_interval}
  */
  readonly serviceInterval?: number;
  /**
  * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed. Default: "true"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#shard_expr Source#shard_expr}
  */
  readonly shardExpr?: string;
  /**
  * Location at which to start reading a shard for the first time. Default: "TRIM_HORIZON"; must be one of ["TRIM_HORIZON", "LATEST"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#shard_iterator_type Source#shard_iterator_type}
  */
  readonly shardIteratorType?: string;
  /**
  * Signature version to use for signing Kinesis stream requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#signature_version Source#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Kinesis Data Stream to read data from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stream_name Source#stream_name}
  */
  readonly streamName: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "kinesis"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Verify Kinesis Producer Library (KPL) event checksums. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#verify_kpl_check_sums Source#verify_kpl_check_sums}
  */
  readonly verifyKplCheckSums?: boolean | cdktf.IResolvable;
}

export function sourceInputKinesisToTerraform(struct?: SourceInputKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    avoid_duplicates: cdktf.booleanToTerraform(struct!.avoidDuplicates),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    connections: cdktf.listMapper(sourceInputKinesisConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    get_records_limit: cdktf.numberToTerraform(struct!.fetchRecordsLimit),
    get_records_limit_total: cdktf.numberToTerraform(struct!.fetchRecordsLimitTotal),
    id: cdktf.stringToTerraform(struct!.id),
    load_balancing_algorithm: cdktf.stringToTerraform(struct!.loadBalancingAlgorithm),
    metadata: cdktf.listMapper(sourceInputKinesisMetadataToTerraform, false)(struct!.metadata),
    payload_format: cdktf.stringToTerraform(struct!.payloadFormat),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputKinesisPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    service_interval: cdktf.numberToTerraform(struct!.serviceInterval),
    shard_expr: cdktf.stringToTerraform(struct!.shardExpr),
    shard_iterator_type: cdktf.stringToTerraform(struct!.shardIteratorType),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
    verify_kpl_check_sums: cdktf.booleanToTerraform(struct!.verifyKplCheckSums),
  }
}


export function sourceInputKinesisToHclTerraform(struct?: SourceInputKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    avoid_duplicates: {
      value: cdktf.booleanToHclTerraform(struct!.avoidDuplicates),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputKinesisConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKinesisConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    get_records_limit: {
      value: cdktf.numberToHclTerraform(struct!.fetchRecordsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    get_records_limit_total: {
      value: cdktf.numberToHclTerraform(struct!.fetchRecordsLimitTotal),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancing_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancingAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputKinesisMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKinesisMetadataList",
    },
    payload_format: {
      value: cdktf.stringToHclTerraform(struct!.payloadFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputKinesisPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKinesisPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service_interval: {
      value: cdktf.numberToHclTerraform(struct!.serviceInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    shard_expr: {
      value: cdktf.stringToHclTerraform(struct!.shardExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shard_iterator_type: {
      value: cdktf.stringToHclTerraform(struct!.shardIteratorType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_kpl_check_sums: {
      value: cdktf.booleanToHclTerraform(struct!.verifyKplCheckSums),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKinesisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKinesis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._avoidDuplicates !== undefined) {
      hasAnyValues = true;
      internalValueResult.avoidDuplicates = this._avoidDuplicates;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._getRecordsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.fetchRecordsLimit = this._getRecordsLimit;
    }
    if (this._getRecordsLimitTotal !== undefined) {
      hasAnyValues = true;
      internalValueResult.fetchRecordsLimitTotal = this._getRecordsLimitTotal;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalancingAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancingAlgorithm = this._loadBalancingAlgorithm;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._payloadFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.payloadFormat = this._payloadFormat;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._serviceInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceInterval = this._serviceInterval;
    }
    if (this._shardExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.shardExpr = this._shardExpr;
    }
    if (this._shardIteratorType !== undefined) {
      hasAnyValues = true;
      internalValueResult.shardIteratorType = this._shardIteratorType;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyKplCheckSums !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyKplCheckSums = this._verifyKplCheckSums;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKinesis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._avoidDuplicates = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._getRecordsLimit = undefined;
      this._getRecordsLimitTotal = undefined;
      this._id = undefined;
      this._loadBalancingAlgorithm = undefined;
      this._metadata.internalValue = undefined;
      this._payloadFormat = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._serviceInterval = undefined;
      this._shardExpr = undefined;
      this._shardIteratorType = undefined;
      this._signatureVersion = undefined;
      this._streamName = undefined;
      this._streamtags = undefined;
      this._type = undefined;
      this._verifyKplCheckSums = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._avoidDuplicates = value.avoidDuplicates;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._getRecordsLimit = value.fetchRecordsLimit;
      this._getRecordsLimitTotal = value.fetchRecordsLimitTotal;
      this._id = value.id;
      this._loadBalancingAlgorithm = value.loadBalancingAlgorithm;
      this._metadata.internalValue = value.metadata;
      this._payloadFormat = value.payloadFormat;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._serviceInterval = value.serviceInterval;
      this._shardExpr = value.shardExpr;
      this._shardIteratorType = value.shardIteratorType;
      this._signatureVersion = value.signatureVersion;
      this._streamName = value.streamName;
      this._streamtags = value.streamtags;
      this._type = value.type;
      this._verifyKplCheckSums = value.verifyKplCheckSums;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // avoid_duplicates - computed: true, optional: true, required: false
  private _avoidDuplicates?: boolean | cdktf.IResolvable; 
  public get avoidDuplicates() {
    return this.getBooleanAttribute('avoid_duplicates');
  }
  public set avoidDuplicates(value: boolean | cdktf.IResolvable) {
    this._avoidDuplicates = value;
  }
  public resetAvoidDuplicates() {
    this._avoidDuplicates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get avoidDuplicatesInput() {
    return this._avoidDuplicates;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputKinesisConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputKinesisConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // get_records_limit - computed: true, optional: true, required: false
  private _getRecordsLimit?: number; 
  public get fetchRecordsLimit() {
    return this.getNumberAttribute('get_records_limit');
  }
  public set fetchRecordsLimit(value: number) {
    this._getRecordsLimit = value;
  }
  public resetFetchRecordsLimit() {
    this._getRecordsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fetchRecordsLimitInput() {
    return this._getRecordsLimit;
  }

  // get_records_limit_total - computed: true, optional: true, required: false
  private _getRecordsLimitTotal?: number; 
  public get fetchRecordsLimitTotal() {
    return this.getNumberAttribute('get_records_limit_total');
  }
  public set fetchRecordsLimitTotal(value: number) {
    this._getRecordsLimitTotal = value;
  }
  public resetFetchRecordsLimitTotal() {
    this._getRecordsLimitTotal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fetchRecordsLimitTotalInput() {
    return this._getRecordsLimitTotal;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balancing_algorithm - computed: true, optional: true, required: false
  private _loadBalancingAlgorithm?: string; 
  public get loadBalancingAlgorithm() {
    return this.getStringAttribute('load_balancing_algorithm');
  }
  public set loadBalancingAlgorithm(value: string) {
    this._loadBalancingAlgorithm = value;
  }
  public resetLoadBalancingAlgorithm() {
    this._loadBalancingAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancingAlgorithmInput() {
    return this._loadBalancingAlgorithm;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputKinesisMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputKinesisMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // payload_format - computed: true, optional: true, required: false
  private _payloadFormat?: string; 
  public get payloadFormat() {
    return this.getStringAttribute('payload_format');
  }
  public set payloadFormat(value: string) {
    this._payloadFormat = value;
  }
  public resetPayloadFormat() {
    this._payloadFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get payloadFormatInput() {
    return this._payloadFormat;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputKinesisPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputKinesisPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // service_interval - computed: true, optional: true, required: false
  private _serviceInterval?: number; 
  public get serviceInterval() {
    return this.getNumberAttribute('service_interval');
  }
  public set serviceInterval(value: number) {
    this._serviceInterval = value;
  }
  public resetServiceInterval() {
    this._serviceInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceIntervalInput() {
    return this._serviceInterval;
  }

  // shard_expr - computed: true, optional: true, required: false
  private _shardExpr?: string; 
  public get shardExpr() {
    return this.getStringAttribute('shard_expr');
  }
  public set shardExpr(value: string) {
    this._shardExpr = value;
  }
  public resetShardExpr() {
    this._shardExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shardExprInput() {
    return this._shardExpr;
  }

  // shard_iterator_type - computed: true, optional: true, required: false
  private _shardIteratorType?: string; 
  public get shardIteratorType() {
    return this.getStringAttribute('shard_iterator_type');
  }
  public set shardIteratorType(value: string) {
    this._shardIteratorType = value;
  }
  public resetShardIteratorType() {
    this._shardIteratorType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shardIteratorTypeInput() {
    return this._shardIteratorType;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stream_name - computed: false, optional: false, required: true
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_kpl_check_sums - computed: true, optional: true, required: false
  private _verifyKplCheckSums?: boolean | cdktf.IResolvable; 
  public get verifyKplCheckSums() {
    return this.getBooleanAttribute('verify_kpl_check_sums');
  }
  public set verifyKplCheckSums(value: boolean | cdktf.IResolvable) {
    this._verifyKplCheckSums = value;
  }
  public resetVerifyKplCheckSums() {
    this._verifyKplCheckSums = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyKplCheckSumsInput() {
    return this._verifyKplCheckSums;
  }
}
export interface SourceInputKubeEventsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputKubeEventsConnectionsToTerraform(struct?: SourceInputKubeEventsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputKubeEventsConnectionsToHclTerraform(struct?: SourceInputKubeEventsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeEventsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeEventsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeEventsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputKubeEventsConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeEventsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeEventsConnectionsOutputReference {
    return new SourceInputKubeEventsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeEventsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputKubeEventsMetadataToTerraform(struct?: SourceInputKubeEventsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputKubeEventsMetadataToHclTerraform(struct?: SourceInputKubeEventsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeEventsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeEventsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeEventsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputKubeEventsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeEventsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeEventsMetadataOutputReference {
    return new SourceInputKubeEventsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeEventsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputKubeEventsPqToTerraform(struct?: SourceInputKubeEventsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputKubeEventsPqToHclTerraform(struct?: SourceInputKubeEventsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeEventsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKubeEventsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeEventsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputKubeEventsRules {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to Kubernetes objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#filter Source#filter}
  */
  readonly filter: string;
}

export function sourceInputKubeEventsRulesToTerraform(struct?: SourceInputKubeEventsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function sourceInputKubeEventsRulesToHclTerraform(struct?: SourceInputKubeEventsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeEventsRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeEventsRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeEventsRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class SourceInputKubeEventsRulesList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeEventsRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeEventsRulesOutputReference {
    return new SourceInputKubeEventsRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeEvents {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputKubeEventsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputKubeEventsMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputKubeEventsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Filtering on event fields
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#rules Source#rules}
  */
  readonly rules?: SourceInputKubeEventsRules[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "kube_events"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
}

export function sourceInputKubeEventsToTerraform(struct?: SourceInputKubeEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputKubeEventsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    metadata: cdktf.listMapper(sourceInputKubeEventsMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputKubeEventsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    rules: cdktf.listMapper(sourceInputKubeEventsRulesToTerraform, false)(struct!.rules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputKubeEventsToHclTerraform(struct?: SourceInputKubeEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputKubeEventsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeEventsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputKubeEventsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeEventsMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputKubeEventsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKubeEventsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rules: {
      value: cdktf.listMapperHcl(sourceInputKubeEventsRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeEventsRulesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKubeEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rules.internalValue = value.rules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputKubeEventsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputKubeEventsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputKubeEventsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputKubeEventsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputKubeEventsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputKubeEventsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new SourceInputKubeEventsRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: SourceInputKubeEventsRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputKubeLogsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputKubeLogsConnectionsToTerraform(struct?: SourceInputKubeLogsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputKubeLogsConnectionsToHclTerraform(struct?: SourceInputKubeLogsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeLogsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeLogsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeLogsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputKubeLogsConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeLogsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeLogsConnectionsOutputReference {
    return new SourceInputKubeLogsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeLogsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputKubeLogsMetadataToTerraform(struct?: SourceInputKubeLogsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputKubeLogsMetadataToHclTerraform(struct?: SourceInputKubeLogsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeLogsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeLogsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeLogsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputKubeLogsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeLogsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeLogsMetadataOutputReference {
    return new SourceInputKubeLogsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeLogsPersistence {
  /**
  * Data compression format. Default is gzip. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * Spool events on disk for Cribl Edge and Search. Default is disabled. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_size Source#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_time Source#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time period for grouping spooled events. Default is 10m. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#time_window Source#time_window}
  */
  readonly timeWindow?: string;
}

export function sourceInputKubeLogsPersistenceToTerraform(struct?: SourceInputKubeLogsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function sourceInputKubeLogsPersistenceToHclTerraform(struct?: SourceInputKubeLogsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeLogsPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKubeLogsPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeLogsPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface SourceInputKubeLogsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputKubeLogsPqToTerraform(struct?: SourceInputKubeLogsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputKubeLogsPqToHclTerraform(struct?: SourceInputKubeLogsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeLogsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKubeLogsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeLogsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputKubeLogsRules {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to Pod objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#filter Source#filter}
  */
  readonly filter: string;
}

export function sourceInputKubeLogsRulesToTerraform(struct?: SourceInputKubeLogsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function sourceInputKubeLogsRulesToHclTerraform(struct?: SourceInputKubeLogsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeLogsRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeLogsRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeLogsRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class SourceInputKubeLogsRulesList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeLogsRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeLogsRulesOutputReference {
    return new SourceInputKubeLogsRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeLogs {
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputKubeLogsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_load_balancing Source#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between checks for new containers. Default is 15 secs. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputKubeLogsMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#persistence Source#persistence}
  */
  readonly persistence?: SourceInputKubeLogsPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputKubeLogsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#rules Source#rules}
  */
  readonly rules?: SourceInputKubeLogsRules[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#timestamps Source#timestamps}
  */
  readonly timestamps?: boolean | cdktf.IResolvable;
  /**
  * must be "kube_logs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
}

export function sourceInputKubeLogsToTerraform(struct?: SourceInputKubeLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    connections: cdktf.listMapper(sourceInputKubeLogsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(sourceInputKubeLogsMetadataToTerraform, false)(struct!.metadata),
    persistence: sourceInputKubeLogsPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputKubeLogsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    rules: cdktf.listMapper(sourceInputKubeLogsRulesToTerraform, false)(struct!.rules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    timestamps: cdktf.booleanToTerraform(struct!.timestamps),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputKubeLogsToHclTerraform(struct?: SourceInputKubeLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputKubeLogsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeLogsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputKubeLogsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeLogsMetadataList",
    },
    persistence: {
      value: sourceInputKubeLogsPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKubeLogsPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputKubeLogsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKubeLogsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rules: {
      value: cdktf.listMapperHcl(sourceInputKubeLogsRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeLogsRulesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timestamps: {
      value: cdktf.booleanToHclTerraform(struct!.timestamps),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKubeLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._timestamps !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestamps = this._timestamps;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._breakerRulesets = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableLoadBalancing = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._timestamps = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._breakerRulesets = value.breakerRulesets;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rules.internalValue = value.rules;
      this._sendToRoutes = value.sendToRoutes;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._timestamps = value.timestamps;
      this._type = value.type;
    }
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputKubeLogsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputKubeLogsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputKubeLogsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputKubeLogsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new SourceInputKubeLogsPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: SourceInputKubeLogsPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputKubeLogsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputKubeLogsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new SourceInputKubeLogsRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: SourceInputKubeLogsRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // timestamps - computed: true, optional: true, required: false
  private _timestamps?: boolean | cdktf.IResolvable; 
  public get timestamps() {
    return this.getBooleanAttribute('timestamps');
  }
  public set timestamps(value: boolean | cdktf.IResolvable) {
    this._timestamps = value;
  }
  public resetTimestamps() {
    this._timestamps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampsInput() {
    return this._timestamps;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputKubeMetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputKubeMetricsConnectionsToTerraform(struct?: SourceInputKubeMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputKubeMetricsConnectionsToHclTerraform(struct?: SourceInputKubeMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeMetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeMetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeMetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputKubeMetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeMetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeMetricsConnectionsOutputReference {
    return new SourceInputKubeMetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeMetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputKubeMetricsMetadataToTerraform(struct?: SourceInputKubeMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputKubeMetricsMetadataToHclTerraform(struct?: SourceInputKubeMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeMetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeMetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeMetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputKubeMetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeMetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeMetricsMetadataOutputReference {
    return new SourceInputKubeMetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeMetricsPersistence {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>. Default: "$CRIBL_HOME/state/kube_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#dest_path Source#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool metrics on disk for Cribl Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_size Source#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_time Source#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#time_window Source#time_window}
  */
  readonly timeWindow?: string;
}

export function sourceInputKubeMetricsPersistenceToTerraform(struct?: SourceInputKubeMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function sourceInputKubeMetricsPersistenceToHclTerraform(struct?: SourceInputKubeMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeMetricsPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKubeMetricsPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeMetricsPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface SourceInputKubeMetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputKubeMetricsPqToTerraform(struct?: SourceInputKubeMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputKubeMetricsPqToHclTerraform(struct?: SourceInputKubeMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeMetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKubeMetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeMetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputKubeMetricsRules {
  /**
  * Optional description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression applied to Kubernetes objects. Return 'true' to include it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#filter Source#filter}
  */
  readonly filter: string;
}

export function sourceInputKubeMetricsRulesToTerraform(struct?: SourceInputKubeMetricsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
  }
}


export function sourceInputKubeMetricsRulesToHclTerraform(struct?: SourceInputKubeMetricsRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeMetricsRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputKubeMetricsRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeMetricsRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }
}

export class SourceInputKubeMetricsRulesList extends cdktf.ComplexList {
  public internalValue? : SourceInputKubeMetricsRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputKubeMetricsRulesOutputReference {
    return new SourceInputKubeMetricsRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputKubeMetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputKubeMetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between consecutive metrics collections. Default is 15 secs. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputKubeMetricsMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#persistence Source#persistence}
  */
  readonly persistence?: SourceInputKubeMetricsPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputKubeMetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#rules Source#rules}
  */
  readonly rules?: SourceInputKubeMetricsRules[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "kube_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
}

export function sourceInputKubeMetricsToTerraform(struct?: SourceInputKubeMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputKubeMetricsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(sourceInputKubeMetricsMetadataToTerraform, false)(struct!.metadata),
    persistence: sourceInputKubeMetricsPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputKubeMetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    rules: cdktf.listMapper(sourceInputKubeMetricsRulesToTerraform, false)(struct!.rules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputKubeMetricsToHclTerraform(struct?: SourceInputKubeMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputKubeMetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeMetricsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputKubeMetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeMetricsMetadataList",
    },
    persistence: {
      value: sourceInputKubeMetricsPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKubeMetricsPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputKubeMetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputKubeMetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rules: {
      value: cdktf.listMapperHcl(sourceInputKubeMetricsRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputKubeMetricsRulesList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputKubeMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputKubeMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputKubeMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rules.internalValue = value.rules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputKubeMetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputKubeMetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputKubeMetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputKubeMetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new SourceInputKubeMetricsPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: SourceInputKubeMetricsPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputKubeMetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputKubeMetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new SourceInputKubeMetricsRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: SourceInputKubeMetricsRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputLokiConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputLokiConnectionsToTerraform(struct?: SourceInputLokiConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputLokiConnectionsToHclTerraform(struct?: SourceInputLokiConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputLokiConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputLokiConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputLokiConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputLokiConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputLokiConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputLokiConnectionsOutputReference {
    return new SourceInputLokiConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputLokiMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputLokiMetadataToTerraform(struct?: SourceInputLokiMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputLokiMetadataToHclTerraform(struct?: SourceInputLokiMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputLokiMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputLokiMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputLokiMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputLokiMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputLokiMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputLokiMetadataOutputReference {
    return new SourceInputLokiMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputLokiOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputLokiOauthHeadersToTerraform(struct?: SourceInputLokiOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputLokiOauthHeadersToHclTerraform(struct?: SourceInputLokiOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputLokiOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputLokiOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputLokiOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputLokiOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : SourceInputLokiOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputLokiOauthHeadersOutputReference {
    return new SourceInputLokiOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputLokiOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputLokiOauthParamsToTerraform(struct?: SourceInputLokiOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputLokiOauthParamsToHclTerraform(struct?: SourceInputLokiOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputLokiOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputLokiOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputLokiOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputLokiOauthParamsList extends cdktf.ComplexList {
  public internalValue? : SourceInputLokiOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputLokiOauthParamsOutputReference {
    return new SourceInputLokiOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputLokiPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputLokiPqToTerraform(struct?: SourceInputLokiPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputLokiPqToHclTerraform(struct?: SourceInputLokiPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputLokiPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputLokiPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputLokiPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputLokiTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputLokiTlsToTerraform(struct?: SourceInputLokiTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputLokiTlsToHclTerraform(struct?: SourceInputLokiTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputLokiTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputLokiTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputLokiTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputLoki {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#activity_log_sample_rate Source#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_header_expr Source#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Loki logs authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#capture_headers Source#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputLokiConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#credentials_secret Source#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_health_check Source#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_allowlist_regex Source#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_denylist_regex Source#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_timeout Source#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#login_url Source#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Default: "/loki/api/v1/push"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#loki_api Source#loki_api}
  */
  readonly lokiApi?: string;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_req Source#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_requests_per_socket Source#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputLokiMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#oauth_headers Source#oauth_headers}
  */
  readonly oauthHeaders?: SourceInputLokiOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#oauth_params Source#oauth_params}
  */
  readonly oauthParams?: SourceInputLokiOauthParams[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#password Source#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputLokiPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#secret Source#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#secret_param_name Source#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputLokiTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token Source#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_attribute_name Source#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_timeout_secs Source#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "loki"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#username Source#username}
  */
  readonly username?: string;
}

export function sourceInputLokiToTerraform(struct?: SourceInputLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(sourceInputLokiConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    loki_api: cdktf.stringToTerraform(struct!.lokiApi),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(sourceInputLokiMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(sourceInputLokiOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(sourceInputLokiOauthParamsToTerraform, false)(struct!.oauthParams),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputLokiPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: sourceInputLokiTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function sourceInputLokiToHclTerraform(struct?: SourceInputLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputLokiConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputLokiConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loki_api: {
      value: cdktf.stringToHclTerraform(struct!.lokiApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputLokiMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputLokiMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(sourceInputLokiOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputLokiOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(sourceInputLokiOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputLokiOauthParamsList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputLokiPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputLokiPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: sourceInputLokiTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputLokiTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputLokiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputLoki | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._lokiApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiApi = this._lokiApi;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputLoki | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._loginUrl = undefined;
      this._lokiApi = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._loginUrl = value.loginUrl;
      this._lokiApi = value.lokiApi;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._username = value.username;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputLokiConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputLokiConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // loki_api - computed: true, optional: true, required: false
  private _lokiApi?: string; 
  public get lokiApi() {
    return this.getStringAttribute('loki_api');
  }
  public set lokiApi(value: string) {
    this._lokiApi = value;
  }
  public resetLokiApi() {
    this._lokiApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiApiInput() {
    return this._lokiApi;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputLokiMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputLokiMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new SourceInputLokiOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: SourceInputLokiOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new SourceInputLokiOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: SourceInputLokiOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputLokiPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputLokiPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputLokiTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputLokiTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface SourceInputMetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputMetricsConnectionsToTerraform(struct?: SourceInputMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputMetricsConnectionsToHclTerraform(struct?: SourceInputMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputMetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputMetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputMetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputMetricsConnectionsOutputReference {
    return new SourceInputMetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputMetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputMetricsMetadataToTerraform(struct?: SourceInputMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputMetricsMetadataToHclTerraform(struct?: SourceInputMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputMetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputMetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputMetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputMetricsMetadataOutputReference {
    return new SourceInputMetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputMetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputMetricsPqToTerraform(struct?: SourceInputMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputMetricsPqToHclTerraform(struct?: SourceInputMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputMetricsTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputMetricsTlsToTerraform(struct?: SourceInputMetricsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputMetricsTlsToHclTerraform(struct?: SourceInputMetricsTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMetricsTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMetricsTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMetricsTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputMetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputMetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_whitelist_regex Source#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputMetricsMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputMetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Enter TCP port number to listen on. Not required if listening on UDP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tcp_port Source#tcp_port}
  */
  readonly tcpPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputMetricsTls;
  /**
  * must be "metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
  /**
  * Enter UDP port number to listen on. Not required if listening on TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_port Source#udp_port}
  */
  readonly udpPort?: number;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_socket_rx_buf_size Source#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
}

export function sourceInputMetricsToTerraform(struct?: SourceInputMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputMetricsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(sourceInputMetricsMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputMetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tcp_port: cdktf.numberToTerraform(struct!.tcpPort),
    tls: sourceInputMetricsTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    udp_port: cdktf.numberToTerraform(struct!.udpPort),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
  }
}


export function sourceInputMetricsToHclTerraform(struct?: SourceInputMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputMetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputMetricsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputMetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputMetricsMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputMetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputMetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tcp_port: {
      value: cdktf.numberToHclTerraform(struct!.tcpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: sourceInputMetricsTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputMetricsTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_port: {
      value: cdktf.numberToHclTerraform(struct!.udpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tcpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpPort = this._tcpPort;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpPort = this._udpPort;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._tcpPort = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._udpPort = undefined;
      this._udpSocketRxBufSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._tcpPort = value.tcpPort;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._udpPort = value.udpPort;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputMetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputMetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputMetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputMetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputMetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputMetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tcp_port - computed: false, optional: true, required: false
  private _tcpPort?: number; 
  public get tcpPort() {
    return this.getNumberAttribute('tcp_port');
  }
  public set tcpPort(value: number) {
    this._tcpPort = value;
  }
  public resetTcpPort() {
    this._tcpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpPortInput() {
    return this._tcpPort;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputMetricsTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputMetricsTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_port - computed: false, optional: true, required: false
  private _udpPort?: number; 
  public get udpPort() {
    return this.getNumberAttribute('udp_port');
  }
  public set udpPort(value: number) {
    this._udpPort = value;
  }
  public resetUdpPort() {
    this._udpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpPortInput() {
    return this._udpPort;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }
}
export interface SourceInputModelDrivenTelemetryConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputModelDrivenTelemetryConnectionsToTerraform(struct?: SourceInputModelDrivenTelemetryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputModelDrivenTelemetryConnectionsToHclTerraform(struct?: SourceInputModelDrivenTelemetryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputModelDrivenTelemetryConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputModelDrivenTelemetryConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputModelDrivenTelemetryConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputModelDrivenTelemetryConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputModelDrivenTelemetryConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputModelDrivenTelemetryConnectionsOutputReference {
    return new SourceInputModelDrivenTelemetryConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputModelDrivenTelemetryMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputModelDrivenTelemetryMetadataToTerraform(struct?: SourceInputModelDrivenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputModelDrivenTelemetryMetadataToHclTerraform(struct?: SourceInputModelDrivenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputModelDrivenTelemetryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputModelDrivenTelemetryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputModelDrivenTelemetryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputModelDrivenTelemetryMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputModelDrivenTelemetryMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputModelDrivenTelemetryMetadataOutputReference {
    return new SourceInputModelDrivenTelemetryMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputModelDrivenTelemetryPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputModelDrivenTelemetryPqToTerraform(struct?: SourceInputModelDrivenTelemetryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputModelDrivenTelemetryPqToHclTerraform(struct?: SourceInputModelDrivenTelemetryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputModelDrivenTelemetryPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputModelDrivenTelemetryPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputModelDrivenTelemetryPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputModelDrivenTelemetryTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputModelDrivenTelemetryTlsToTerraform(struct?: SourceInputModelDrivenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputModelDrivenTelemetryTlsToHclTerraform(struct?: SourceInputModelDrivenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputModelDrivenTelemetryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputModelDrivenTelemetryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputModelDrivenTelemetryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputModelDrivenTelemetry {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputModelDrivenTelemetryConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_cxn Source#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputModelDrivenTelemetryMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on. Default: 57000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputModelDrivenTelemetryPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000. Default: 5000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#shutdown_timeout_ms Source#shutdown_timeout_ms}
  */
  readonly shutdownTimeoutMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputModelDrivenTelemetryTls;
  /**
  * must be "model_driven_telemetry"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputModelDrivenTelemetryToTerraform(struct?: SourceInputModelDrivenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputModelDrivenTelemetryConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    metadata: cdktf.listMapper(sourceInputModelDrivenTelemetryMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputModelDrivenTelemetryPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    shutdown_timeout_ms: cdktf.numberToTerraform(struct!.shutdownTimeoutMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: sourceInputModelDrivenTelemetryTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputModelDrivenTelemetryToHclTerraform(struct?: SourceInputModelDrivenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputModelDrivenTelemetryConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputModelDrivenTelemetryConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputModelDrivenTelemetryMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputModelDrivenTelemetryMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputModelDrivenTelemetryPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputModelDrivenTelemetryPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    shutdown_timeout_ms: {
      value: cdktf.numberToHclTerraform(struct!.shutdownTimeoutMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: sourceInputModelDrivenTelemetryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputModelDrivenTelemetryTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputModelDrivenTelemetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputModelDrivenTelemetry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._shutdownTimeoutMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.shutdownTimeoutMs = this._shutdownTimeoutMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputModelDrivenTelemetry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._maxActiveCxn = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._shutdownTimeoutMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._maxActiveCxn = value.maxActiveCxn;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._shutdownTimeoutMs = value.shutdownTimeoutMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputModelDrivenTelemetryConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputModelDrivenTelemetryConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputModelDrivenTelemetryMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputModelDrivenTelemetryMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputModelDrivenTelemetryPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputModelDrivenTelemetryPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // shutdown_timeout_ms - computed: true, optional: true, required: false
  private _shutdownTimeoutMs?: number; 
  public get shutdownTimeoutMs() {
    return this.getNumberAttribute('shutdown_timeout_ms');
  }
  public set shutdownTimeoutMs(value: number) {
    this._shutdownTimeoutMs = value;
  }
  public resetShutdownTimeoutMs() {
    this._shutdownTimeoutMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shutdownTimeoutMsInput() {
    return this._shutdownTimeoutMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputModelDrivenTelemetryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputModelDrivenTelemetryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputMskConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputMskConnectionsToTerraform(struct?: SourceInputMskConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputMskConnectionsToHclTerraform(struct?: SourceInputMskConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMskConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputMskConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMskConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputMskConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputMskConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputMskConnectionsOutputReference {
    return new SourceInputMskConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputMskKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#credentials_secret Source#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function sourceInputMskKafkaSchemaRegistryAuthToTerraform(struct?: SourceInputMskKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function sourceInputMskKafkaSchemaRegistryAuthToHclTerraform(struct?: SourceInputMskKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMskKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMskKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMskKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface SourceInputMskKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#servername Source#servername}
  */
  readonly servername?: string;
}

export function sourceInputMskKafkaSchemaRegistryTlsToTerraform(struct?: SourceInputMskKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function sourceInputMskKafkaSchemaRegistryTlsToHclTerraform(struct?: SourceInputMskKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMskKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMskKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMskKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface SourceInputMskKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth Source#auth}
  */
  readonly auth?: SourceInputMskKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connection_timeout Source#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_retries Source#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#schema_registry_url Source#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputMskKafkaSchemaRegistryTls;
}

export function sourceInputMskKafkaSchemaRegistryToTerraform(struct?: SourceInputMskKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: sourceInputMskKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: sourceInputMskKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function sourceInputMskKafkaSchemaRegistryToHclTerraform(struct?: SourceInputMskKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: sourceInputMskKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputMskKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: sourceInputMskKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputMskKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMskKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMskKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMskKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new SourceInputMskKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: SourceInputMskKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputMskKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputMskKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface SourceInputMskMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputMskMetadataToTerraform(struct?: SourceInputMskMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputMskMetadataToHclTerraform(struct?: SourceInputMskMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMskMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputMskMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMskMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputMskMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputMskMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputMskMetadataOutputReference {
    return new SourceInputMskMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputMskPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputMskPqToTerraform(struct?: SourceInputMskPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputMskPqToHclTerraform(struct?: SourceInputMskPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMskPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMskPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMskPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputMskTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#servername Source#servername}
  */
  readonly servername?: string;
}

export function sourceInputMskTlsToTerraform(struct?: SourceInputMskTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function sourceInputMskTlsToHclTerraform(struct?: SourceInputMskTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMskTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMskTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMskTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface SourceInputMsk {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_arn Source#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_external_id Source#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#authentication_timeout Source#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auto_commit_interval Source#auto_commit_interval}
  */
  readonly autoCommitInterval?: number;
  /**
  * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auto_commit_threshold Source#auto_commit_threshold}
  */
  readonly autoCommitThreshold?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_api_key Source#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_authentication_method Source#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret Source#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret_key Source#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#backoff_rate Source#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#brokers Source#brokers}
  */
  readonly brokers: string[];
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connection_timeout Source#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputMskConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#duration_seconds Source#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access MSK. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_assume_role Source#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#from_beginning Source#from_beginning}
  */
  readonly fromBeginning?: boolean | cdktf.IResolvable;
  /**
  * The consumer group to which this instance belongs. Defaults to 'Cribl'. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#group_id Source#group_id}
  */
  readonly groupId?: string;
  /**
  * Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
  *     Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
  * Default: 3000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#heartbeat_interval Source#heartbeat_interval}
  */
  readonly heartbeatInterval?: number;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#initial_backoff Source#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#kafka_schema_registry Source#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: SourceInputMskKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_back_off Source#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB). Default: 10485760
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_bytes Source#max_bytes}
  */
  readonly maxBytes?: number;
  /**
  * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB). Default: 1048576
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_bytes_per_partition Source#max_bytes_per_partition}
  */
  readonly maxBytesPerPartition?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_retries Source#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum number of network errors before the consumer re-creates a socket. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_socket_errors Source#max_socket_errors}
  */
  readonly maxSocketErrors?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputMskMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputMskPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reauthentication_threshold Source#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum allowed time for each worker to join the group after a rebalance begins.
  *     If the timeout is exceeded, the coordinator broker will remove the worker from the group.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
  * Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#rebalance_timeout Source#rebalance_timeout}
  */
  readonly rebalanceTimeout?: number;
  /**
  * Region where the MSK cluster is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#region Source#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reuse_connections Source#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Timeout used to detect client failures when using Kafka's group-management facilities.
  *     If the client sends no heartbeats to the broker before the timeout expires, 
  *     the broker will remove the client from the group and initiate a rebalance.
  *     Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
  *     See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
  * Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#session_timeout Source#session_timeout}
  */
  readonly sessionTimeout?: number;
  /**
  * Signature version to use for signing MSK cluster requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#signature_version Source#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputMskTls;
  /**
  * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#topics Source#topics}
  */
  readonly topics?: string[];
  /**
  * must be "msk"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputMskToTerraform(struct?: SourceInputMsk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    auto_commit_interval: cdktf.numberToTerraform(struct!.autoCommitInterval),
    auto_commit_threshold: cdktf.numberToTerraform(struct!.autoCommitThreshold),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    connections: cdktf.listMapper(sourceInputMskConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    from_beginning: cdktf.booleanToTerraform(struct!.fromBeginning),
    group_id: cdktf.stringToTerraform(struct!.groupId),
    heartbeat_interval: cdktf.numberToTerraform(struct!.heartbeatInterval),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: sourceInputMskKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_bytes: cdktf.numberToTerraform(struct!.maxBytes),
    max_bytes_per_partition: cdktf.numberToTerraform(struct!.maxBytesPerPartition),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    max_socket_errors: cdktf.numberToTerraform(struct!.maxSocketErrors),
    metadata: cdktf.listMapper(sourceInputMskMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputMskPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    rebalance_timeout: cdktf.numberToTerraform(struct!.rebalanceTimeout),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    session_timeout: cdktf.numberToTerraform(struct!.sessionTimeout),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: sourceInputMskTlsToTerraform(struct!.tls),
    topics: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.topics),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputMskToHclTerraform(struct?: SourceInputMsk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_interval: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auto_commit_threshold: {
      value: cdktf.numberToHclTerraform(struct!.autoCommitThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputMskConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputMskConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    from_beginning: {
      value: cdktf.booleanToHclTerraform(struct!.fromBeginning),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    group_id: {
      value: cdktf.stringToHclTerraform(struct!.groupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.numberToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: sourceInputMskKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputMskKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_bytes_per_partition: {
      value: cdktf.numberToHclTerraform(struct!.maxBytesPerPartition),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_socket_errors: {
      value: cdktf.numberToHclTerraform(struct!.maxSocketErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputMskMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputMskMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputMskPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputMskPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    rebalance_timeout: {
      value: cdktf.numberToHclTerraform(struct!.rebalanceTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    session_timeout: {
      value: cdktf.numberToHclTerraform(struct!.sessionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: sourceInputMskTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputMskTls",
    },
    topics: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.topics),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputMskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputMsk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._autoCommitInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitInterval = this._autoCommitInterval;
    }
    if (this._autoCommitThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoCommitThreshold = this._autoCommitThreshold;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fromBeginning !== undefined) {
      hasAnyValues = true;
      internalValueResult.fromBeginning = this._fromBeginning;
    }
    if (this._groupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupId = this._groupId;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytes = this._maxBytes;
    }
    if (this._maxBytesPerPartition !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBytesPerPartition = this._maxBytesPerPartition;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._maxSocketErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSocketErrors = this._maxSocketErrors;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._rebalanceTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.rebalanceTimeout = this._rebalanceTimeout;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._sessionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTimeout = this._sessionTimeout;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topics !== undefined) {
      hasAnyValues = true;
      internalValueResult.topics = this._topics;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputMsk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._authenticationTimeout = undefined;
      this._autoCommitInterval = undefined;
      this._autoCommitThreshold = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._connectionTimeout = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fromBeginning = undefined;
      this._groupId = undefined;
      this._heartbeatInterval = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxBytes = undefined;
      this._maxBytesPerPartition = undefined;
      this._maxRetries = undefined;
      this._maxSocketErrors = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._reauthenticationThreshold = undefined;
      this._rebalanceTimeout = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._requestTimeout = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._sessionTimeout = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._topics = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._authenticationTimeout = value.authenticationTimeout;
      this._autoCommitInterval = value.autoCommitInterval;
      this._autoCommitThreshold = value.autoCommitThreshold;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._connectionTimeout = value.connectionTimeout;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fromBeginning = value.fromBeginning;
      this._groupId = value.groupId;
      this._heartbeatInterval = value.heartbeatInterval;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxBytes = value.maxBytes;
      this._maxBytesPerPartition = value.maxBytesPerPartition;
      this._maxRetries = value.maxRetries;
      this._maxSocketErrors = value.maxSocketErrors;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._rebalanceTimeout = value.rebalanceTimeout;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestTimeout = value.requestTimeout;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._sessionTimeout = value.sessionTimeout;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._topics = value.topics;
      this._type = value.type;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // auto_commit_interval - computed: false, optional: true, required: false
  private _autoCommitInterval?: number; 
  public get autoCommitInterval() {
    return this.getNumberAttribute('auto_commit_interval');
  }
  public set autoCommitInterval(value: number) {
    this._autoCommitInterval = value;
  }
  public resetAutoCommitInterval() {
    this._autoCommitInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitIntervalInput() {
    return this._autoCommitInterval;
  }

  // auto_commit_threshold - computed: false, optional: true, required: false
  private _autoCommitThreshold?: number; 
  public get autoCommitThreshold() {
    return this.getNumberAttribute('auto_commit_threshold');
  }
  public set autoCommitThreshold(value: number) {
    this._autoCommitThreshold = value;
  }
  public resetAutoCommitThreshold() {
    this._autoCommitThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoCommitThresholdInput() {
    return this._autoCommitThreshold;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputMskConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputMskConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // from_beginning - computed: true, optional: true, required: false
  private _fromBeginning?: boolean | cdktf.IResolvable; 
  public get fromBeginning() {
    return this.getBooleanAttribute('from_beginning');
  }
  public set fromBeginning(value: boolean | cdktf.IResolvable) {
    this._fromBeginning = value;
  }
  public resetFromBeginning() {
    this._fromBeginning = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromBeginningInput() {
    return this._fromBeginning;
  }

  // group_id - computed: true, optional: true, required: false
  private _groupId?: string; 
  public get groupId() {
    return this.getStringAttribute('group_id');
  }
  public set groupId(value: string) {
    this._groupId = value;
  }
  public resetGroupId() {
    this._groupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIdInput() {
    return this._groupId;
  }

  // heartbeat_interval - computed: true, optional: true, required: false
  private _heartbeatInterval?: number; 
  public get heartbeatInterval() {
    return this.getNumberAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: number) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new SourceInputMskKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: SourceInputMskKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_bytes - computed: true, optional: true, required: false
  private _maxBytes?: number; 
  public get maxBytes() {
    return this.getNumberAttribute('max_bytes');
  }
  public set maxBytes(value: number) {
    this._maxBytes = value;
  }
  public resetMaxBytes() {
    this._maxBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesInput() {
    return this._maxBytes;
  }

  // max_bytes_per_partition - computed: true, optional: true, required: false
  private _maxBytesPerPartition?: number; 
  public get maxBytesPerPartition() {
    return this.getNumberAttribute('max_bytes_per_partition');
  }
  public set maxBytesPerPartition(value: number) {
    this._maxBytesPerPartition = value;
  }
  public resetMaxBytesPerPartition() {
    this._maxBytesPerPartition = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBytesPerPartitionInput() {
    return this._maxBytesPerPartition;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // max_socket_errors - computed: true, optional: true, required: false
  private _maxSocketErrors?: number; 
  public get maxSocketErrors() {
    return this.getNumberAttribute('max_socket_errors');
  }
  public set maxSocketErrors(value: number) {
    this._maxSocketErrors = value;
  }
  public resetMaxSocketErrors() {
    this._maxSocketErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSocketErrorsInput() {
    return this._maxSocketErrors;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputMskMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputMskMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputMskPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputMskPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // rebalance_timeout - computed: true, optional: true, required: false
  private _rebalanceTimeout?: number; 
  public get rebalanceTimeout() {
    return this.getNumberAttribute('rebalance_timeout');
  }
  public set rebalanceTimeout(value: number) {
    this._rebalanceTimeout = value;
  }
  public resetRebalanceTimeout() {
    this._rebalanceTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rebalanceTimeoutInput() {
    return this._rebalanceTimeout;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // session_timeout - computed: true, optional: true, required: false
  private _sessionTimeout?: number; 
  public get sessionTimeout() {
    return this.getNumberAttribute('session_timeout');
  }
  public set sessionTimeout(value: number) {
    this._sessionTimeout = value;
  }
  public resetSessionTimeout() {
    this._sessionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTimeoutInput() {
    return this._sessionTimeout;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputMskTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputMskTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topics - computed: true, optional: true, required: false
  private _topics?: string[]; 
  public get topics() {
    return this.getListAttribute('topics');
  }
  public set topics(value: string[]) {
    this._topics = value;
  }
  public resetTopics() {
    this._topics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topicsInput() {
    return this._topics;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputNetflowConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputNetflowConnectionsToTerraform(struct?: SourceInputNetflowConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputNetflowConnectionsToHclTerraform(struct?: SourceInputNetflowConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputNetflowConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputNetflowConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputNetflowConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputNetflowConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputNetflowConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputNetflowConnectionsOutputReference {
    return new SourceInputNetflowConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputNetflowMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputNetflowMetadataToTerraform(struct?: SourceInputNetflowMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputNetflowMetadataToHclTerraform(struct?: SourceInputNetflowMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputNetflowMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputNetflowMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputNetflowMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputNetflowMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputNetflowMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputNetflowMetadataOutputReference {
    return new SourceInputNetflowMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputNetflowPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputNetflowPqToTerraform(struct?: SourceInputNetflowPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputNetflowPqToHclTerraform(struct?: SourceInputNetflowPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputNetflowPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputNetflowPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputNetflowPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputNetflow {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputNetflowConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_pass_through Source#enable_pass_through}
  */
  readonly enablePassThrough?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_allowlist_regex Source#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_denylist_regex Source#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * Accept messages in IPFIX format. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ipfix_enabled Source#ipfix_enabled}
  */
  readonly ipfixEnabled?: boolean | cdktf.IResolvable;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputNetflowMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on. Default: 2055
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputNetflowPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#template_cache_minutes Source#template_cache_minutes}
  */
  readonly templateCacheMinutes?: number;
  /**
  * must be "netflow"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_socket_rx_buf_size Source#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
  /**
  * Accept messages in Netflow V5 format. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#v5_enabled Source#v5_enabled}
  */
  readonly v5Enabled?: boolean | cdktf.IResolvable;
  /**
  * Accept messages in Netflow V9 format. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#v9_enabled Source#v9_enabled}
  */
  readonly v9Enabled?: boolean | cdktf.IResolvable;
}

export function sourceInputNetflowToTerraform(struct?: SourceInputNetflow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputNetflowConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_pass_through: cdktf.booleanToTerraform(struct!.enablePassThrough),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    ipfix_enabled: cdktf.booleanToTerraform(struct!.ipfixEnabled),
    metadata: cdktf.listMapper(sourceInputNetflowMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputNetflowPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    template_cache_minutes: cdktf.numberToTerraform(struct!.templateCacheMinutes),
    type: cdktf.stringToTerraform(struct!.type),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
    v5_enabled: cdktf.booleanToTerraform(struct!.v5Enabled),
    v9_enabled: cdktf.booleanToTerraform(struct!.v9Enabled),
  }
}


export function sourceInputNetflowToHclTerraform(struct?: SourceInputNetflow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputNetflowConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputNetflowConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_pass_through: {
      value: cdktf.booleanToHclTerraform(struct!.enablePassThrough),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipfix_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.ipfixEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputNetflowMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputNetflowMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputNetflowPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputNetflowPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    template_cache_minutes: {
      value: cdktf.numberToHclTerraform(struct!.templateCacheMinutes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    v5_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.v5Enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    v9_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.v9Enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputNetflowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputNetflow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enablePassThrough !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePassThrough = this._enablePassThrough;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._ipfixEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipfixEnabled = this._ipfixEnabled;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._templateCacheMinutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.templateCacheMinutes = this._templateCacheMinutes;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    if (this._v5Enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.v5Enabled = this._v5Enabled;
    }
    if (this._v9Enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.v9Enabled = this._v9Enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputNetflow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enablePassThrough = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._ipfixEnabled = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._templateCacheMinutes = undefined;
      this._type = undefined;
      this._udpSocketRxBufSize = undefined;
      this._v5Enabled = undefined;
      this._v9Enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enablePassThrough = value.enablePassThrough;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._ipfixEnabled = value.ipfixEnabled;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._templateCacheMinutes = value.templateCacheMinutes;
      this._type = value.type;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
      this._v5Enabled = value.v5Enabled;
      this._v9Enabled = value.v9Enabled;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputNetflowConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputNetflowConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_pass_through - computed: true, optional: true, required: false
  private _enablePassThrough?: boolean | cdktf.IResolvable; 
  public get enablePassThrough() {
    return this.getBooleanAttribute('enable_pass_through');
  }
  public set enablePassThrough(value: boolean | cdktf.IResolvable) {
    this._enablePassThrough = value;
  }
  public resetEnablePassThrough() {
    this._enablePassThrough = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePassThroughInput() {
    return this._enablePassThrough;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // ipfix_enabled - computed: true, optional: true, required: false
  private _ipfixEnabled?: boolean | cdktf.IResolvable; 
  public get ipfixEnabled() {
    return this.getBooleanAttribute('ipfix_enabled');
  }
  public set ipfixEnabled(value: boolean | cdktf.IResolvable) {
    this._ipfixEnabled = value;
  }
  public resetIpfixEnabled() {
    this._ipfixEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipfixEnabledInput() {
    return this._ipfixEnabled;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputNetflowMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputNetflowMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputNetflowPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputNetflowPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // template_cache_minutes - computed: true, optional: true, required: false
  private _templateCacheMinutes?: number; 
  public get templateCacheMinutes() {
    return this.getNumberAttribute('template_cache_minutes');
  }
  public set templateCacheMinutes(value: number) {
    this._templateCacheMinutes = value;
  }
  public resetTemplateCacheMinutes() {
    this._templateCacheMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateCacheMinutesInput() {
    return this._templateCacheMinutes;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }

  // v5_enabled - computed: true, optional: true, required: false
  private _v5Enabled?: boolean | cdktf.IResolvable; 
  public get v5Enabled() {
    return this.getBooleanAttribute('v5_enabled');
  }
  public set v5Enabled(value: boolean | cdktf.IResolvable) {
    this._v5Enabled = value;
  }
  public resetV5Enabled() {
    this._v5Enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get v5EnabledInput() {
    return this._v5Enabled;
  }

  // v9_enabled - computed: true, optional: true, required: false
  private _v9Enabled?: boolean | cdktf.IResolvable; 
  public get v9Enabled() {
    return this.getBooleanAttribute('v9_enabled');
  }
  public set v9Enabled(value: boolean | cdktf.IResolvable) {
    this._v9Enabled = value;
  }
  public resetV9Enabled() {
    this._v9Enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get v9EnabledInput() {
    return this._v9Enabled;
  }
}
export interface SourceInputOffice365MgmtConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputOffice365MgmtConnectionsToTerraform(struct?: SourceInputOffice365MgmtConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputOffice365MgmtConnectionsToHclTerraform(struct?: SourceInputOffice365MgmtConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MgmtConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOffice365MgmtConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MgmtConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputOffice365MgmtConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputOffice365MgmtConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOffice365MgmtConnectionsOutputReference {
    return new SourceInputOffice365MgmtConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOffice365MgmtContentConfig {
  /**
  * Office 365 Management Activity API Content Type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#content_type Source#content_type}
  */
  readonly contentType: string;
  /**
  * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enabled Source#enabled}
  */
  readonly enabled: boolean | cdktf.IResolvable;
  /**
  * Interval, in minutes, between polls
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval: number;
  /**
  * must be one of ["error", "warn", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#log_level Source#log_level}
  */
  readonly logLevel: string;
}

export function sourceInputOffice365MgmtContentConfigToTerraform(struct?: SourceInputOffice365MgmtContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content_type: cdktf.stringToTerraform(struct!.contentType),
    description: cdktf.stringToTerraform(struct!.description),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    interval: cdktf.numberToTerraform(struct!.interval),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
  }
}


export function sourceInputOffice365MgmtContentConfigToHclTerraform(struct?: SourceInputOffice365MgmtContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MgmtContentConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOffice365MgmtContentConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MgmtContentConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contentType = undefined;
      this._description = undefined;
      this._enabled = undefined;
      this._interval = undefined;
      this._logLevel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contentType = value.contentType;
      this._description = value.description;
      this._enabled = value.enabled;
      this._interval = value.interval;
      this._logLevel = value.logLevel;
    }
  }

  // content_type - computed: false, optional: false, required: true
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: false, optional: false, required: true
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // interval - computed: false, optional: false, required: true
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // log_level - computed: false, optional: false, required: true
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }
}

export class SourceInputOffice365MgmtContentConfigList extends cdktf.ComplexList {
  public internalValue? : SourceInputOffice365MgmtContentConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOffice365MgmtContentConfigOutputReference {
    return new SourceInputOffice365MgmtContentConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOffice365MgmtMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputOffice365MgmtMetadataToTerraform(struct?: SourceInputOffice365MgmtMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputOffice365MgmtMetadataToHclTerraform(struct?: SourceInputOffice365MgmtMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MgmtMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOffice365MgmtMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MgmtMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputOffice365MgmtMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputOffice365MgmtMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOffice365MgmtMetadataOutputReference {
    return new SourceInputOffice365MgmtMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOffice365MgmtPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputOffice365MgmtPqToTerraform(struct?: SourceInputOffice365MgmtPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputOffice365MgmtPqToHclTerraform(struct?: SourceInputOffice365MgmtPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MgmtPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365MgmtPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MgmtPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputOffice365MgmtRetryRules {
  /**
  * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503. Default: [429,500,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#codes Source#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_header Source#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#limit Source#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#multiplier Source#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_reset Source#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_timeout Source#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputOffice365MgmtRetryRulesToTerraform(struct?: SourceInputOffice365MgmtRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputOffice365MgmtRetryRulesToHclTerraform(struct?: SourceInputOffice365MgmtRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MgmtRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365MgmtRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MgmtRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputOffice365Mgmt {
  /**
  * Office 365 Azure Application ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#app_id Source#app_id}
  */
  readonly appId: string;
  /**
  * Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Office 365 Azure client secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#client_secret Source#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputOffice365MgmtConnections[] | cdktf.IResolvable;
  /**
  * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#content_config Source#content_config}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly contentConfig?: SourceInputOffice365MgmtContentConfig[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ignore_group_jobs_limit Source#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ingestion_lag Source#ingestion_lag}
  */
  readonly ingestionLag?: number;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#job_timeout Source#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_time Source#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_missed_keep_alives Source#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputOffice365MgmtMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#plan_type Source#plan_type}
  */
  readonly planType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputOffice365MgmtPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#publisher_identifier Source#publisher_identifier}
  */
  readonly publisherIdentifier?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_rules Source#retry_rules}
  */
  readonly retryRules?: SourceInputOffice365MgmtRetryRules;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Office 365 Azure Tenant ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tenant_id Source#tenant_id}
  */
  readonly tenantId: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * HTTP request inactivity timeout, use 0 to disable. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#timeout Source#timeout}
  */
  readonly timeout?: number;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ttl Source#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "office365_mgmt"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputOffice365MgmtToTerraform(struct?: SourceInputOffice365Mgmt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_id: cdktf.stringToTerraform(struct!.appId),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    connections: cdktf.listMapper(sourceInputOffice365MgmtConnectionsToTerraform, false)(struct!.connections),
    content_config: cdktf.listMapper(sourceInputOffice365MgmtContentConfigToTerraform, false)(struct!.contentConfig),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    ingestion_lag: cdktf.numberToTerraform(struct!.ingestionLag),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(sourceInputOffice365MgmtMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    plan_type: cdktf.stringToTerraform(struct!.planType),
    pq: sourceInputOffice365MgmtPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    publisher_identifier: cdktf.stringToTerraform(struct!.publisherIdentifier),
    retry_rules: sourceInputOffice365MgmtRetryRulesToTerraform(struct!.retryRules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout: cdktf.numberToTerraform(struct!.timeout),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputOffice365MgmtToHclTerraform(struct?: SourceInputOffice365Mgmt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_id: {
      value: cdktf.stringToHclTerraform(struct!.appId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputOffice365MgmtConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOffice365MgmtConnectionsList",
    },
    content_config: {
      value: cdktf.listMapperHcl(sourceInputOffice365MgmtContentConfigToHclTerraform, false)(struct!.contentConfig),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOffice365MgmtContentConfigList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ingestion_lag: {
      value: cdktf.numberToHclTerraform(struct!.ingestionLag),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputOffice365MgmtMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOffice365MgmtMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plan_type: {
      value: cdktf.stringToHclTerraform(struct!.planType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputOffice365MgmtPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOffice365MgmtPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    publisher_identifier: {
      value: cdktf.stringToHclTerraform(struct!.publisherIdentifier),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retry_rules: {
      value: sourceInputOffice365MgmtRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOffice365MgmtRetryRules",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MgmtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365Mgmt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appId !== undefined) {
      hasAnyValues = true;
      internalValueResult.appId = this._appId;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._contentConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentConfig = this._contentConfig?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._ingestionLag !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestionLag = this._ingestionLag;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._planType !== undefined) {
      hasAnyValues = true;
      internalValueResult.planType = this._planType;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._publisherIdentifier !== undefined) {
      hasAnyValues = true;
      internalValueResult.publisherIdentifier = this._publisherIdentifier;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365Mgmt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appId = undefined;
      this._authType = undefined;
      this._clientSecret = undefined;
      this._connections.internalValue = undefined;
      this._contentConfig.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._ingestionLag = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._planType = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._publisherIdentifier = undefined;
      this._retryRules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._timeout = undefined;
      this._ttl = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appId = value.appId;
      this._authType = value.authType;
      this._clientSecret = value.clientSecret;
      this._connections.internalValue = value.connections;
      this._contentConfig.internalValue = value.contentConfig;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._ingestionLag = value.ingestionLag;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._planType = value.planType;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._publisherIdentifier = value.publisherIdentifier;
      this._retryRules.internalValue = value.retryRules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._timeout = value.timeout;
      this._ttl = value.ttl;
      this._type = value.type;
    }
  }

  // app_id - computed: false, optional: false, required: true
  private _appId?: string; 
  public get appId() {
    return this.getStringAttribute('app_id');
  }
  public set appId(value: string) {
    this._appId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get appIdInput() {
    return this._appId;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputOffice365MgmtConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputOffice365MgmtConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // content_config - computed: false, optional: true, required: false
  private _contentConfig = new SourceInputOffice365MgmtContentConfigList(this, "content_config", false);
  public get contentConfig() {
    return this._contentConfig;
  }
  public putContentConfig(value: SourceInputOffice365MgmtContentConfig[] | cdktf.IResolvable) {
    this._contentConfig.internalValue = value;
  }
  public resetContentConfig() {
    this._contentConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentConfigInput() {
    return this._contentConfig.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // ingestion_lag - computed: true, optional: true, required: false
  private _ingestionLag?: number; 
  public get ingestionLag() {
    return this.getNumberAttribute('ingestion_lag');
  }
  public set ingestionLag(value: number) {
    this._ingestionLag = value;
  }
  public resetIngestionLag() {
    this._ingestionLag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestionLagInput() {
    return this._ingestionLag;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputOffice365MgmtMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputOffice365MgmtMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // plan_type - computed: true, optional: true, required: false
  private _planType?: string; 
  public get planType() {
    return this.getStringAttribute('plan_type');
  }
  public set planType(value: string) {
    this._planType = value;
  }
  public resetPlanType() {
    this._planType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get planTypeInput() {
    return this._planType;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputOffice365MgmtPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputOffice365MgmtPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // publisher_identifier - computed: false, optional: true, required: false
  private _publisherIdentifier?: string; 
  public get publisherIdentifier() {
    return this.getStringAttribute('publisher_identifier');
  }
  public set publisherIdentifier(value: string) {
    this._publisherIdentifier = value;
  }
  public resetPublisherIdentifier() {
    this._publisherIdentifier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get publisherIdentifierInput() {
    return this._publisherIdentifier;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new SourceInputOffice365MgmtRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: SourceInputOffice365MgmtRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tenant_id - computed: false, optional: false, required: true
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout - computed: true, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputOffice365MsgTraceCertOptions {
  /**
  * Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath: string;
  /**
  * The name of the predefined certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Passphrase to use to decrypt the private key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath: string;
}

export function sourceInputOffice365MsgTraceCertOptionsToTerraform(struct?: SourceInputOffice365MsgTraceCertOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
  }
}


export function sourceInputOffice365MsgTraceCertOptionsToHclTerraform(struct?: SourceInputOffice365MsgTraceCertOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MsgTraceCertOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365MsgTraceCertOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MsgTraceCertOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
    }
  }

  // cert_path - computed: false, optional: false, required: true
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: false, required: true
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }
}
export interface SourceInputOffice365MsgTraceConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputOffice365MsgTraceConnectionsToTerraform(struct?: SourceInputOffice365MsgTraceConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputOffice365MsgTraceConnectionsToHclTerraform(struct?: SourceInputOffice365MsgTraceConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MsgTraceConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOffice365MsgTraceConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MsgTraceConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputOffice365MsgTraceConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputOffice365MsgTraceConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOffice365MsgTraceConnectionsOutputReference {
    return new SourceInputOffice365MsgTraceConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOffice365MsgTraceMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputOffice365MsgTraceMetadataToTerraform(struct?: SourceInputOffice365MsgTraceMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputOffice365MsgTraceMetadataToHclTerraform(struct?: SourceInputOffice365MsgTraceMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MsgTraceMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOffice365MsgTraceMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MsgTraceMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputOffice365MsgTraceMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputOffice365MsgTraceMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOffice365MsgTraceMetadataOutputReference {
    return new SourceInputOffice365MsgTraceMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOffice365MsgTracePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputOffice365MsgTracePqToTerraform(struct?: SourceInputOffice365MsgTracePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputOffice365MsgTracePqToHclTerraform(struct?: SourceInputOffice365MsgTracePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MsgTracePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365MsgTracePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MsgTracePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputOffice365MsgTraceRetryRules {
  /**
  * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503. Default: [429,500,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#codes Source#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_header Source#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#limit Source#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#multiplier Source#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_reset Source#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_timeout Source#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputOffice365MsgTraceRetryRulesToTerraform(struct?: SourceInputOffice365MsgTraceRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputOffice365MsgTraceRetryRulesToHclTerraform(struct?: SourceInputOffice365MsgTraceRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MsgTraceRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365MsgTraceRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MsgTraceRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputOffice365MsgTrace {
  /**
  * Select authentication method. Default: "oauth"; must be one of ["manual", "secret", "oauth", "oauthSecret", "oauthCert"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_options Source#cert_options}
  */
  readonly certOptions?: SourceInputOffice365MsgTraceCertOptions;
  /**
  * client_id to pass in the OAuth request parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#client_id Source#client_id}
  */
  readonly clientId?: string;
  /**
  * client_secret to pass in the OAuth request parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#client_secret Source#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputOffice365MsgTraceConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#credentials_secret Source#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Disables time filtering of events when a date range is specified. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disable_time_filter Source#disable_time_filter}
  */
  readonly disableTimeFilter?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#end_date Source#end_date}
  */
  readonly endDate?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ignore_group_jobs_limit Source#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#job_timeout Source#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_time Source#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * Log Level (verbosity) for collection runtime behavior. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#log_level Source#log_level}
  */
  readonly logLevel?: string;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_missed_keep_alives Source#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Maximum number of times a task can be rescheduled. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_task_reschedule Source#max_task_reschedule}
  */
  readonly maxTaskReschedule?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputOffice365MsgTraceMetadata[] | cdktf.IResolvable;
  /**
  * Password to run Message Trace API call.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#password Source#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#plan_type Source#plan_type}
  */
  readonly planType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputOffice365MsgTracePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Reschedule tasks that failed with non-fatal errors. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reschedule_dropped_tasks Source#reschedule_dropped_tasks}
  */
  readonly rescheduleDroppedTasks?: boolean | cdktf.IResolvable;
  /**
  * Resource to pass in the OAuth request parameter. Default: "https://outlook.office365.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#resource Source#resource}
  */
  readonly resource?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_rules Source#retry_rules}
  */
  readonly retryRules?: SourceInputOffice365MsgTraceRetryRules;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#start_date Source#start_date}
  */
  readonly startDate?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Directory ID (tenant identifier) in Azure Active Directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tenant_id Source#tenant_id}
  */
  readonly tenantId?: string;
  /**
  * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#timeout Source#timeout}
  */
  readonly timeout?: number;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ttl Source#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "office365_msg_trace"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * URL to use when retrieving report data. Default: "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#url Source#url}
  */
  readonly url?: string;
  /**
  * Username to run Message Trace API call.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#username Source#username}
  */
  readonly username?: string;
}

export function sourceInputOffice365MsgTraceToTerraform(struct?: SourceInputOffice365MsgTrace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    cert_options: sourceInputOffice365MsgTraceCertOptionsToTerraform(struct!.certOptions),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    connections: cdktf.listMapper(sourceInputOffice365MsgTraceConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    disable_time_filter: cdktf.booleanToTerraform(struct!.disableTimeFilter),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    end_date: cdktf.stringToTerraform(struct!.endDate),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    interval: cdktf.numberToTerraform(struct!.interval),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    max_task_reschedule: cdktf.numberToTerraform(struct!.maxTaskReschedule),
    metadata: cdktf.listMapper(sourceInputOffice365MsgTraceMetadataToTerraform, false)(struct!.metadata),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    plan_type: cdktf.stringToTerraform(struct!.planType),
    pq: sourceInputOffice365MsgTracePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reschedule_dropped_tasks: cdktf.booleanToTerraform(struct!.rescheduleDroppedTasks),
    resource: cdktf.stringToTerraform(struct!.resource),
    retry_rules: sourceInputOffice365MsgTraceRetryRulesToTerraform(struct!.retryRules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    start_date: cdktf.stringToTerraform(struct!.startDate),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout: cdktf.numberToTerraform(struct!.timeout),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function sourceInputOffice365MsgTraceToHclTerraform(struct?: SourceInputOffice365MsgTrace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_options: {
      value: sourceInputOffice365MsgTraceCertOptionsToHclTerraform(struct!.certOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOffice365MsgTraceCertOptions",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputOffice365MsgTraceConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOffice365MsgTraceConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_time_filter: {
      value: cdktf.booleanToHclTerraform(struct!.disableTimeFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    end_date: {
      value: cdktf.stringToHclTerraform(struct!.endDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_task_reschedule: {
      value: cdktf.numberToHclTerraform(struct!.maxTaskReschedule),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputOffice365MsgTraceMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOffice365MsgTraceMetadataList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plan_type: {
      value: cdktf.stringToHclTerraform(struct!.planType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputOffice365MsgTracePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOffice365MsgTracePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reschedule_dropped_tasks: {
      value: cdktf.booleanToHclTerraform(struct!.rescheduleDroppedTasks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    retry_rules: {
      value: sourceInputOffice365MsgTraceRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOffice365MsgTraceRetryRules",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    start_date: {
      value: cdktf.stringToHclTerraform(struct!.startDate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365MsgTraceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365MsgTrace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._certOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certOptions = this._certOptions?.internalValue;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disableTimeFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableTimeFilter = this._disableTimeFilter;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._endDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.endDate = this._endDate;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._maxTaskReschedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTaskReschedule = this._maxTaskReschedule;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._planType !== undefined) {
      hasAnyValues = true;
      internalValueResult.planType = this._planType;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rescheduleDroppedTasks !== undefined) {
      hasAnyValues = true;
      internalValueResult.rescheduleDroppedTasks = this._rescheduleDroppedTasks;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._startDate !== undefined) {
      hasAnyValues = true;
      internalValueResult.startDate = this._startDate;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365MsgTrace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._certOptions.internalValue = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._disableTimeFilter = undefined;
      this._disabled = undefined;
      this._endDate = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._interval = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._logLevel = undefined;
      this._maxMissedKeepAlives = undefined;
      this._maxTaskReschedule = undefined;
      this._metadata.internalValue = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._planType = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rescheduleDroppedTasks = undefined;
      this._resource = undefined;
      this._retryRules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._startDate = undefined;
      this._streamtags = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._timeout = undefined;
      this._ttl = undefined;
      this._type = undefined;
      this._url = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._certOptions.internalValue = value.certOptions;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._disableTimeFilter = value.disableTimeFilter;
      this._disabled = value.disabled;
      this._endDate = value.endDate;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._interval = value.interval;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._logLevel = value.logLevel;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._maxTaskReschedule = value.maxTaskReschedule;
      this._metadata.internalValue = value.metadata;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._planType = value.planType;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rescheduleDroppedTasks = value.rescheduleDroppedTasks;
      this._resource = value.resource;
      this._retryRules.internalValue = value.retryRules;
      this._sendToRoutes = value.sendToRoutes;
      this._startDate = value.startDate;
      this._streamtags = value.streamtags;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._timeout = value.timeout;
      this._ttl = value.ttl;
      this._type = value.type;
      this._url = value.url;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // cert_options - computed: false, optional: true, required: false
  private _certOptions = new SourceInputOffice365MsgTraceCertOptionsOutputReference(this, "cert_options");
  public get certOptions() {
    return this._certOptions;
  }
  public putCertOptions(value: SourceInputOffice365MsgTraceCertOptions) {
    this._certOptions.internalValue = value;
  }
  public resetCertOptions() {
    this._certOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certOptionsInput() {
    return this._certOptions.internalValue;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputOffice365MsgTraceConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputOffice365MsgTraceConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disable_time_filter - computed: true, optional: true, required: false
  private _disableTimeFilter?: boolean | cdktf.IResolvable; 
  public get disableTimeFilter() {
    return this.getBooleanAttribute('disable_time_filter');
  }
  public set disableTimeFilter(value: boolean | cdktf.IResolvable) {
    this._disableTimeFilter = value;
  }
  public resetDisableTimeFilter() {
    this._disableTimeFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableTimeFilterInput() {
    return this._disableTimeFilter;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // end_date - computed: false, optional: true, required: false
  private _endDate?: string; 
  public get endDate() {
    return this.getStringAttribute('end_date');
  }
  public set endDate(value: string) {
    this._endDate = value;
  }
  public resetEndDate() {
    this._endDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endDateInput() {
    return this._endDate;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // log_level - computed: true, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // max_task_reschedule - computed: true, optional: true, required: false
  private _maxTaskReschedule?: number; 
  public get maxTaskReschedule() {
    return this.getNumberAttribute('max_task_reschedule');
  }
  public set maxTaskReschedule(value: number) {
    this._maxTaskReschedule = value;
  }
  public resetMaxTaskReschedule() {
    this._maxTaskReschedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTaskRescheduleInput() {
    return this._maxTaskReschedule;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputOffice365MsgTraceMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputOffice365MsgTraceMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // plan_type - computed: true, optional: true, required: false
  private _planType?: string; 
  public get planType() {
    return this.getStringAttribute('plan_type');
  }
  public set planType(value: string) {
    this._planType = value;
  }
  public resetPlanType() {
    this._planType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get planTypeInput() {
    return this._planType;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputOffice365MsgTracePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputOffice365MsgTracePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reschedule_dropped_tasks - computed: true, optional: true, required: false
  private _rescheduleDroppedTasks?: boolean | cdktf.IResolvable; 
  public get rescheduleDroppedTasks() {
    return this.getBooleanAttribute('reschedule_dropped_tasks');
  }
  public set rescheduleDroppedTasks(value: boolean | cdktf.IResolvable) {
    this._rescheduleDroppedTasks = value;
  }
  public resetRescheduleDroppedTasks() {
    this._rescheduleDroppedTasks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rescheduleDroppedTasksInput() {
    return this._rescheduleDroppedTasks;
  }

  // resource - computed: true, optional: true, required: false
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  public resetResource() {
    this._resource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new SourceInputOffice365MsgTraceRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: SourceInputOffice365MsgTraceRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // start_date - computed: false, optional: true, required: false
  private _startDate?: string; 
  public get startDate() {
    return this.getStringAttribute('start_date');
  }
  public set startDate(value: string) {
    this._startDate = value;
  }
  public resetStartDate() {
    this._startDate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startDateInput() {
    return this._startDate;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout - computed: true, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface SourceInputOffice365ServiceConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputOffice365ServiceConnectionsToTerraform(struct?: SourceInputOffice365ServiceConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputOffice365ServiceConnectionsToHclTerraform(struct?: SourceInputOffice365ServiceConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365ServiceConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOffice365ServiceConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365ServiceConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputOffice365ServiceConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputOffice365ServiceConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOffice365ServiceConnectionsOutputReference {
    return new SourceInputOffice365ServiceConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOffice365ServiceContentConfig {
  /**
  * Office 365 Services API Content Type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#content_type Source#content_type}
  */
  readonly contentType?: string;
  /**
  * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enabled Source#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Collector runtime Log Level. must be one of ["error", "warn", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#log_level Source#log_level}
  */
  readonly logLevel?: string;
}

export function sourceInputOffice365ServiceContentConfigToTerraform(struct?: SourceInputOffice365ServiceContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content_type: cdktf.stringToTerraform(struct!.contentType),
    description: cdktf.stringToTerraform(struct!.description),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    interval: cdktf.numberToTerraform(struct!.interval),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
  }
}


export function sourceInputOffice365ServiceContentConfigToHclTerraform(struct?: SourceInputOffice365ServiceContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365ServiceContentConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOffice365ServiceContentConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365ServiceContentConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contentType = undefined;
      this._description = undefined;
      this._enabled = undefined;
      this._interval = undefined;
      this._logLevel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contentType = value.contentType;
      this._description = value.description;
      this._enabled = value.enabled;
      this._interval = value.interval;
      this._logLevel = value.logLevel;
    }
  }

  // content_type - computed: false, optional: true, required: false
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // interval - computed: false, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }
}

export class SourceInputOffice365ServiceContentConfigList extends cdktf.ComplexList {
  public internalValue? : SourceInputOffice365ServiceContentConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOffice365ServiceContentConfigOutputReference {
    return new SourceInputOffice365ServiceContentConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOffice365ServiceMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputOffice365ServiceMetadataToTerraform(struct?: SourceInputOffice365ServiceMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputOffice365ServiceMetadataToHclTerraform(struct?: SourceInputOffice365ServiceMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365ServiceMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOffice365ServiceMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365ServiceMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputOffice365ServiceMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputOffice365ServiceMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOffice365ServiceMetadataOutputReference {
    return new SourceInputOffice365ServiceMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOffice365ServicePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputOffice365ServicePqToTerraform(struct?: SourceInputOffice365ServicePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputOffice365ServicePqToHclTerraform(struct?: SourceInputOffice365ServicePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365ServicePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365ServicePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365ServicePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputOffice365ServiceRetryRules {
  /**
  * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503. Default: [429,500,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#codes Source#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_header Source#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#limit Source#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#multiplier Source#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_reset Source#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_timeout Source#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputOffice365ServiceRetryRulesToTerraform(struct?: SourceInputOffice365ServiceRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputOffice365ServiceRetryRulesToHclTerraform(struct?: SourceInputOffice365ServiceRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365ServiceRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365ServiceRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365ServiceRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputOffice365Service {
  /**
  * Office 365 Azure Application ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#app_id Source#app_id}
  */
  readonly appId: string;
  /**
  * Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Office 365 Azure client secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#client_secret Source#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputOffice365ServiceConnections[] | cdktf.IResolvable;
  /**
  * Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#content_config Source#content_config}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly contentConfig?: SourceInputOffice365ServiceContentConfig[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ignore_group_jobs_limit Source#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#job_timeout Source#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_time Source#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_missed_keep_alives Source#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputOffice365ServiceMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Office 365 subscription plan for your organization, typically Office 365 Enterprise. Default: "enterprise_gcc"; must be one of ["enterprise_gcc", "gcc", "gcc_high", "dod"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#plan_type Source#plan_type}
  */
  readonly planType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputOffice365ServicePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_rules Source#retry_rules}
  */
  readonly retryRules?: SourceInputOffice365ServiceRetryRules;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Office 365 Azure Tenant ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tenant_id Source#tenant_id}
  */
  readonly tenantId: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * HTTP request inactivity timeout, use 0 to disable. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#timeout Source#timeout}
  */
  readonly timeout?: number;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ttl Source#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "office365_service"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputOffice365ServiceToTerraform(struct?: SourceInputOffice365Service | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_id: cdktf.stringToTerraform(struct!.appId),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    connections: cdktf.listMapper(sourceInputOffice365ServiceConnectionsToTerraform, false)(struct!.connections),
    content_config: cdktf.listMapper(sourceInputOffice365ServiceContentConfigToTerraform, false)(struct!.contentConfig),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(sourceInputOffice365ServiceMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    plan_type: cdktf.stringToTerraform(struct!.planType),
    pq: sourceInputOffice365ServicePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    retry_rules: sourceInputOffice365ServiceRetryRulesToTerraform(struct!.retryRules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout: cdktf.numberToTerraform(struct!.timeout),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputOffice365ServiceToHclTerraform(struct?: SourceInputOffice365Service | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_id: {
      value: cdktf.stringToHclTerraform(struct!.appId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputOffice365ServiceConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOffice365ServiceConnectionsList",
    },
    content_config: {
      value: cdktf.listMapperHcl(sourceInputOffice365ServiceContentConfigToHclTerraform, false)(struct!.contentConfig),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOffice365ServiceContentConfigList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputOffice365ServiceMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOffice365ServiceMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plan_type: {
      value: cdktf.stringToHclTerraform(struct!.planType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputOffice365ServicePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOffice365ServicePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_rules: {
      value: sourceInputOffice365ServiceRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOffice365ServiceRetryRules",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOffice365ServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOffice365Service | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appId !== undefined) {
      hasAnyValues = true;
      internalValueResult.appId = this._appId;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._contentConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentConfig = this._contentConfig?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._planType !== undefined) {
      hasAnyValues = true;
      internalValueResult.planType = this._planType;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOffice365Service | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appId = undefined;
      this._authType = undefined;
      this._clientSecret = undefined;
      this._connections.internalValue = undefined;
      this._contentConfig.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._planType = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._retryRules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._timeout = undefined;
      this._ttl = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appId = value.appId;
      this._authType = value.authType;
      this._clientSecret = value.clientSecret;
      this._connections.internalValue = value.connections;
      this._contentConfig.internalValue = value.contentConfig;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._planType = value.planType;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._retryRules.internalValue = value.retryRules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._timeout = value.timeout;
      this._ttl = value.ttl;
      this._type = value.type;
    }
  }

  // app_id - computed: false, optional: false, required: true
  private _appId?: string; 
  public get appId() {
    return this.getStringAttribute('app_id');
  }
  public set appId(value: string) {
    this._appId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get appIdInput() {
    return this._appId;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputOffice365ServiceConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputOffice365ServiceConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // content_config - computed: false, optional: true, required: false
  private _contentConfig = new SourceInputOffice365ServiceContentConfigList(this, "content_config", false);
  public get contentConfig() {
    return this._contentConfig;
  }
  public putContentConfig(value: SourceInputOffice365ServiceContentConfig[] | cdktf.IResolvable) {
    this._contentConfig.internalValue = value;
  }
  public resetContentConfig() {
    this._contentConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentConfigInput() {
    return this._contentConfig.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputOffice365ServiceMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputOffice365ServiceMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // plan_type - computed: true, optional: true, required: false
  private _planType?: string; 
  public get planType() {
    return this.getStringAttribute('plan_type');
  }
  public set planType(value: string) {
    this._planType = value;
  }
  public resetPlanType() {
    this._planType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get planTypeInput() {
    return this._planType;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputOffice365ServicePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputOffice365ServicePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new SourceInputOffice365ServiceRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: SourceInputOffice365ServiceRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tenant_id - computed: false, optional: false, required: true
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout - computed: true, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputOpenTelemetryConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputOpenTelemetryConnectionsToTerraform(struct?: SourceInputOpenTelemetryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputOpenTelemetryConnectionsToHclTerraform(struct?: SourceInputOpenTelemetryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOpenTelemetryConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOpenTelemetryConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOpenTelemetryConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputOpenTelemetryConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputOpenTelemetryConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOpenTelemetryConnectionsOutputReference {
    return new SourceInputOpenTelemetryConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOpenTelemetryMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputOpenTelemetryMetadataToTerraform(struct?: SourceInputOpenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputOpenTelemetryMetadataToHclTerraform(struct?: SourceInputOpenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOpenTelemetryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOpenTelemetryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOpenTelemetryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputOpenTelemetryMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputOpenTelemetryMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOpenTelemetryMetadataOutputReference {
    return new SourceInputOpenTelemetryMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOpenTelemetryOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputOpenTelemetryOauthHeadersToTerraform(struct?: SourceInputOpenTelemetryOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputOpenTelemetryOauthHeadersToHclTerraform(struct?: SourceInputOpenTelemetryOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOpenTelemetryOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOpenTelemetryOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOpenTelemetryOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputOpenTelemetryOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : SourceInputOpenTelemetryOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOpenTelemetryOauthHeadersOutputReference {
    return new SourceInputOpenTelemetryOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOpenTelemetryOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputOpenTelemetryOauthParamsToTerraform(struct?: SourceInputOpenTelemetryOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputOpenTelemetryOauthParamsToHclTerraform(struct?: SourceInputOpenTelemetryOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOpenTelemetryOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputOpenTelemetryOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOpenTelemetryOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputOpenTelemetryOauthParamsList extends cdktf.ComplexList {
  public internalValue? : SourceInputOpenTelemetryOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputOpenTelemetryOauthParamsOutputReference {
    return new SourceInputOpenTelemetryOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputOpenTelemetryPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputOpenTelemetryPqToTerraform(struct?: SourceInputOpenTelemetryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputOpenTelemetryPqToHclTerraform(struct?: SourceInputOpenTelemetryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOpenTelemetryPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOpenTelemetryPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOpenTelemetryPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputOpenTelemetryTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputOpenTelemetryTlsToTerraform(struct?: SourceInputOpenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputOpenTelemetryTlsToHclTerraform(struct?: SourceInputOpenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOpenTelemetryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOpenTelemetryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOpenTelemetryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputOpenTelemetry {
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#activity_log_sample_rate Source#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: string;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_header_expr Source#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * OpenTelemetry authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#capture_headers Source#capture_headers}
  */
  readonly captureHeaders?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputOpenTelemetryConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#credentials_secret Source#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_health_check Source#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Enable to extract each incoming log record to a separate event. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#extract_logs Source#extract_logs}
  */
  readonly extractLogs?: boolean | cdktf.IResolvable;
  /**
  * Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#extract_metrics Source#extract_metrics}
  */
  readonly extractMetrics?: boolean | cdktf.IResolvable;
  /**
  * Enable to extract each incoming span to a separate event. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#extract_spans Source#extract_spans}
  */
  readonly extractSpans?: boolean | cdktf.IResolvable;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_allowlist_regex Source#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_denylist_regex Source#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.). Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_timeout Source#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#login_url Source#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_cxn Source#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_req Source#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_requests_per_socket Source#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputOpenTelemetryMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#oauth_headers Source#oauth_headers}
  */
  readonly oauthHeaders?: SourceInputOpenTelemetryOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#oauth_params Source#oauth_params}
  */
  readonly oauthParams?: SourceInputOpenTelemetryOauthParams[] | cdktf.IResolvable;
  /**
  * The version of OTLP Protobuf definitions to use when interpreting received data. Default: "0.10.0"; must be one of ["0.10.0", "1.3.1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#otlp_version Source#otlp_version}
  */
  readonly otlpVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#password Source#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on. Default: 4317
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputOpenTelemetryPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to leverage gRPC or HTTP for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#protocol Source#protocol}
  */
  readonly protocol?: string;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#secret Source#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#secret_param_name Source#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputOpenTelemetryTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token Source#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_attribute_name Source#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_timeout_secs Source#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "open_telemetry"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#username Source#username}
  */
  readonly username?: string;
}

export function sourceInputOpenTelemetryToTerraform(struct?: SourceInputOpenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.stringToTerraform(struct!.activityLogSampleRate),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    capture_headers: cdktf.stringToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(sourceInputOpenTelemetryConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.stringToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    extract_logs: cdktf.booleanToTerraform(struct!.extractLogs),
    extract_metrics: cdktf.booleanToTerraform(struct!.extractMetrics),
    extract_spans: cdktf.booleanToTerraform(struct!.extractSpans),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(sourceInputOpenTelemetryMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(sourceInputOpenTelemetryOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(sourceInputOpenTelemetryOauthParamsToTerraform, false)(struct!.oauthParams),
    otlp_version: cdktf.stringToTerraform(struct!.otlpVersion),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputOpenTelemetryPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: sourceInputOpenTelemetryTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function sourceInputOpenTelemetryToHclTerraform(struct?: SourceInputOpenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.stringToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.stringToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputOpenTelemetryConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOpenTelemetryConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.stringToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extract_logs: {
      value: cdktf.booleanToHclTerraform(struct!.extractLogs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extract_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.extractMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extract_spans: {
      value: cdktf.booleanToHclTerraform(struct!.extractSpans),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputOpenTelemetryMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOpenTelemetryMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(sourceInputOpenTelemetryOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOpenTelemetryOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(sourceInputOpenTelemetryOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputOpenTelemetryOauthParamsList",
    },
    otlp_version: {
      value: cdktf.stringToHclTerraform(struct!.otlpVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputOpenTelemetryPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOpenTelemetryPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: sourceInputOpenTelemetryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputOpenTelemetryTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputOpenTelemetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputOpenTelemetry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extractLogs !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractLogs = this._extractLogs;
    }
    if (this._extractMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractMetrics = this._extractMetrics;
    }
    if (this._extractSpans !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractSpans = this._extractSpans;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._otlpVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.otlpVersion = this._otlpVersion;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputOpenTelemetry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._extractLogs = undefined;
      this._extractMetrics = undefined;
      this._extractSpans = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._loginUrl = undefined;
      this._maxActiveCxn = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._otlpVersion = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._protocol = undefined;
      this._requestTimeout = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._extractLogs = value.extractLogs;
      this._extractMetrics = value.extractMetrics;
      this._extractSpans = value.extractSpans;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._loginUrl = value.loginUrl;
      this._maxActiveCxn = value.maxActiveCxn;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._otlpVersion = value.otlpVersion;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._protocol = value.protocol;
      this._requestTimeout = value.requestTimeout;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._username = value.username;
    }
  }

  // activity_log_sample_rate - computed: false, optional: true, required: false
  private _activityLogSampleRate?: string; 
  public get activityLogSampleRate() {
    return this.getStringAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: string) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // capture_headers - computed: false, optional: true, required: false
  private _captureHeaders?: string; 
  public get captureHeaders() {
    return this.getStringAttribute('capture_headers');
  }
  public set captureHeaders(value: string) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputOpenTelemetryConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputOpenTelemetryConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: false, optional: true, required: false
  private _enableProxyHeader?: string; 
  public get enableProxyHeader() {
    return this.getStringAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: string) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extract_logs - computed: true, optional: true, required: false
  private _extractLogs?: boolean | cdktf.IResolvable; 
  public get extractLogs() {
    return this.getBooleanAttribute('extract_logs');
  }
  public set extractLogs(value: boolean | cdktf.IResolvable) {
    this._extractLogs = value;
  }
  public resetExtractLogs() {
    this._extractLogs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractLogsInput() {
    return this._extractLogs;
  }

  // extract_metrics - computed: true, optional: true, required: false
  private _extractMetrics?: boolean | cdktf.IResolvable; 
  public get extractMetrics() {
    return this.getBooleanAttribute('extract_metrics');
  }
  public set extractMetrics(value: boolean | cdktf.IResolvable) {
    this._extractMetrics = value;
  }
  public resetExtractMetrics() {
    this._extractMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractMetricsInput() {
    return this._extractMetrics;
  }

  // extract_spans - computed: true, optional: true, required: false
  private _extractSpans?: boolean | cdktf.IResolvable; 
  public get extractSpans() {
    return this.getBooleanAttribute('extract_spans');
  }
  public set extractSpans(value: boolean | cdktf.IResolvable) {
    this._extractSpans = value;
  }
  public resetExtractSpans() {
    this._extractSpans = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractSpansInput() {
    return this._extractSpans;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputOpenTelemetryMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputOpenTelemetryMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new SourceInputOpenTelemetryOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: SourceInputOpenTelemetryOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new SourceInputOpenTelemetryOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: SourceInputOpenTelemetryOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // otlp_version - computed: true, optional: true, required: false
  private _otlpVersion?: string; 
  public get otlpVersion() {
    return this.getStringAttribute('otlp_version');
  }
  public set otlpVersion(value: string) {
    this._otlpVersion = value;
  }
  public resetOtlpVersion() {
    this._otlpVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get otlpVersionInput() {
    return this._otlpVersion;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputOpenTelemetryPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputOpenTelemetryPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputOpenTelemetryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputOpenTelemetryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface SourceInputPrometheusConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputPrometheusConnectionsToTerraform(struct?: SourceInputPrometheusConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputPrometheusConnectionsToHclTerraform(struct?: SourceInputPrometheusConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputPrometheusConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputPrometheusConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputPrometheusConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputPrometheusConnectionsOutputReference {
    return new SourceInputPrometheusConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputPrometheusMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputPrometheusMetadataToTerraform(struct?: SourceInputPrometheusMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputPrometheusMetadataToHclTerraform(struct?: SourceInputPrometheusMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputPrometheusMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputPrometheusMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputPrometheusMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputPrometheusMetadataOutputReference {
    return new SourceInputPrometheusMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputPrometheusPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputPrometheusPqToTerraform(struct?: SourceInputPrometheusPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputPrometheusPqToHclTerraform(struct?: SourceInputPrometheusPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputPrometheusPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputPrometheusSearchFilter {
  /**
  * Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * Search Filter Values, if empty only "running" EC2 instances will be returned. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#values Source#values}
  */
  readonly values?: string[];
}

export function sourceInputPrometheusSearchFilterToTerraform(struct?: SourceInputPrometheusSearchFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function sourceInputPrometheusSearchFilterToHclTerraform(struct?: SourceInputPrometheusSearchFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusSearchFilterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputPrometheusSearchFilter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusSearchFilter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._values = value.values;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // values - computed: true, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class SourceInputPrometheusSearchFilterList extends cdktf.ComplexList {
  public internalValue? : SourceInputPrometheusSearchFilter[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputPrometheusSearchFilterOutputReference {
    return new SourceInputPrometheusSearchFilterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputPrometheus {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_arn Source#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_external_id Source#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_authentication_method Source#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret_key Source#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputPrometheusConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#credentials_secret Source#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Other dimensions to include in events. Default: ["host","source"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#dimension_list Source#dimension_list}
  */
  readonly dimensionList?: string[];
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Target discovery mechanism. Use static to manually enter a list of targets. Default: "static"; must be one of ["static", "dns", "ec2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#discovery_type Source#discovery_type}
  */
  readonly discoveryType?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#duration_seconds Source#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access EC2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_assume_role Source#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ignore_group_jobs_limit Source#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#job_timeout Source#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_time Source#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * Collector runtime Log Level. Default: "info"; must be one of ["error", "warn", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#log_level Source#log_level}
  */
  readonly logLevel?: string;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_missed_keep_alives Source#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputPrometheusMetadata[] | cdktf.IResolvable;
  /**
  * List of DNS names to resolve. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name_list Source#name_list}
  */
  readonly nameList?: string[];
  /**
  * Password for Prometheus Basic authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#password Source#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputPrometheusPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * DNS Record type to resolve. Default: "SRV"; must be one of ["SRV", "A", "AAAA"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#record_type Source#record_type}
  */
  readonly recordType?: string;
  /**
  * Region where the EC2 is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#region Source#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reuse_connections Source#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Path to use when collecting metrics from discovered targets. Default: "/metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#scrape_path Source#scrape_path}
  */
  readonly scrapePath?: string;
  /**
  * The port number in the metrics URL for discovered targets. Default: 9090
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#scrape_port Source#scrape_port}
  */
  readonly scrapePort?: number;
  /**
  * Protocol to use when collecting metrics. Default: "http"; must be one of ["http", "https"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#scrape_protocol Source#scrape_protocol}
  */
  readonly scrapeProtocol?: string;
  /**
  * EC2 Instance Search Filter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#search_filter Source#search_filter}
  */
  readonly searchFilter?: SourceInputPrometheusSearchFilter[] | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing EC2 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#signature_version Source#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#target_list Source#target_list}
  */
  readonly targetList?: string[];
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ttl Source#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "prometheus"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Use public IP address for discovered targets. Set to false if the private IP address should be used. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#use_public_ip Source#use_public_ip}
  */
  readonly usePublicIp?: boolean | cdktf.IResolvable;
  /**
  * Username for Prometheus Basic authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#username Source#username}
  */
  readonly username?: string;
}

export function sourceInputPrometheusToTerraform(struct?: SourceInputPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    connections: cdktf.listMapper(sourceInputPrometheusConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    dimension_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dimensionList),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    discovery_type: cdktf.stringToTerraform(struct!.discoveryType),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    interval: cdktf.numberToTerraform(struct!.interval),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(sourceInputPrometheusMetadataToTerraform, false)(struct!.metadata),
    name_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.nameList),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputPrometheusPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    record_type: cdktf.stringToTerraform(struct!.recordType),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    scrape_path: cdktf.stringToTerraform(struct!.scrapePath),
    scrape_port: cdktf.numberToTerraform(struct!.scrapePort),
    scrape_protocol: cdktf.stringToTerraform(struct!.scrapeProtocol),
    search_filter: cdktf.listMapper(sourceInputPrometheusSearchFilterToTerraform, false)(struct!.searchFilter),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    target_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.targetList),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
    use_public_ip: cdktf.booleanToTerraform(struct!.usePublicIp),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function sourceInputPrometheusToHclTerraform(struct?: SourceInputPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputPrometheusConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputPrometheusConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dimension_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dimensionList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_type: {
      value: cdktf.stringToHclTerraform(struct!.discoveryType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputPrometheusMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputPrometheusMetadataList",
    },
    name_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.nameList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputPrometheusPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputPrometheusPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    record_type: {
      value: cdktf.stringToHclTerraform(struct!.recordType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    scrape_path: {
      value: cdktf.stringToHclTerraform(struct!.scrapePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scrape_port: {
      value: cdktf.numberToHclTerraform(struct!.scrapePort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    scrape_protocol: {
      value: cdktf.stringToHclTerraform(struct!.scrapeProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_filter: {
      value: cdktf.listMapperHcl(sourceInputPrometheusSearchFilterToHclTerraform, false)(struct!.searchFilter),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputPrometheusSearchFilterList",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    target_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.targetList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_public_ip: {
      value: cdktf.booleanToHclTerraform(struct!.usePublicIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputPrometheus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dimensionList !== undefined) {
      hasAnyValues = true;
      internalValueResult.dimensionList = this._dimensionList;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._discoveryType !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryType = this._discoveryType;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._nameList !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameList = this._nameList;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._recordType !== undefined) {
      hasAnyValues = true;
      internalValueResult.recordType = this._recordType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._scrapePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapePath = this._scrapePath;
    }
    if (this._scrapePort !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapePort = this._scrapePort;
    }
    if (this._scrapeProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.scrapeProtocol = this._scrapeProtocol;
    }
    if (this._searchFilter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchFilter = this._searchFilter?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._targetList !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetList = this._targetList;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usePublicIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.usePublicIp = this._usePublicIp;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._authType = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecretKey = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._dimensionList = undefined;
      this._disabled = undefined;
      this._discoveryType = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._interval = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._logLevel = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._nameList = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._recordType = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._scrapePath = undefined;
      this._scrapePort = undefined;
      this._scrapeProtocol = undefined;
      this._searchFilter.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._targetList = undefined;
      this._ttl = undefined;
      this._type = undefined;
      this._usePublicIp = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._authType = value.authType;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecretKey = value.awsSecretKey;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._dimensionList = value.dimensionList;
      this._disabled = value.disabled;
      this._discoveryType = value.discoveryType;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._interval = value.interval;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._logLevel = value.logLevel;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._nameList = value.nameList;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._recordType = value.recordType;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._scrapePath = value.scrapePath;
      this._scrapePort = value.scrapePort;
      this._scrapeProtocol = value.scrapeProtocol;
      this._searchFilter.internalValue = value.searchFilter;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._targetList = value.targetList;
      this._ttl = value.ttl;
      this._type = value.type;
      this._usePublicIp = value.usePublicIp;
      this._username = value.username;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputPrometheusConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputPrometheusConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dimension_list - computed: true, optional: true, required: false
  private _dimensionList?: string[]; 
  public get dimensionList() {
    return this.getListAttribute('dimension_list');
  }
  public set dimensionList(value: string[]) {
    this._dimensionList = value;
  }
  public resetDimensionList() {
    this._dimensionList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dimensionListInput() {
    return this._dimensionList;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // discovery_type - computed: true, optional: true, required: false
  private _discoveryType?: string; 
  public get discoveryType() {
    return this.getStringAttribute('discovery_type');
  }
  public set discoveryType(value: string) {
    this._discoveryType = value;
  }
  public resetDiscoveryType() {
    this._discoveryType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryTypeInput() {
    return this._discoveryType;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // log_level - computed: true, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputPrometheusMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputPrometheusMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // name_list - computed: true, optional: true, required: false
  private _nameList?: string[]; 
  public get nameList() {
    return this.getListAttribute('name_list');
  }
  public set nameList(value: string[]) {
    this._nameList = value;
  }
  public resetNameList() {
    this._nameList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameListInput() {
    return this._nameList;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputPrometheusPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputPrometheusPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // record_type - computed: true, optional: true, required: false
  private _recordType?: string; 
  public get recordType() {
    return this.getStringAttribute('record_type');
  }
  public set recordType(value: string) {
    this._recordType = value;
  }
  public resetRecordType() {
    this._recordType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recordTypeInput() {
    return this._recordType;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // scrape_path - computed: true, optional: true, required: false
  private _scrapePath?: string; 
  public get scrapePath() {
    return this.getStringAttribute('scrape_path');
  }
  public set scrapePath(value: string) {
    this._scrapePath = value;
  }
  public resetScrapePath() {
    this._scrapePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapePathInput() {
    return this._scrapePath;
  }

  // scrape_port - computed: true, optional: true, required: false
  private _scrapePort?: number; 
  public get scrapePort() {
    return this.getNumberAttribute('scrape_port');
  }
  public set scrapePort(value: number) {
    this._scrapePort = value;
  }
  public resetScrapePort() {
    this._scrapePort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapePortInput() {
    return this._scrapePort;
  }

  // scrape_protocol - computed: true, optional: true, required: false
  private _scrapeProtocol?: string; 
  public get scrapeProtocol() {
    return this.getStringAttribute('scrape_protocol');
  }
  public set scrapeProtocol(value: string) {
    this._scrapeProtocol = value;
  }
  public resetScrapeProtocol() {
    this._scrapeProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scrapeProtocolInput() {
    return this._scrapeProtocol;
  }

  // search_filter - computed: false, optional: true, required: false
  private _searchFilter = new SourceInputPrometheusSearchFilterList(this, "search_filter", false);
  public get searchFilter() {
    return this._searchFilter;
  }
  public putSearchFilter(value: SourceInputPrometheusSearchFilter[] | cdktf.IResolvable) {
    this._searchFilter.internalValue = value;
  }
  public resetSearchFilter() {
    this._searchFilter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchFilterInput() {
    return this._searchFilter.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // target_list - computed: true, optional: true, required: false
  private _targetList?: string[]; 
  public get targetList() {
    return this.getListAttribute('target_list');
  }
  public set targetList(value: string[]) {
    this._targetList = value;
  }
  public resetTargetList() {
    this._targetList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetListInput() {
    return this._targetList;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_public_ip - computed: true, optional: true, required: false
  private _usePublicIp?: boolean | cdktf.IResolvable; 
  public get usePublicIp() {
    return this.getBooleanAttribute('use_public_ip');
  }
  public set usePublicIp(value: boolean | cdktf.IResolvable) {
    this._usePublicIp = value;
  }
  public resetUsePublicIp() {
    this._usePublicIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usePublicIpInput() {
    return this._usePublicIp;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface SourceInputPrometheusRwConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputPrometheusRwConnectionsToTerraform(struct?: SourceInputPrometheusRwConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputPrometheusRwConnectionsToHclTerraform(struct?: SourceInputPrometheusRwConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusRwConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputPrometheusRwConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusRwConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputPrometheusRwConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputPrometheusRwConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputPrometheusRwConnectionsOutputReference {
    return new SourceInputPrometheusRwConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputPrometheusRwMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputPrometheusRwMetadataToTerraform(struct?: SourceInputPrometheusRwMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputPrometheusRwMetadataToHclTerraform(struct?: SourceInputPrometheusRwMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusRwMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputPrometheusRwMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusRwMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputPrometheusRwMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputPrometheusRwMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputPrometheusRwMetadataOutputReference {
    return new SourceInputPrometheusRwMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputPrometheusRwOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputPrometheusRwOauthHeadersToTerraform(struct?: SourceInputPrometheusRwOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputPrometheusRwOauthHeadersToHclTerraform(struct?: SourceInputPrometheusRwOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusRwOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputPrometheusRwOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusRwOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputPrometheusRwOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : SourceInputPrometheusRwOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputPrometheusRwOauthHeadersOutputReference {
    return new SourceInputPrometheusRwOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputPrometheusRwOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputPrometheusRwOauthParamsToTerraform(struct?: SourceInputPrometheusRwOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputPrometheusRwOauthParamsToHclTerraform(struct?: SourceInputPrometheusRwOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusRwOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputPrometheusRwOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusRwOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputPrometheusRwOauthParamsList extends cdktf.ComplexList {
  public internalValue? : SourceInputPrometheusRwOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputPrometheusRwOauthParamsOutputReference {
    return new SourceInputPrometheusRwOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputPrometheusRwPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputPrometheusRwPqToTerraform(struct?: SourceInputPrometheusRwPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputPrometheusRwPqToHclTerraform(struct?: SourceInputPrometheusRwPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusRwPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputPrometheusRwPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusRwPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputPrometheusRwTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputPrometheusRwTlsToTerraform(struct?: SourceInputPrometheusRwTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputPrometheusRwTlsToHclTerraform(struct?: SourceInputPrometheusRwTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusRwTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputPrometheusRwTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusRwTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputPrometheusRw {
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#activity_log_sample_rate Source#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_header_expr Source#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#capture_headers Source#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputPrometheusRwConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#credentials_secret Source#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_health_check Source#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_allowlist_regex Source#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_denylist_regex Source#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_timeout Source#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#login_url Source#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_req Source#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_requests_per_socket Source#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputPrometheusRwMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#oauth_headers Source#oauth_headers}
  */
  readonly oauthHeaders?: SourceInputPrometheusRwOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#oauth_params Source#oauth_params}
  */
  readonly oauthParams?: SourceInputPrometheusRwOauthParams[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#password Source#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputPrometheusRwPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<your‑upstream‑URL>:<your‑port>/write. Default: "/write"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#prometheus_api Source#prometheus_api}
  */
  readonly prometheusApi?: string;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#secret Source#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#secret_param_name Source#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputPrometheusRwTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token Source#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_attribute_name Source#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_timeout_secs Source#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "prometheus_rw"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#username Source#username}
  */
  readonly username?: string;
}

export function sourceInputPrometheusRwToTerraform(struct?: SourceInputPrometheusRw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(sourceInputPrometheusRwConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(sourceInputPrometheusRwMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(sourceInputPrometheusRwOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(sourceInputPrometheusRwOauthParamsToTerraform, false)(struct!.oauthParams),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputPrometheusRwPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    prometheus_api: cdktf.stringToTerraform(struct!.prometheusApi),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: sourceInputPrometheusRwTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function sourceInputPrometheusRwToHclTerraform(struct?: SourceInputPrometheusRw | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputPrometheusRwConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputPrometheusRwConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputPrometheusRwMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputPrometheusRwMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(sourceInputPrometheusRwOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputPrometheusRwOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(sourceInputPrometheusRwOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputPrometheusRwOauthParamsList",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputPrometheusRwPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputPrometheusRwPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prometheus_api: {
      value: cdktf.stringToHclTerraform(struct!.prometheusApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: sourceInputPrometheusRwTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputPrometheusRwTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputPrometheusRwOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputPrometheusRw | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._prometheusApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusApi = this._prometheusApi;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputPrometheusRw | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._loginUrl = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._prometheusApi = undefined;
      this._requestTimeout = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._loginUrl = value.loginUrl;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._prometheusApi = value.prometheusApi;
      this._requestTimeout = value.requestTimeout;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._username = value.username;
    }
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputPrometheusRwConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputPrometheusRwConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputPrometheusRwMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputPrometheusRwMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new SourceInputPrometheusRwOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: SourceInputPrometheusRwOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new SourceInputPrometheusRwOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: SourceInputPrometheusRwOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputPrometheusRwPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputPrometheusRwPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // prometheus_api - computed: true, optional: true, required: false
  private _prometheusApi?: string; 
  public get prometheusApi() {
    return this.getStringAttribute('prometheus_api');
  }
  public set prometheusApi(value: string) {
    this._prometheusApi = value;
  }
  public resetPrometheusApi() {
    this._prometheusApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusApiInput() {
    return this._prometheusApi;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputPrometheusRwTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputPrometheusRwTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface SourceInputRawUdpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputRawUdpConnectionsToTerraform(struct?: SourceInputRawUdpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputRawUdpConnectionsToHclTerraform(struct?: SourceInputRawUdpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputRawUdpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputRawUdpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputRawUdpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputRawUdpConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputRawUdpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputRawUdpConnectionsOutputReference {
    return new SourceInputRawUdpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputRawUdpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputRawUdpMetadataToTerraform(struct?: SourceInputRawUdpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputRawUdpMetadataToHclTerraform(struct?: SourceInputRawUdpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputRawUdpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputRawUdpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputRawUdpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputRawUdpMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputRawUdpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputRawUdpMetadataOutputReference {
    return new SourceInputRawUdpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputRawUdpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputRawUdpPqToTerraform(struct?: SourceInputRawUdpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputRawUdpPqToHclTerraform(struct?: SourceInputRawUdpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputRawUdpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputRawUdpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputRawUdpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputRawUdp {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputRawUdpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ingest_raw_bytes Source#ingest_raw_bytes}
  */
  readonly ingestRawBytes?: boolean | cdktf.IResolvable;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_whitelist_regex Source#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputRawUdpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputRawUdpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#single_msg_udp_packets Source#single_msg_udp_packets}
  */
  readonly singleMsgUdpPackets?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "raw_udp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_socket_rx_buf_size Source#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
}

export function sourceInputRawUdpToTerraform(struct?: SourceInputRawUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputRawUdpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ingest_raw_bytes: cdktf.booleanToTerraform(struct!.ingestRawBytes),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(sourceInputRawUdpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputRawUdpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    single_msg_udp_packets: cdktf.booleanToTerraform(struct!.singleMsgUdpPackets),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
  }
}


export function sourceInputRawUdpToHclTerraform(struct?: SourceInputRawUdp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputRawUdpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputRawUdpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingest_raw_bytes: {
      value: cdktf.booleanToHclTerraform(struct!.ingestRawBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputRawUdpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputRawUdpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputRawUdpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputRawUdpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    single_msg_udp_packets: {
      value: cdktf.booleanToHclTerraform(struct!.singleMsgUdpPackets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputRawUdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputRawUdp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ingestRawBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestRawBytes = this._ingestRawBytes;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._singleMsgUdpPackets !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleMsgUdpPackets = this._singleMsgUdpPackets;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputRawUdp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ingestRawBytes = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._singleMsgUdpPackets = undefined;
      this._streamtags = undefined;
      this._type = undefined;
      this._udpSocketRxBufSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ingestRawBytes = value.ingestRawBytes;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._singleMsgUdpPackets = value.singleMsgUdpPackets;
      this._streamtags = value.streamtags;
      this._type = value.type;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputRawUdpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputRawUdpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ingest_raw_bytes - computed: true, optional: true, required: false
  private _ingestRawBytes?: boolean | cdktf.IResolvable; 
  public get ingestRawBytes() {
    return this.getBooleanAttribute('ingest_raw_bytes');
  }
  public set ingestRawBytes(value: boolean | cdktf.IResolvable) {
    this._ingestRawBytes = value;
  }
  public resetIngestRawBytes() {
    this._ingestRawBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestRawBytesInput() {
    return this._ingestRawBytes;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputRawUdpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputRawUdpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputRawUdpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputRawUdpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // single_msg_udp_packets - computed: true, optional: true, required: false
  private _singleMsgUdpPackets?: boolean | cdktf.IResolvable; 
  public get singleMsgUdpPackets() {
    return this.getBooleanAttribute('single_msg_udp_packets');
  }
  public set singleMsgUdpPackets(value: boolean | cdktf.IResolvable) {
    this._singleMsgUdpPackets = value;
  }
  public resetSingleMsgUdpPackets() {
    this._singleMsgUdpPackets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleMsgUdpPacketsInput() {
    return this._singleMsgUdpPackets;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }
}
export interface SourceInputS3Checkpointing {
  /**
  * Resume processing files after an interruption. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enabled Source#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retries Source#retries}
  */
  readonly retries?: number;
}

export function sourceInputS3CheckpointingToTerraform(struct?: SourceInputS3Checkpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    retries: cdktf.numberToTerraform(struct!.retries),
  }
}


export function sourceInputS3CheckpointingToHclTerraform(struct?: SourceInputS3Checkpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3CheckpointingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputS3Checkpointing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3Checkpointing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._retries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._retries = value.retries;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // retries - computed: true, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }
}
export interface SourceInputS3Connections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputS3ConnectionsToTerraform(struct?: SourceInputS3Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputS3ConnectionsToHclTerraform(struct?: SourceInputS3Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3ConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputS3Connections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3Connections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputS3ConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputS3Connections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputS3ConnectionsOutputReference {
    return new SourceInputS3ConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputS3Metadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputS3MetadataToTerraform(struct?: SourceInputS3Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputS3MetadataToHclTerraform(struct?: SourceInputS3Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3MetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputS3Metadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3Metadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputS3MetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputS3Metadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputS3MetadataOutputReference {
    return new SourceInputS3MetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputS3Pq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputS3PqToTerraform(struct?: SourceInputS3Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputS3PqToHclTerraform(struct?: SourceInputS3Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3PqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputS3Pq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3Pq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputS3Preprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#args Source#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#command Source#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function sourceInputS3PreprocessToTerraform(struct?: SourceInputS3Preprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function sourceInputS3PreprocessToHclTerraform(struct?: SourceInputS3Preprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3PreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputS3Preprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3Preprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface SourceInputS3 {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_arn Source#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_external_id Source#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_account_id Source#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_api_key Source#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_authentication_method Source#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret Source#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret_key Source#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#checkpointing Source#checkpointing}
  */
  readonly checkpointing?: SourceInputS3Checkpointing;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputS3Connections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#duration_seconds Source#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Amazon S3. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_assume_role Source#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Use Assume Role credentials when accessing Amazon SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_sqs_assume_role Source#enable_sqs_assume_role}
  */
  readonly enableSqsAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#encoding Source#encoding}
  */
  readonly encoding?: string;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Regex matching file names to download and process. Defaults to: .*. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#file_filter Source#file_filter}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly fileFilter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_messages Source#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputS3Metadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#num_receivers Source#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#parquet_chunk_download_timeout Source#parquet_chunk_download_timeout}
  */
  readonly parquetChunkDownloadTimeout?: number;
  /**
  * Maximum file size for each Parquet chunk. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#parquet_chunk_size_mb Source#parquet_chunk_size_mb}
  */
  readonly parquetChunkSizeMb?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#poll_timeout Source#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputS3Pq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#preprocess Source#preprocess}
  */
  readonly preprocess?: SourceInputS3Preprocess;
  /**
  * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#processed_tag_key Source#processed_tag_key}
  */
  readonly processedTagKey?: string;
  /**
  * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#processed_tag_value Source#processed_tag_value}
  */
  readonly processedTagValue?: string;
  /**
  * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#queue_name Source#queue_name}
  */
  readonly queueName: string;
  /**
  * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#region Source#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reuse_connections Source#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#signature_version Source#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#skip_on_error Source#skip_on_error}
  */
  readonly skipOnError?: boolean | cdktf.IResolvable;
  /**
  * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tag_after_processing Source#tag_after_processing}
  */
  readonly tagAfterProcessing?: boolean | cdktf.IResolvable;
  /**
  * must be "s3"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#visibility_timeout Source#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function sourceInputS3ToTerraform(struct?: SourceInputS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    checkpointing: sourceInputS3CheckpointingToTerraform(struct!.checkpointing),
    connections: cdktf.listMapper(sourceInputS3ConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_sqs_assume_role: cdktf.booleanToTerraform(struct!.enableSqsAssumeRole),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_filter: cdktf.stringToTerraform(struct!.fileFilter),
    id: cdktf.stringToTerraform(struct!.id),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(sourceInputS3MetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    parquet_chunk_download_timeout: cdktf.numberToTerraform(struct!.parquetChunkDownloadTimeout),
    parquet_chunk_size_mb: cdktf.numberToTerraform(struct!.parquetChunkSizeMb),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: sourceInputS3PqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: sourceInputS3PreprocessToTerraform(struct!.preprocess),
    processed_tag_key: cdktf.stringToTerraform(struct!.processedTagKey),
    processed_tag_value: cdktf.stringToTerraform(struct!.processedTagValue),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    skip_on_error: cdktf.booleanToTerraform(struct!.skipOnError),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tag_after_processing: cdktf.booleanToTerraform(struct!.tagAfterProcessing),
    type: cdktf.stringToTerraform(struct!.type),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function sourceInputS3ToHclTerraform(struct?: SourceInputS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    checkpointing: {
      value: sourceInputS3CheckpointingToHclTerraform(struct!.checkpointing),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputS3Checkpointing",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputS3ConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputS3ConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sqs_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableSqsAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_filter: {
      value: cdktf.stringToHclTerraform(struct!.fileFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputS3MetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputS3MetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_download_timeout: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkDownloadTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputS3PqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputS3Pq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: sourceInputS3PreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputS3Preprocess",
    },
    processed_tag_key: {
      value: cdktf.stringToHclTerraform(struct!.processedTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processed_tag_value: {
      value: cdktf.stringToHclTerraform(struct!.processedTagValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_on_error: {
      value: cdktf.booleanToHclTerraform(struct!.skipOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag_after_processing: {
      value: cdktf.booleanToHclTerraform(struct!.tagAfterProcessing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputS3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._checkpointing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkpointing = this._checkpointing?.internalValue;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enableSqsAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSqsAssumeRole = this._enableSqsAssumeRole;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileFilter = this._fileFilter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._parquetChunkDownloadTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkDownloadTimeout = this._parquetChunkDownloadTimeout;
    }
    if (this._parquetChunkSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkSizeMb = this._parquetChunkSizeMb;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._processedTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagKey = this._processedTagKey;
    }
    if (this._processedTagValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagValue = this._processedTagValue;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._skipOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipOnError = this._skipOnError;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tagAfterProcessing !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagAfterProcessing = this._tagAfterProcessing;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._breakerRulesets = undefined;
      this._checkpointing.internalValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._enableSqsAssumeRole = undefined;
      this._encoding = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileFilter = undefined;
      this._id = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._parquetChunkDownloadTimeout = undefined;
      this._parquetChunkSizeMb = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._processedTagKey = undefined;
      this._processedTagValue = undefined;
      this._queueName = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._skipOnError = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tagAfterProcessing = undefined;
      this._type = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._breakerRulesets = value.breakerRulesets;
      this._checkpointing.internalValue = value.checkpointing;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enableSqsAssumeRole = value.enableSqsAssumeRole;
      this._encoding = value.encoding;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileFilter = value.fileFilter;
      this._id = value.id;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._parquetChunkDownloadTimeout = value.parquetChunkDownloadTimeout;
      this._parquetChunkSizeMb = value.parquetChunkSizeMb;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._processedTagKey = value.processedTagKey;
      this._processedTagValue = value.processedTagValue;
      this._queueName = value.queueName;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._skipOnError = value.skipOnError;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tagAfterProcessing = value.tagAfterProcessing;
      this._type = value.type;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // checkpointing - computed: false, optional: true, required: false
  private _checkpointing = new SourceInputS3CheckpointingOutputReference(this, "checkpointing");
  public get checkpointing() {
    return this._checkpointing;
  }
  public putCheckpointing(value: SourceInputS3Checkpointing) {
    this._checkpointing.internalValue = value;
  }
  public resetCheckpointing() {
    this._checkpointing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkpointingInput() {
    return this._checkpointing.internalValue;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputS3ConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputS3Connections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_sqs_assume_role - computed: true, optional: true, required: false
  private _enableSqsAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableSqsAssumeRole() {
    return this.getBooleanAttribute('enable_sqs_assume_role');
  }
  public set enableSqsAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableSqsAssumeRole = value;
  }
  public resetEnableSqsAssumeRole() {
    this._enableSqsAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSqsAssumeRoleInput() {
    return this._enableSqsAssumeRole;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_filter - computed: true, optional: true, required: false
  private _fileFilter?: string; 
  public get fileFilter() {
    return this.getStringAttribute('file_filter');
  }
  public set fileFilter(value: string) {
    this._fileFilter = value;
  }
  public resetFileFilter() {
    this._fileFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileFilterInput() {
    return this._fileFilter;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputS3MetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputS3Metadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // parquet_chunk_download_timeout - computed: true, optional: true, required: false
  private _parquetChunkDownloadTimeout?: number; 
  public get parquetChunkDownloadTimeout() {
    return this.getNumberAttribute('parquet_chunk_download_timeout');
  }
  public set parquetChunkDownloadTimeout(value: number) {
    this._parquetChunkDownloadTimeout = value;
  }
  public resetParquetChunkDownloadTimeout() {
    this._parquetChunkDownloadTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkDownloadTimeoutInput() {
    return this._parquetChunkDownloadTimeout;
  }

  // parquet_chunk_size_mb - computed: true, optional: true, required: false
  private _parquetChunkSizeMb?: number; 
  public get parquetChunkSizeMb() {
    return this.getNumberAttribute('parquet_chunk_size_mb');
  }
  public set parquetChunkSizeMb(value: number) {
    this._parquetChunkSizeMb = value;
  }
  public resetParquetChunkSizeMb() {
    this._parquetChunkSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkSizeMbInput() {
    return this._parquetChunkSizeMb;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputS3PqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputS3Pq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new SourceInputS3PreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: SourceInputS3Preprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // processed_tag_key - computed: false, optional: true, required: false
  private _processedTagKey?: string; 
  public get processedTagKey() {
    return this.getStringAttribute('processed_tag_key');
  }
  public set processedTagKey(value: string) {
    this._processedTagKey = value;
  }
  public resetProcessedTagKey() {
    this._processedTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagKeyInput() {
    return this._processedTagKey;
  }

  // processed_tag_value - computed: false, optional: true, required: false
  private _processedTagValue?: string; 
  public get processedTagValue() {
    return this.getStringAttribute('processed_tag_value');
  }
  public set processedTagValue(value: string) {
    this._processedTagValue = value;
  }
  public resetProcessedTagValue() {
    this._processedTagValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagValueInput() {
    return this._processedTagValue;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // skip_on_error - computed: true, optional: true, required: false
  private _skipOnError?: boolean | cdktf.IResolvable; 
  public get skipOnError() {
    return this.getBooleanAttribute('skip_on_error');
  }
  public set skipOnError(value: boolean | cdktf.IResolvable) {
    this._skipOnError = value;
  }
  public resetSkipOnError() {
    this._skipOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipOnErrorInput() {
    return this._skipOnError;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tag_after_processing - computed: true, optional: true, required: false
  private _tagAfterProcessing?: boolean | cdktf.IResolvable; 
  public get tagAfterProcessing() {
    return this.getBooleanAttribute('tag_after_processing');
  }
  public set tagAfterProcessing(value: boolean | cdktf.IResolvable) {
    this._tagAfterProcessing = value;
  }
  public resetTagAfterProcessing() {
    this._tagAfterProcessing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagAfterProcessingInput() {
    return this._tagAfterProcessing;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface SourceInputS3InventoryCheckpointing {
  /**
  * Resume processing files after an interruption. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enabled Source#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retries Source#retries}
  */
  readonly retries?: number;
}

export function sourceInputS3InventoryCheckpointingToTerraform(struct?: SourceInputS3InventoryCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    retries: cdktf.numberToTerraform(struct!.retries),
  }
}


export function sourceInputS3InventoryCheckpointingToHclTerraform(struct?: SourceInputS3InventoryCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3InventoryCheckpointingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputS3InventoryCheckpointing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3InventoryCheckpointing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._retries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._retries = value.retries;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // retries - computed: true, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }
}
export interface SourceInputS3InventoryConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputS3InventoryConnectionsToTerraform(struct?: SourceInputS3InventoryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputS3InventoryConnectionsToHclTerraform(struct?: SourceInputS3InventoryConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3InventoryConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputS3InventoryConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3InventoryConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputS3InventoryConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputS3InventoryConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputS3InventoryConnectionsOutputReference {
    return new SourceInputS3InventoryConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputS3InventoryMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputS3InventoryMetadataToTerraform(struct?: SourceInputS3InventoryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputS3InventoryMetadataToHclTerraform(struct?: SourceInputS3InventoryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3InventoryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputS3InventoryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3InventoryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputS3InventoryMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputS3InventoryMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputS3InventoryMetadataOutputReference {
    return new SourceInputS3InventoryMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputS3InventoryPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputS3InventoryPqToTerraform(struct?: SourceInputS3InventoryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputS3InventoryPqToHclTerraform(struct?: SourceInputS3InventoryPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3InventoryPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputS3InventoryPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3InventoryPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputS3InventoryPreprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#args Source#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#command Source#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function sourceInputS3InventoryPreprocessToTerraform(struct?: SourceInputS3InventoryPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function sourceInputS3InventoryPreprocessToHclTerraform(struct?: SourceInputS3InventoryPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3InventoryPreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputS3InventoryPreprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3InventoryPreprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface SourceInputS3Inventory {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_arn Source#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_external_id Source#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_account_id Source#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_api_key Source#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_authentication_method Source#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret Source#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret_key Source#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#checkpointing Source#checkpointing}
  */
  readonly checkpointing?: SourceInputS3InventoryCheckpointing;
  /**
  * Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum". Default: "checksum"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#checksum_suffix Source#checksum_suffix}
  */
  readonly checksumSuffix?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputS3InventoryConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#duration_seconds Source#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Amazon S3. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_assume_role Source#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Use Assume Role credentials when accessing Amazon SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_sqs_assume_role Source#enable_sqs_assume_role}
  */
  readonly enableSqsAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Regex matching file names to download and process. Defaults to: .*. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#file_filter Source#file_filter}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly fileFilter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_manifest_size_kb Source#max_manifest_size_kb}
  */
  readonly maxManifestSizeKb?: number;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_messages Source#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputS3InventoryMetadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#num_receivers Source#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#parquet_chunk_download_timeout Source#parquet_chunk_download_timeout}
  */
  readonly parquetChunkDownloadTimeout?: number;
  /**
  * Maximum file size for each Parquet chunk. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#parquet_chunk_size_mb Source#parquet_chunk_size_mb}
  */
  readonly parquetChunkSizeMb?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#poll_timeout Source#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputS3InventoryPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#preprocess Source#preprocess}
  */
  readonly preprocess?: SourceInputS3InventoryPreprocess;
  /**
  * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#processed_tag_key Source#processed_tag_key}
  */
  readonly processedTagKey?: string;
  /**
  * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#processed_tag_value Source#processed_tag_value}
  */
  readonly processedTagValue?: string;
  /**
  * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#queue_name Source#queue_name}
  */
  readonly queueName: string;
  /**
  * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#region Source#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reuse_connections Source#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#signature_version Source#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#skip_on_error Source#skip_on_error}
  */
  readonly skipOnError?: boolean | cdktf.IResolvable;
  /**
  * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be one of ["false", "true"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tag_after_processing Source#tag_after_processing}
  */
  readonly tagAfterProcessing?: string;
  /**
  * must be "s3_inventory"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
  /**
  * If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#validate_inventory_files Source#validate_inventory_files}
  */
  readonly validateInventoryFiles?: boolean | cdktf.IResolvable;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#visibility_timeout Source#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function sourceInputS3InventoryToTerraform(struct?: SourceInputS3Inventory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    checkpointing: sourceInputS3InventoryCheckpointingToTerraform(struct!.checkpointing),
    checksum_suffix: cdktf.stringToTerraform(struct!.checksumSuffix),
    connections: cdktf.listMapper(sourceInputS3InventoryConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_sqs_assume_role: cdktf.booleanToTerraform(struct!.enableSqsAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_filter: cdktf.stringToTerraform(struct!.fileFilter),
    id: cdktf.stringToTerraform(struct!.id),
    max_manifest_size_kb: cdktf.numberToTerraform(struct!.maxManifestSizeKb),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(sourceInputS3InventoryMetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    parquet_chunk_download_timeout: cdktf.numberToTerraform(struct!.parquetChunkDownloadTimeout),
    parquet_chunk_size_mb: cdktf.numberToTerraform(struct!.parquetChunkSizeMb),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: sourceInputS3InventoryPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: sourceInputS3InventoryPreprocessToTerraform(struct!.preprocess),
    processed_tag_key: cdktf.stringToTerraform(struct!.processedTagKey),
    processed_tag_value: cdktf.stringToTerraform(struct!.processedTagValue),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    skip_on_error: cdktf.booleanToTerraform(struct!.skipOnError),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tag_after_processing: cdktf.stringToTerraform(struct!.tagAfterProcessing),
    type: cdktf.stringToTerraform(struct!.type),
    validate_inventory_files: cdktf.booleanToTerraform(struct!.validateInventoryFiles),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function sourceInputS3InventoryToHclTerraform(struct?: SourceInputS3Inventory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    checkpointing: {
      value: sourceInputS3InventoryCheckpointingToHclTerraform(struct!.checkpointing),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputS3InventoryCheckpointing",
    },
    checksum_suffix: {
      value: cdktf.stringToHclTerraform(struct!.checksumSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputS3InventoryConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputS3InventoryConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sqs_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableSqsAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_filter: {
      value: cdktf.stringToHclTerraform(struct!.fileFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_manifest_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxManifestSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputS3InventoryMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputS3InventoryMetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_download_timeout: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkDownloadTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputS3InventoryPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputS3InventoryPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: sourceInputS3InventoryPreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputS3InventoryPreprocess",
    },
    processed_tag_key: {
      value: cdktf.stringToHclTerraform(struct!.processedTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processed_tag_value: {
      value: cdktf.stringToHclTerraform(struct!.processedTagValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_on_error: {
      value: cdktf.booleanToHclTerraform(struct!.skipOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag_after_processing: {
      value: cdktf.stringToHclTerraform(struct!.tagAfterProcessing),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    validate_inventory_files: {
      value: cdktf.booleanToHclTerraform(struct!.validateInventoryFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputS3InventoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputS3Inventory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._checkpointing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkpointing = this._checkpointing?.internalValue;
    }
    if (this._checksumSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.checksumSuffix = this._checksumSuffix;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enableSqsAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSqsAssumeRole = this._enableSqsAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileFilter = this._fileFilter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxManifestSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxManifestSizeKb = this._maxManifestSizeKb;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._parquetChunkDownloadTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkDownloadTimeout = this._parquetChunkDownloadTimeout;
    }
    if (this._parquetChunkSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkSizeMb = this._parquetChunkSizeMb;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._processedTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagKey = this._processedTagKey;
    }
    if (this._processedTagValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagValue = this._processedTagValue;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._skipOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipOnError = this._skipOnError;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tagAfterProcessing !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagAfterProcessing = this._tagAfterProcessing;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._validateInventoryFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.validateInventoryFiles = this._validateInventoryFiles;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputS3Inventory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._breakerRulesets = undefined;
      this._checkpointing.internalValue = undefined;
      this._checksumSuffix = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._enableSqsAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileFilter = undefined;
      this._id = undefined;
      this._maxManifestSizeKb = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._parquetChunkDownloadTimeout = undefined;
      this._parquetChunkSizeMb = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._processedTagKey = undefined;
      this._processedTagValue = undefined;
      this._queueName = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._skipOnError = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tagAfterProcessing = undefined;
      this._type = undefined;
      this._validateInventoryFiles = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._breakerRulesets = value.breakerRulesets;
      this._checkpointing.internalValue = value.checkpointing;
      this._checksumSuffix = value.checksumSuffix;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enableSqsAssumeRole = value.enableSqsAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileFilter = value.fileFilter;
      this._id = value.id;
      this._maxManifestSizeKb = value.maxManifestSizeKb;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._parquetChunkDownloadTimeout = value.parquetChunkDownloadTimeout;
      this._parquetChunkSizeMb = value.parquetChunkSizeMb;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._processedTagKey = value.processedTagKey;
      this._processedTagValue = value.processedTagValue;
      this._queueName = value.queueName;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._skipOnError = value.skipOnError;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tagAfterProcessing = value.tagAfterProcessing;
      this._type = value.type;
      this._validateInventoryFiles = value.validateInventoryFiles;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // checkpointing - computed: false, optional: true, required: false
  private _checkpointing = new SourceInputS3InventoryCheckpointingOutputReference(this, "checkpointing");
  public get checkpointing() {
    return this._checkpointing;
  }
  public putCheckpointing(value: SourceInputS3InventoryCheckpointing) {
    this._checkpointing.internalValue = value;
  }
  public resetCheckpointing() {
    this._checkpointing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkpointingInput() {
    return this._checkpointing.internalValue;
  }

  // checksum_suffix - computed: true, optional: true, required: false
  private _checksumSuffix?: string; 
  public get checksumSuffix() {
    return this.getStringAttribute('checksum_suffix');
  }
  public set checksumSuffix(value: string) {
    this._checksumSuffix = value;
  }
  public resetChecksumSuffix() {
    this._checksumSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checksumSuffixInput() {
    return this._checksumSuffix;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputS3InventoryConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputS3InventoryConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_sqs_assume_role - computed: true, optional: true, required: false
  private _enableSqsAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableSqsAssumeRole() {
    return this.getBooleanAttribute('enable_sqs_assume_role');
  }
  public set enableSqsAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableSqsAssumeRole = value;
  }
  public resetEnableSqsAssumeRole() {
    this._enableSqsAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSqsAssumeRoleInput() {
    return this._enableSqsAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_filter - computed: true, optional: true, required: false
  private _fileFilter?: string; 
  public get fileFilter() {
    return this.getStringAttribute('file_filter');
  }
  public set fileFilter(value: string) {
    this._fileFilter = value;
  }
  public resetFileFilter() {
    this._fileFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileFilterInput() {
    return this._fileFilter;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_manifest_size_kb - computed: true, optional: true, required: false
  private _maxManifestSizeKb?: number; 
  public get maxManifestSizeKb() {
    return this.getNumberAttribute('max_manifest_size_kb');
  }
  public set maxManifestSizeKb(value: number) {
    this._maxManifestSizeKb = value;
  }
  public resetMaxManifestSizeKb() {
    this._maxManifestSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxManifestSizeKbInput() {
    return this._maxManifestSizeKb;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputS3InventoryMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputS3InventoryMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // parquet_chunk_download_timeout - computed: true, optional: true, required: false
  private _parquetChunkDownloadTimeout?: number; 
  public get parquetChunkDownloadTimeout() {
    return this.getNumberAttribute('parquet_chunk_download_timeout');
  }
  public set parquetChunkDownloadTimeout(value: number) {
    this._parquetChunkDownloadTimeout = value;
  }
  public resetParquetChunkDownloadTimeout() {
    this._parquetChunkDownloadTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkDownloadTimeoutInput() {
    return this._parquetChunkDownloadTimeout;
  }

  // parquet_chunk_size_mb - computed: true, optional: true, required: false
  private _parquetChunkSizeMb?: number; 
  public get parquetChunkSizeMb() {
    return this.getNumberAttribute('parquet_chunk_size_mb');
  }
  public set parquetChunkSizeMb(value: number) {
    this._parquetChunkSizeMb = value;
  }
  public resetParquetChunkSizeMb() {
    this._parquetChunkSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkSizeMbInput() {
    return this._parquetChunkSizeMb;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputS3InventoryPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputS3InventoryPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new SourceInputS3InventoryPreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: SourceInputS3InventoryPreprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // processed_tag_key - computed: false, optional: true, required: false
  private _processedTagKey?: string; 
  public get processedTagKey() {
    return this.getStringAttribute('processed_tag_key');
  }
  public set processedTagKey(value: string) {
    this._processedTagKey = value;
  }
  public resetProcessedTagKey() {
    this._processedTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagKeyInput() {
    return this._processedTagKey;
  }

  // processed_tag_value - computed: false, optional: true, required: false
  private _processedTagValue?: string; 
  public get processedTagValue() {
    return this.getStringAttribute('processed_tag_value');
  }
  public set processedTagValue(value: string) {
    this._processedTagValue = value;
  }
  public resetProcessedTagValue() {
    this._processedTagValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagValueInput() {
    return this._processedTagValue;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // skip_on_error - computed: true, optional: true, required: false
  private _skipOnError?: boolean | cdktf.IResolvable; 
  public get skipOnError() {
    return this.getBooleanAttribute('skip_on_error');
  }
  public set skipOnError(value: boolean | cdktf.IResolvable) {
    this._skipOnError = value;
  }
  public resetSkipOnError() {
    this._skipOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipOnErrorInput() {
    return this._skipOnError;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tag_after_processing - computed: false, optional: true, required: false
  private _tagAfterProcessing?: string; 
  public get tagAfterProcessing() {
    return this.getStringAttribute('tag_after_processing');
  }
  public set tagAfterProcessing(value: string) {
    this._tagAfterProcessing = value;
  }
  public resetTagAfterProcessing() {
    this._tagAfterProcessing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagAfterProcessingInput() {
    return this._tagAfterProcessing;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // validate_inventory_files - computed: true, optional: true, required: false
  private _validateInventoryFiles?: boolean | cdktf.IResolvable; 
  public get validateInventoryFiles() {
    return this.getBooleanAttribute('validate_inventory_files');
  }
  public set validateInventoryFiles(value: boolean | cdktf.IResolvable) {
    this._validateInventoryFiles = value;
  }
  public resetValidateInventoryFiles() {
    this._validateInventoryFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validateInventoryFilesInput() {
    return this._validateInventoryFiles;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface SourceInputSecurityLakeCheckpointing {
  /**
  * Resume processing files after an interruption. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enabled Source#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retries Source#retries}
  */
  readonly retries?: number;
}

export function sourceInputSecurityLakeCheckpointingToTerraform(struct?: SourceInputSecurityLakeCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    retries: cdktf.numberToTerraform(struct!.retries),
  }
}


export function sourceInputSecurityLakeCheckpointingToHclTerraform(struct?: SourceInputSecurityLakeCheckpointing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retries: {
      value: cdktf.numberToHclTerraform(struct!.retries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSecurityLakeCheckpointingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSecurityLakeCheckpointing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._retries !== undefined) {
      hasAnyValues = true;
      internalValueResult.retries = this._retries;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSecurityLakeCheckpointing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._retries = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._retries = value.retries;
    }
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // retries - computed: true, optional: true, required: false
  private _retries?: number; 
  public get retries() {
    return this.getNumberAttribute('retries');
  }
  public set retries(value: number) {
    this._retries = value;
  }
  public resetRetries() {
    this._retries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retriesInput() {
    return this._retries;
  }
}
export interface SourceInputSecurityLakeConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSecurityLakeConnectionsToTerraform(struct?: SourceInputSecurityLakeConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSecurityLakeConnectionsToHclTerraform(struct?: SourceInputSecurityLakeConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSecurityLakeConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSecurityLakeConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSecurityLakeConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSecurityLakeConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSecurityLakeConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSecurityLakeConnectionsOutputReference {
    return new SourceInputSecurityLakeConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSecurityLakeMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSecurityLakeMetadataToTerraform(struct?: SourceInputSecurityLakeMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSecurityLakeMetadataToHclTerraform(struct?: SourceInputSecurityLakeMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSecurityLakeMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSecurityLakeMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSecurityLakeMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSecurityLakeMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSecurityLakeMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSecurityLakeMetadataOutputReference {
    return new SourceInputSecurityLakeMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSecurityLakePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSecurityLakePqToTerraform(struct?: SourceInputSecurityLakePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSecurityLakePqToHclTerraform(struct?: SourceInputSecurityLakePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSecurityLakePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSecurityLakePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSecurityLakePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSecurityLakePreprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#args Source#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#command Source#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function sourceInputSecurityLakePreprocessToTerraform(struct?: SourceInputSecurityLakePreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function sourceInputSecurityLakePreprocessToHclTerraform(struct?: SourceInputSecurityLakePreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSecurityLakePreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSecurityLakePreprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSecurityLakePreprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface SourceInputSecurityLake {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_arn Source#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_external_id Source#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_account_id Source#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_api_key Source#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_authentication_method Source#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret Source#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret_key Source#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#checkpointing Source#checkpointing}
  */
  readonly checkpointing?: SourceInputSecurityLakeCheckpointing;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSecurityLakeConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#duration_seconds Source#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Amazon S3. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_assume_role Source#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Use Assume Role credentials when accessing Amazon SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_sqs_assume_role Source#enable_sqs_assume_role}
  */
  readonly enableSqsAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#encoding Source#encoding}
  */
  readonly encoding?: string;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Regex matching file names to download and process. Defaults to: .*. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#file_filter Source#file_filter}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly fileFilter?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_messages Source#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSecurityLakeMetadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#num_receivers Source#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#parquet_chunk_download_timeout Source#parquet_chunk_download_timeout}
  */
  readonly parquetChunkDownloadTimeout?: number;
  /**
  * Maximum file size for each Parquet chunk. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#parquet_chunk_size_mb Source#parquet_chunk_size_mb}
  */
  readonly parquetChunkSizeMb?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#poll_timeout Source#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSecurityLakePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#preprocess Source#preprocess}
  */
  readonly preprocess?: SourceInputSecurityLakePreprocess;
  /**
  * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#processed_tag_key Source#processed_tag_key}
  */
  readonly processedTagKey?: string;
  /**
  * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#processed_tag_value Source#processed_tag_value}
  */
  readonly processedTagValue?: string;
  /**
  * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#queue_name Source#queue_name}
  */
  readonly queueName: string;
  /**
  * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#region Source#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reuse_connections Source#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#signature_version Source#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#skip_on_error Source#skip_on_error}
  */
  readonly skipOnError?: boolean | cdktf.IResolvable;
  /**
  * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be one of ["false", "true"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tag_after_processing Source#tag_after_processing}
  */
  readonly tagAfterProcessing?: string;
  /**
  * must be "security_lake"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#visibility_timeout Source#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function sourceInputSecurityLakeToTerraform(struct?: SourceInputSecurityLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    checkpointing: sourceInputSecurityLakeCheckpointingToTerraform(struct!.checkpointing),
    connections: cdktf.listMapper(sourceInputSecurityLakeConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_sqs_assume_role: cdktf.booleanToTerraform(struct!.enableSqsAssumeRole),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_filter: cdktf.stringToTerraform(struct!.fileFilter),
    id: cdktf.stringToTerraform(struct!.id),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(sourceInputSecurityLakeMetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    parquet_chunk_download_timeout: cdktf.numberToTerraform(struct!.parquetChunkDownloadTimeout),
    parquet_chunk_size_mb: cdktf.numberToTerraform(struct!.parquetChunkSizeMb),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: sourceInputSecurityLakePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: sourceInputSecurityLakePreprocessToTerraform(struct!.preprocess),
    processed_tag_key: cdktf.stringToTerraform(struct!.processedTagKey),
    processed_tag_value: cdktf.stringToTerraform(struct!.processedTagValue),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    skip_on_error: cdktf.booleanToTerraform(struct!.skipOnError),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tag_after_processing: cdktf.stringToTerraform(struct!.tagAfterProcessing),
    type: cdktf.stringToTerraform(struct!.type),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function sourceInputSecurityLakeToHclTerraform(struct?: SourceInputSecurityLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    checkpointing: {
      value: sourceInputSecurityLakeCheckpointingToHclTerraform(struct!.checkpointing),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSecurityLakeCheckpointing",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSecurityLakeConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSecurityLakeConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_sqs_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableSqsAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_filter: {
      value: cdktf.stringToHclTerraform(struct!.fileFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSecurityLakeMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSecurityLakeMetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_download_timeout: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkDownloadTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_chunk_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.parquetChunkSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputSecurityLakePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSecurityLakePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: sourceInputSecurityLakePreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSecurityLakePreprocess",
    },
    processed_tag_key: {
      value: cdktf.stringToHclTerraform(struct!.processedTagKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processed_tag_value: {
      value: cdktf.stringToHclTerraform(struct!.processedTagValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_on_error: {
      value: cdktf.booleanToHclTerraform(struct!.skipOnError),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tag_after_processing: {
      value: cdktf.stringToHclTerraform(struct!.tagAfterProcessing),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSecurityLakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSecurityLake | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._checkpointing?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkpointing = this._checkpointing?.internalValue;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enableSqsAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableSqsAssumeRole = this._enableSqsAssumeRole;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileFilter = this._fileFilter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._parquetChunkDownloadTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkDownloadTimeout = this._parquetChunkDownloadTimeout;
    }
    if (this._parquetChunkSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetChunkSizeMb = this._parquetChunkSizeMb;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._processedTagKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagKey = this._processedTagKey;
    }
    if (this._processedTagValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processedTagValue = this._processedTagValue;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._skipOnError !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipOnError = this._skipOnError;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tagAfterProcessing !== undefined) {
      hasAnyValues = true;
      internalValueResult.tagAfterProcessing = this._tagAfterProcessing;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSecurityLake | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._breakerRulesets = undefined;
      this._checkpointing.internalValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._enableSqsAssumeRole = undefined;
      this._encoding = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileFilter = undefined;
      this._id = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._parquetChunkDownloadTimeout = undefined;
      this._parquetChunkSizeMb = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._processedTagKey = undefined;
      this._processedTagValue = undefined;
      this._queueName = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._skipOnError = undefined;
      this._socketTimeout = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tagAfterProcessing = undefined;
      this._type = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._breakerRulesets = value.breakerRulesets;
      this._checkpointing.internalValue = value.checkpointing;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enableSqsAssumeRole = value.enableSqsAssumeRole;
      this._encoding = value.encoding;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileFilter = value.fileFilter;
      this._id = value.id;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._parquetChunkDownloadTimeout = value.parquetChunkDownloadTimeout;
      this._parquetChunkSizeMb = value.parquetChunkSizeMb;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._processedTagKey = value.processedTagKey;
      this._processedTagValue = value.processedTagValue;
      this._queueName = value.queueName;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._skipOnError = value.skipOnError;
      this._socketTimeout = value.socketTimeout;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tagAfterProcessing = value.tagAfterProcessing;
      this._type = value.type;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // checkpointing - computed: false, optional: true, required: false
  private _checkpointing = new SourceInputSecurityLakeCheckpointingOutputReference(this, "checkpointing");
  public get checkpointing() {
    return this._checkpointing;
  }
  public putCheckpointing(value: SourceInputSecurityLakeCheckpointing) {
    this._checkpointing.internalValue = value;
  }
  public resetCheckpointing() {
    this._checkpointing.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkpointingInput() {
    return this._checkpointing.internalValue;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSecurityLakeConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSecurityLakeConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_sqs_assume_role - computed: true, optional: true, required: false
  private _enableSqsAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableSqsAssumeRole() {
    return this.getBooleanAttribute('enable_sqs_assume_role');
  }
  public set enableSqsAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableSqsAssumeRole = value;
  }
  public resetEnableSqsAssumeRole() {
    this._enableSqsAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableSqsAssumeRoleInput() {
    return this._enableSqsAssumeRole;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_filter - computed: true, optional: true, required: false
  private _fileFilter?: string; 
  public get fileFilter() {
    return this.getStringAttribute('file_filter');
  }
  public set fileFilter(value: string) {
    this._fileFilter = value;
  }
  public resetFileFilter() {
    this._fileFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileFilterInput() {
    return this._fileFilter;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSecurityLakeMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSecurityLakeMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // parquet_chunk_download_timeout - computed: true, optional: true, required: false
  private _parquetChunkDownloadTimeout?: number; 
  public get parquetChunkDownloadTimeout() {
    return this.getNumberAttribute('parquet_chunk_download_timeout');
  }
  public set parquetChunkDownloadTimeout(value: number) {
    this._parquetChunkDownloadTimeout = value;
  }
  public resetParquetChunkDownloadTimeout() {
    this._parquetChunkDownloadTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkDownloadTimeoutInput() {
    return this._parquetChunkDownloadTimeout;
  }

  // parquet_chunk_size_mb - computed: true, optional: true, required: false
  private _parquetChunkSizeMb?: number; 
  public get parquetChunkSizeMb() {
    return this.getNumberAttribute('parquet_chunk_size_mb');
  }
  public set parquetChunkSizeMb(value: number) {
    this._parquetChunkSizeMb = value;
  }
  public resetParquetChunkSizeMb() {
    this._parquetChunkSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetChunkSizeMbInput() {
    return this._parquetChunkSizeMb;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSecurityLakePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSecurityLakePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new SourceInputSecurityLakePreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: SourceInputSecurityLakePreprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // processed_tag_key - computed: false, optional: true, required: false
  private _processedTagKey?: string; 
  public get processedTagKey() {
    return this.getStringAttribute('processed_tag_key');
  }
  public set processedTagKey(value: string) {
    this._processedTagKey = value;
  }
  public resetProcessedTagKey() {
    this._processedTagKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagKeyInput() {
    return this._processedTagKey;
  }

  // processed_tag_value - computed: false, optional: true, required: false
  private _processedTagValue?: string; 
  public get processedTagValue() {
    return this.getStringAttribute('processed_tag_value');
  }
  public set processedTagValue(value: string) {
    this._processedTagValue = value;
  }
  public resetProcessedTagValue() {
    this._processedTagValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processedTagValueInput() {
    return this._processedTagValue;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // skip_on_error - computed: true, optional: true, required: false
  private _skipOnError?: boolean | cdktf.IResolvable; 
  public get skipOnError() {
    return this.getBooleanAttribute('skip_on_error');
  }
  public set skipOnError(value: boolean | cdktf.IResolvable) {
    this._skipOnError = value;
  }
  public resetSkipOnError() {
    this._skipOnError = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipOnErrorInput() {
    return this._skipOnError;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tag_after_processing - computed: false, optional: true, required: false
  private _tagAfterProcessing?: string; 
  public get tagAfterProcessing() {
    return this.getStringAttribute('tag_after_processing');
  }
  public set tagAfterProcessing(value: string) {
    this._tagAfterProcessing = value;
  }
  public resetTagAfterProcessing() {
    this._tagAfterProcessing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagAfterProcessingInput() {
    return this._tagAfterProcessing;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface SourceInputSnmpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSnmpConnectionsToTerraform(struct?: SourceInputSnmpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSnmpConnectionsToHclTerraform(struct?: SourceInputSnmpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSnmpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSnmpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSnmpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSnmpConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSnmpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSnmpConnectionsOutputReference {
    return new SourceInputSnmpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSnmpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSnmpMetadataToTerraform(struct?: SourceInputSnmpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSnmpMetadataToHclTerraform(struct?: SourceInputSnmpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSnmpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSnmpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSnmpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSnmpMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSnmpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSnmpMetadataOutputReference {
    return new SourceInputSnmpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSnmpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSnmpPqToTerraform(struct?: SourceInputSnmpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSnmpPqToHclTerraform(struct?: SourceInputSnmpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSnmpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSnmpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSnmpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSnmpSnmpV3AuthV3Users {
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_key Source#auth_key}
  */
  readonly authKey?: string;
  /**
  * Default: "none"; must be one of ["none", "md5", "sha", "sha224", "sha256", "sha384", "sha512"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_protocol Source#auth_protocol}
  */
  readonly authProtocol?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * Default: "none"; Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_protocol Source#priv_protocol}
  */
  readonly privProtocol?: string;
}

export function sourceInputSnmpSnmpV3AuthV3UsersToTerraform(struct?: SourceInputSnmpSnmpV3AuthV3Users | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_key: cdktf.stringToTerraform(struct!.authKey),
    auth_protocol: cdktf.stringToTerraform(struct!.authProtocol),
    name: cdktf.stringToTerraform(struct!.name),
    priv_protocol: cdktf.stringToTerraform(struct!.privProtocol),
  }
}


export function sourceInputSnmpSnmpV3AuthV3UsersToHclTerraform(struct?: SourceInputSnmpSnmpV3AuthV3Users | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_key: {
      value: cdktf.stringToHclTerraform(struct!.authKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_protocol: {
      value: cdktf.stringToHclTerraform(struct!.authProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_protocol: {
      value: cdktf.stringToHclTerraform(struct!.privProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSnmpSnmpV3AuthV3UsersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSnmpSnmpV3AuthV3Users | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.authKey = this._authKey;
    }
    if (this._authProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.authProtocol = this._authProtocol;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._privProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.privProtocol = this._privProtocol;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSnmpSnmpV3AuthV3Users | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authKey = undefined;
      this._authProtocol = undefined;
      this._name = undefined;
      this._privProtocol = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authKey = value.authKey;
      this._authProtocol = value.authProtocol;
      this._name = value.name;
      this._privProtocol = value.privProtocol;
    }
  }

  // auth_key - computed: false, optional: true, required: false
  private _authKey?: string; 
  public get authKey() {
    return this.getStringAttribute('auth_key');
  }
  public set authKey(value: string) {
    this._authKey = value;
  }
  public resetAuthKey() {
    this._authKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authKeyInput() {
    return this._authKey;
  }

  // auth_protocol - computed: true, optional: true, required: false
  private _authProtocol?: string; 
  public get authProtocol() {
    return this.getStringAttribute('auth_protocol');
  }
  public set authProtocol(value: string) {
    this._authProtocol = value;
  }
  public resetAuthProtocol() {
    this._authProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authProtocolInput() {
    return this._authProtocol;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // priv_protocol - computed: true, optional: true, required: false
  private _privProtocol?: string; 
  public get privProtocol() {
    return this.getStringAttribute('priv_protocol');
  }
  public set privProtocol(value: string) {
    this._privProtocol = value;
  }
  public resetPrivProtocol() {
    this._privProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privProtocolInput() {
    return this._privProtocol;
  }
}

export class SourceInputSnmpSnmpV3AuthV3UsersList extends cdktf.ComplexList {
  public internalValue? : SourceInputSnmpSnmpV3AuthV3Users[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSnmpSnmpV3AuthV3UsersOutputReference {
    return new SourceInputSnmpSnmpV3AuthV3UsersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSnmpSnmpV3Auth {
  /**
  * Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allow_unmatched_trap Source#allow_unmatched_trap}
  */
  readonly allowUnmatchedTrap?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#v3_auth_enabled Source#v3_auth_enabled}
  */
  readonly v3AuthEnabled?: boolean | cdktf.IResolvable;
  /**
  * User credentials for receiving v3 traps
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#v3_users Source#v3_users}
  */
  readonly v3Users?: SourceInputSnmpSnmpV3AuthV3Users[] | cdktf.IResolvable;
}

export function sourceInputSnmpSnmpV3AuthToTerraform(struct?: SourceInputSnmpSnmpV3Auth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_unmatched_trap: cdktf.booleanToTerraform(struct!.allowUnmatchedTrap),
    v3_auth_enabled: cdktf.booleanToTerraform(struct!.v3AuthEnabled),
    v3_users: cdktf.listMapper(sourceInputSnmpSnmpV3AuthV3UsersToTerraform, false)(struct!.v3Users),
  }
}


export function sourceInputSnmpSnmpV3AuthToHclTerraform(struct?: SourceInputSnmpSnmpV3Auth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_unmatched_trap: {
      value: cdktf.booleanToHclTerraform(struct!.allowUnmatchedTrap),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    v3_auth_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.v3AuthEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    v3_users: {
      value: cdktf.listMapperHcl(sourceInputSnmpSnmpV3AuthV3UsersToHclTerraform, false)(struct!.v3Users),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSnmpSnmpV3AuthV3UsersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSnmpSnmpV3AuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSnmpSnmpV3Auth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowUnmatchedTrap !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowUnmatchedTrap = this._allowUnmatchedTrap;
    }
    if (this._v3AuthEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.v3AuthEnabled = this._v3AuthEnabled;
    }
    if (this._v3Users?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.v3Users = this._v3Users?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSnmpSnmpV3Auth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowUnmatchedTrap = undefined;
      this._v3AuthEnabled = undefined;
      this._v3Users.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowUnmatchedTrap = value.allowUnmatchedTrap;
      this._v3AuthEnabled = value.v3AuthEnabled;
      this._v3Users.internalValue = value.v3Users;
    }
  }

  // allow_unmatched_trap - computed: true, optional: true, required: false
  private _allowUnmatchedTrap?: boolean | cdktf.IResolvable; 
  public get allowUnmatchedTrap() {
    return this.getBooleanAttribute('allow_unmatched_trap');
  }
  public set allowUnmatchedTrap(value: boolean | cdktf.IResolvable) {
    this._allowUnmatchedTrap = value;
  }
  public resetAllowUnmatchedTrap() {
    this._allowUnmatchedTrap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowUnmatchedTrapInput() {
    return this._allowUnmatchedTrap;
  }

  // v3_auth_enabled - computed: true, optional: true, required: false
  private _v3AuthEnabled?: boolean | cdktf.IResolvable; 
  public get v3AuthEnabled() {
    return this.getBooleanAttribute('v3_auth_enabled');
  }
  public set v3AuthEnabled(value: boolean | cdktf.IResolvable) {
    this._v3AuthEnabled = value;
  }
  public resetV3AuthEnabled() {
    this._v3AuthEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get v3AuthEnabledInput() {
    return this._v3AuthEnabled;
  }

  // v3_users - computed: false, optional: true, required: false
  private _v3Users = new SourceInputSnmpSnmpV3AuthV3UsersList(this, "v3_users", false);
  public get v3Users() {
    return this._v3Users;
  }
  public putV3Users(value: SourceInputSnmpSnmpV3AuthV3Users[] | cdktf.IResolvable) {
    this._v3Users.internalValue = value;
  }
  public resetV3Users() {
    this._v3Users.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get v3UsersInput() {
    return this._v3Users.internalValue;
  }
}
export interface SourceInputSnmp {
  /**
  * If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#best_effort_parsing Source#best_effort_parsing}
  */
  readonly bestEffortParsing?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSnmpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_whitelist_regex Source#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of events to buffer when downstream is blocking. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSnmpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * UDP port to receive SNMP traps on. Defaults to 162. Default: 162
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSnmpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#snmp_v3_auth Source#snmp_v3_auth}
  */
  readonly snmpV3Auth?: SourceInputSnmpSnmpV3Auth;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "snmp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_socket_rx_buf_size Source#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
  /**
  * If enabled, parses varbinds as an array of objects that include OID, value, and type. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#varbinds_with_types Source#varbinds_with_types}
  */
  readonly varbindsWithTypes?: boolean | cdktf.IResolvable;
}

export function sourceInputSnmpToTerraform(struct?: SourceInputSnmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    best_effort_parsing: cdktf.booleanToTerraform(struct!.bestEffortParsing),
    connections: cdktf.listMapper(sourceInputSnmpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(sourceInputSnmpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputSnmpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    snmp_v3_auth: sourceInputSnmpSnmpV3AuthToTerraform(struct!.snmpV3Auth),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
    varbinds_with_types: cdktf.booleanToTerraform(struct!.varbindsWithTypes),
  }
}


export function sourceInputSnmpToHclTerraform(struct?: SourceInputSnmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    best_effort_parsing: {
      value: cdktf.booleanToHclTerraform(struct!.bestEffortParsing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSnmpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSnmpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSnmpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSnmpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputSnmpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSnmpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    snmp_v3_auth: {
      value: sourceInputSnmpSnmpV3AuthToHclTerraform(struct!.snmpV3Auth),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSnmpSnmpV3Auth",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    varbinds_with_types: {
      value: cdktf.booleanToHclTerraform(struct!.varbindsWithTypes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSnmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSnmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bestEffortParsing !== undefined) {
      hasAnyValues = true;
      internalValueResult.bestEffortParsing = this._bestEffortParsing;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._snmpV3Auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.snmpV3Auth = this._snmpV3Auth?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    if (this._varbindsWithTypes !== undefined) {
      hasAnyValues = true;
      internalValueResult.varbindsWithTypes = this._varbindsWithTypes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSnmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bestEffortParsing = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._snmpV3Auth.internalValue = undefined;
      this._streamtags = undefined;
      this._type = undefined;
      this._udpSocketRxBufSize = undefined;
      this._varbindsWithTypes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bestEffortParsing = value.bestEffortParsing;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._snmpV3Auth.internalValue = value.snmpV3Auth;
      this._streamtags = value.streamtags;
      this._type = value.type;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
      this._varbindsWithTypes = value.varbindsWithTypes;
    }
  }

  // best_effort_parsing - computed: true, optional: true, required: false
  private _bestEffortParsing?: boolean | cdktf.IResolvable; 
  public get bestEffortParsing() {
    return this.getBooleanAttribute('best_effort_parsing');
  }
  public set bestEffortParsing(value: boolean | cdktf.IResolvable) {
    this._bestEffortParsing = value;
  }
  public resetBestEffortParsing() {
    this._bestEffortParsing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bestEffortParsingInput() {
    return this._bestEffortParsing;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSnmpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSnmpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSnmpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSnmpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSnmpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSnmpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // snmp_v3_auth - computed: false, optional: true, required: false
  private _snmpV3Auth = new SourceInputSnmpSnmpV3AuthOutputReference(this, "snmp_v3_auth");
  public get snmpV3Auth() {
    return this._snmpV3Auth;
  }
  public putSnmpV3Auth(value: SourceInputSnmpSnmpV3Auth) {
    this._snmpV3Auth.internalValue = value;
  }
  public resetSnmpV3Auth() {
    this._snmpV3Auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snmpV3AuthInput() {
    return this._snmpV3Auth.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }

  // varbinds_with_types - computed: true, optional: true, required: false
  private _varbindsWithTypes?: boolean | cdktf.IResolvable; 
  public get varbindsWithTypes() {
    return this.getBooleanAttribute('varbinds_with_types');
  }
  public set varbindsWithTypes(value: boolean | cdktf.IResolvable) {
    this._varbindsWithTypes = value;
  }
  public resetVarbindsWithTypes() {
    this._varbindsWithTypes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get varbindsWithTypesInput() {
    return this._varbindsWithTypes;
  }
}
export interface SourceInputSplunkAuthTokens {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token Source#token}
  */
  readonly token: string;
}

export function sourceInputSplunkAuthTokensToTerraform(struct?: SourceInputSplunkAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    token: cdktf.stringToTerraform(struct!.token),
  }
}


export function sourceInputSplunkAuthTokensToHclTerraform(struct?: SourceInputSplunkAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkAuthTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkAuthTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkAuthTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._token = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._token = value.token;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }
}

export class SourceInputSplunkAuthTokensList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkAuthTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkAuthTokensOutputReference {
    return new SourceInputSplunkAuthTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSplunkConnectionsToTerraform(struct?: SourceInputSplunkConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSplunkConnectionsToHclTerraform(struct?: SourceInputSplunkConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSplunkConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkConnectionsOutputReference {
    return new SourceInputSplunkConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSplunkMetadataToTerraform(struct?: SourceInputSplunkMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSplunkMetadataToHclTerraform(struct?: SourceInputSplunkMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSplunkMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkMetadataOutputReference {
    return new SourceInputSplunkMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
