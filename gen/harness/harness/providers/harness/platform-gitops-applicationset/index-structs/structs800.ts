import * as cdktf from 'cdktf';
import { PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectory,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectoryToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectoryToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectoryOutputReference,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelm,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelmToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelmToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelmOutputReference,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestination,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestinationToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestinationToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestinationOutputReference,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifference,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifferenceToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifferenceToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifferenceList,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfo,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfoToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfoToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfoList,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadata,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadataToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadataToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadataOutputReference,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServer,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServerToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServerToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServerOutputReference,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilter,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilterToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilterToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilterList,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitea,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGiteaToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGiteaToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGiteaOutputReference,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithub,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithubToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithubToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithubOutputReference,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlab,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlabToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlabToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlabOutputReference,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorListStruct,
platformGitopsApplicationsetApplicationsetSpecGeneratorListStructToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorListStructToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorListStructList,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorMatrix,
platformGitopsApplicationsetApplicationsetSpecGeneratorMatrixToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorMatrixToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorMatrixList,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorMerge,
platformGitopsApplicationsetApplicationsetSpecGeneratorMergeToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorMergeToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorMergeList } from './structs400'
import { PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResource,
platformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResourceToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResourceToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResourceList,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusters,
platformGitopsApplicationsetApplicationsetSpecGeneratorClustersToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorClustersToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorClustersList,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorGit,
platformGitopsApplicationsetApplicationsetSpecGeneratorGitToTerraform,
platformGitopsApplicationsetApplicationsetSpecGeneratorGitToHclTerraform,
PlatformGitopsApplicationsetApplicationsetSpecGeneratorGitList,
PlatformGitopsApplicationsetApplicationsetMetadata,
platformGitopsApplicationsetApplicationsetMetadataToTerraform,
platformGitopsApplicationsetApplicationsetMetadataToHclTerraform,
PlatformGitopsApplicationsetApplicationsetMetadataOutputReference } from './structs0'
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomize {
  /**
  * List of additional annotations to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_annotations PlatformGitopsApplicationset#common_annotations}
  */
  readonly commonAnnotations?: { [key: string]: string };
  /**
  * List of additional labels to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_labels PlatformGitopsApplicationset#common_labels}
  */
  readonly commonLabels?: { [key: string]: string };
  /**
  * Indicates if to force applying common annotations to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_annotations PlatformGitopsApplicationset#force_common_annotations}
  */
  readonly forceCommonAnnotations?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to force apply common labels to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_labels PlatformGitopsApplicationset#force_common_labels}
  */
  readonly forceCommonLabels?: boolean | cdktf.IResolvable;
  /**
  * List of Kustomize image override specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#images PlatformGitopsApplicationset#images}
  */
  readonly images?: string[];
  /**
  * Prefix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_prefix PlatformGitopsApplicationset#name_prefix}
  */
  readonly namePrefix?: string;
  /**
  * Suffix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_suffix PlatformGitopsApplicationset#name_suffix}
  */
  readonly nameSuffix?: string;
  /**
  * Version of Kustomize to use for rendering manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    common_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonAnnotations),
    common_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonLabels),
    force_common_annotations: cdktf.booleanToTerraform(struct!.forceCommonAnnotations),
    force_common_labels: cdktf.booleanToTerraform(struct!.forceCommonLabels),
    images: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.images),
    name_prefix: cdktf.stringToTerraform(struct!.namePrefix),
    name_suffix: cdktf.stringToTerraform(struct!.nameSuffix),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    common_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    common_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    force_common_annotations: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    force_common_labels: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    images: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.images),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name_prefix: {
      value: cdktf.stringToHclTerraform(struct!.namePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.nameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomize | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonAnnotations = this._commonAnnotations;
    }
    if (this._commonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonLabels = this._commonLabels;
    }
    if (this._forceCommonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonAnnotations = this._forceCommonAnnotations;
    }
    if (this._forceCommonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonLabels = this._forceCommonLabels;
    }
    if (this._images !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images;
    }
    if (this._namePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.namePrefix = this._namePrefix;
    }
    if (this._nameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameSuffix = this._nameSuffix;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomize | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._commonAnnotations = undefined;
      this._commonLabels = undefined;
      this._forceCommonAnnotations = undefined;
      this._forceCommonLabels = undefined;
      this._images = undefined;
      this._namePrefix = undefined;
      this._nameSuffix = undefined;
      this._version = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._commonAnnotations = value.commonAnnotations;
      this._commonLabels = value.commonLabels;
      this._forceCommonAnnotations = value.forceCommonAnnotations;
      this._forceCommonLabels = value.forceCommonLabels;
      this._images = value.images;
      this._namePrefix = value.namePrefix;
      this._nameSuffix = value.nameSuffix;
      this._version = value.version;
    }
  }

  // common_annotations - computed: false, optional: true, required: false
  private _commonAnnotations?: { [key: string]: string }; 
  public get commonAnnotations() {
    return this.getStringMapAttribute('common_annotations');
  }
  public set commonAnnotations(value: { [key: string]: string }) {
    this._commonAnnotations = value;
  }
  public resetCommonAnnotations() {
    this._commonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonAnnotationsInput() {
    return this._commonAnnotations;
  }

  // common_labels - computed: false, optional: true, required: false
  private _commonLabels?: { [key: string]: string }; 
  public get commonLabels() {
    return this.getStringMapAttribute('common_labels');
  }
  public set commonLabels(value: { [key: string]: string }) {
    this._commonLabels = value;
  }
  public resetCommonLabels() {
    this._commonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonLabelsInput() {
    return this._commonLabels;
  }

  // force_common_annotations - computed: false, optional: true, required: false
  private _forceCommonAnnotations?: boolean | cdktf.IResolvable; 
  public get forceCommonAnnotations() {
    return this.getBooleanAttribute('force_common_annotations');
  }
  public set forceCommonAnnotations(value: boolean | cdktf.IResolvable) {
    this._forceCommonAnnotations = value;
  }
  public resetForceCommonAnnotations() {
    this._forceCommonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonAnnotationsInput() {
    return this._forceCommonAnnotations;
  }

  // force_common_labels - computed: false, optional: true, required: false
  private _forceCommonLabels?: boolean | cdktf.IResolvable; 
  public get forceCommonLabels() {
    return this.getBooleanAttribute('force_common_labels');
  }
  public set forceCommonLabels(value: boolean | cdktf.IResolvable) {
    this._forceCommonLabels = value;
  }
  public resetForceCommonLabels() {
    this._forceCommonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonLabelsInput() {
    return this._forceCommonLabels;
  }

  // images - computed: false, optional: true, required: false
  private _images?: string[]; 
  public get images() {
    return this.getListAttribute('images');
  }
  public set images(value: string[]) {
    this._images = value;
  }
  public resetImages() {
    this._images = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images;
  }

  // name_prefix - computed: false, optional: true, required: false
  private _namePrefix?: string; 
  public get namePrefix() {
    return this.getStringAttribute('name_prefix');
  }
  public set namePrefix(value: string) {
    this._namePrefix = value;
  }
  public resetNamePrefix() {
    this._namePrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namePrefixInput() {
    return this._namePrefix;
  }

  // name_suffix - computed: false, optional: true, required: false
  private _nameSuffix?: string; 
  public get nameSuffix() {
    return this.getStringAttribute('name_suffix');
  }
  public set nameSuffix(value: string) {
    this._nameSuffix = value;
  }
  public resetNameSuffix() {
    this._nameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameSuffixInput() {
    return this._nameSuffix;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnv {
  /**
  * Name of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePlugin {
  /**
  * Name of the plugin. Only set the plugin name if the plugin is defined in `argocd-cm`. If the plugin is defined as a sidecar, omit the name. The plugin will be automatically matched with the Application according to the plugin's discovery rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * env block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#env PlatformGitopsApplicationset#env}
  */
  readonly env?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnv[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    env: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvToTerraform, true)(struct!.env),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvToHclTerraform, true)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePlugin | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePlugin | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._env.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._env.internalValue = value.env;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // env - computed: false, optional: true, required: false
  private _env = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSource {
  /**
  * Helm chart name. Must be specified for applications sourced from a Helm repo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#chart PlatformGitopsApplicationset#chart}
  */
  readonly chart?: string;
  /**
  * Directory path within the repository. Only valid for applications sourced from Git.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path?: string;
  /**
  * Reference to another `source` within defined sources. See associated documentation on [Helm value files from external Git repository](https://argo-cd.readthedocs.io/en/stable/user-guide/multiple_sources/#helm-value-files-from-external-git-repository) regarding combining `ref` with `path` and/or `chart`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ref PlatformGitopsApplicationset#ref}
  */
  readonly ref?: string;
  /**
  * URL to the repository (Git or Helm) that contains the application manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#repo_url PlatformGitopsApplicationset#repo_url}
  */
  readonly repoUrl?: string;
  /**
  * Revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart's version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#target_revision PlatformGitopsApplicationset#target_revision}
  */
  readonly targetRevision?: string;
  /**
  * directory block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#directory PlatformGitopsApplicationset#directory}
  */
  readonly directory?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectory;
  /**
  * helm block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#helm PlatformGitopsApplicationset#helm}
  */
  readonly helm?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelm;
  /**
  * kustomize block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#kustomize PlatformGitopsApplicationset#kustomize}
  */
  readonly kustomize?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomize;
  /**
  * plugin block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#plugin PlatformGitopsApplicationset#plugin}
  */
  readonly plugin?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePlugin;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chart: cdktf.stringToTerraform(struct!.chart),
    path: cdktf.stringToTerraform(struct!.path),
    ref: cdktf.stringToTerraform(struct!.ref),
    repo_url: cdktf.stringToTerraform(struct!.repoUrl),
    target_revision: cdktf.stringToTerraform(struct!.targetRevision),
    directory: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectoryToTerraform(struct!.directory),
    helm: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelmToTerraform(struct!.helm),
    kustomize: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeToTerraform(struct!.kustomize),
    plugin: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginToTerraform(struct!.plugin),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chart: {
      value: cdktf.stringToHclTerraform(struct!.chart),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: cdktf.stringToHclTerraform(struct!.ref),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repo_url: {
      value: cdktf.stringToHclTerraform(struct!.repoUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_revision: {
      value: cdktf.stringToHclTerraform(struct!.targetRevision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    directory: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectoryToHclTerraform(struct!.directory),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectoryList",
    },
    helm: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelmToHclTerraform(struct!.helm),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelmList",
    },
    kustomize: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeToHclTerraform(struct!.kustomize),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeList",
    },
    plugin: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginToHclTerraform(struct!.plugin),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chart !== undefined) {
      hasAnyValues = true;
      internalValueResult.chart = this._chart;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ref !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref;
    }
    if (this._repoUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.repoUrl = this._repoUrl;
    }
    if (this._targetRevision !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRevision = this._targetRevision;
    }
    if (this._directory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.directory = this._directory?.internalValue;
    }
    if (this._helm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.helm = this._helm?.internalValue;
    }
    if (this._kustomize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kustomize = this._kustomize?.internalValue;
    }
    if (this._plugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chart = undefined;
      this._path = undefined;
      this._ref = undefined;
      this._repoUrl = undefined;
      this._targetRevision = undefined;
      this._directory.internalValue = undefined;
      this._helm.internalValue = undefined;
      this._kustomize.internalValue = undefined;
      this._plugin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chart = value.chart;
      this._path = value.path;
      this._ref = value.ref;
      this._repoUrl = value.repoUrl;
      this._targetRevision = value.targetRevision;
      this._directory.internalValue = value.directory;
      this._helm.internalValue = value.helm;
      this._kustomize.internalValue = value.kustomize;
      this._plugin.internalValue = value.plugin;
    }
  }

  // chart - computed: false, optional: true, required: false
  private _chart?: string; 
  public get chart() {
    return this.getStringAttribute('chart');
  }
  public set chart(value: string) {
    this._chart = value;
  }
  public resetChart() {
    this._chart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chartInput() {
    return this._chart;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ref - computed: false, optional: true, required: false
  private _ref?: string; 
  public get ref() {
    return this.getStringAttribute('ref');
  }
  public set ref(value: string) {
    this._ref = value;
  }
  public resetRef() {
    this._ref = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref;
  }

  // repo_url - computed: false, optional: true, required: false
  private _repoUrl?: string; 
  public get repoUrl() {
    return this.getStringAttribute('repo_url');
  }
  public set repoUrl(value: string) {
    this._repoUrl = value;
  }
  public resetRepoUrl() {
    this._repoUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repoUrlInput() {
    return this._repoUrl;
  }

  // target_revision - computed: false, optional: true, required: false
  private _targetRevision?: string; 
  public get targetRevision() {
    return this.getStringAttribute('target_revision');
  }
  public set targetRevision(value: string) {
    this._targetRevision = value;
  }
  public resetTargetRevision() {
    this._targetRevision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRevisionInput() {
    return this._targetRevision;
  }

  // directory - computed: false, optional: true, required: false
  private _directory = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectoryOutputReference(this, "directory");
  public get directory() {
    return this._directory;
  }
  public putDirectory(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceDirectory) {
    this._directory.internalValue = value;
  }
  public resetDirectory() {
    this._directory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directoryInput() {
    return this._directory.internalValue;
  }

  // helm - computed: false, optional: true, required: false
  private _helm = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelmOutputReference(this, "helm");
  public get helm() {
    return this._helm;
  }
  public putHelm(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceHelm) {
    this._helm.internalValue = value;
  }
  public resetHelm() {
    this._helm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helmInput() {
    return this._helm.internalValue;
  }

  // kustomize - computed: false, optional: true, required: false
  private _kustomize = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomizeOutputReference(this, "kustomize");
  public get kustomize() {
    return this._kustomize;
  }
  public putKustomize(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceKustomize) {
    this._kustomize.internalValue = value;
  }
  public resetKustomize() {
    this._kustomize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kustomizeInput() {
    return this._kustomize.internalValue;
  }

  // plugin - computed: false, optional: true, required: false
  private _plugin = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePluginOutputReference(this, "plugin");
  public get plugin() {
    return this._plugin;
  }
  public putPlugin(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcePlugin) {
    this._plugin.internalValue = value;
  }
  public resetPlugin() {
    this._plugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSource[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVar {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlas {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnet {
  /**
  * Additional library search dirs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#libs PlatformGitopsApplicationset#libs}
  */
  readonly libs?: string[];
  /**
  * ext_var block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ext_var PlatformGitopsApplicationset#ext_var}
  */
  readonly extVar?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable;
  /**
  * tlas block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#tlas PlatformGitopsApplicationset#tlas}
  */
  readonly tlas?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    libs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.libs),
    ext_var: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarToTerraform, true)(struct!.extVar),
    tlas: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasToTerraform, true)(struct!.tlas),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    libs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.libs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ext_var: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarToHclTerraform, true)(struct!.extVar),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarList",
    },
    tlas: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasToHclTerraform, true)(struct!.tlas),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._libs !== undefined) {
      hasAnyValues = true;
      internalValueResult.libs = this._libs;
    }
    if (this._extVar?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extVar = this._extVar?.internalValue;
    }
    if (this._tlas?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlas = this._tlas?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._libs = undefined;
      this._extVar.internalValue = undefined;
      this._tlas.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._libs = value.libs;
      this._extVar.internalValue = value.extVar;
      this._tlas.internalValue = value.tlas;
    }
  }

  // libs - computed: false, optional: true, required: false
  private _libs?: string[]; 
  public get libs() {
    return this.getListAttribute('libs');
  }
  public set libs(value: string[]) {
    this._libs = value;
  }
  public resetLibs() {
    this._libs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get libsInput() {
    return this._libs;
  }

  // ext_var - computed: false, optional: true, required: false
  private _extVar = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVarList(this, "ext_var", false);
  public get extVar() {
    return this._extVar;
  }
  public putExtVar(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable) {
    this._extVar.internalValue = value;
  }
  public resetExtVar() {
    this._extVar.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extVarInput() {
    return this._extVar.internalValue;
  }

  // tlas - computed: false, optional: true, required: false
  private _tlas = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlasList(this, "tlas", false);
  public get tlas() {
    return this._tlas;
  }
  public putTlas(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable) {
    this._tlas.internalValue = value;
  }
  public resetTlas() {
    this._tlas.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlasInput() {
    return this._tlas.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectory {
  /**
  * Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation. This takes precedence over the `include` field. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{config.yaml,env-use2/*}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#exclude PlatformGitopsApplicationset#exclude}
  */
  readonly exclude?: string;
  /**
  * Glob pattern to match paths against that should be explicitly included during manifest generation. If this field is set, only matching manifests will be included. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{*.yml,*.yaml}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#include PlatformGitopsApplicationset#include}
  */
  readonly include?: string;
  /**
  * Whether to scan a directory recursively for manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#recurse PlatformGitopsApplicationset#recurse}
  */
  readonly recurse?: boolean | cdktf.IResolvable;
  /**
  * jsonnet block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#jsonnet PlatformGitopsApplicationset#jsonnet}
  */
  readonly jsonnet?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnet;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exclude: cdktf.stringToTerraform(struct!.exclude),
    include: cdktf.stringToTerraform(struct!.include),
    recurse: cdktf.booleanToTerraform(struct!.recurse),
    jsonnet: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetToTerraform(struct!.jsonnet),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exclude: {
      value: cdktf.stringToHclTerraform(struct!.exclude),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include: {
      value: cdktf.stringToHclTerraform(struct!.include),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    recurse: {
      value: cdktf.booleanToHclTerraform(struct!.recurse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    jsonnet: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetToHclTerraform(struct!.jsonnet),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectory | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exclude !== undefined) {
      hasAnyValues = true;
      internalValueResult.exclude = this._exclude;
    }
    if (this._include !== undefined) {
      hasAnyValues = true;
      internalValueResult.include = this._include;
    }
    if (this._recurse !== undefined) {
      hasAnyValues = true;
      internalValueResult.recurse = this._recurse;
    }
    if (this._jsonnet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonnet = this._jsonnet?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectory | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._exclude = undefined;
      this._include = undefined;
      this._recurse = undefined;
      this._jsonnet.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._exclude = value.exclude;
      this._include = value.include;
      this._recurse = value.recurse;
      this._jsonnet.internalValue = value.jsonnet;
    }
  }

  // exclude - computed: false, optional: true, required: false
  private _exclude?: string; 
  public get exclude() {
    return this.getStringAttribute('exclude');
  }
  public set exclude(value: string) {
    this._exclude = value;
  }
  public resetExclude() {
    this._exclude = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeInput() {
    return this._exclude;
  }

  // include - computed: false, optional: true, required: false
  private _include?: string; 
  public get include() {
    return this.getStringAttribute('include');
  }
  public set include(value: string) {
    this._include = value;
  }
  public resetInclude() {
    this._include = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeInput() {
    return this._include;
  }

  // recurse - computed: false, optional: true, required: false
  private _recurse?: boolean | cdktf.IResolvable; 
  public get recurse() {
    return this.getBooleanAttribute('recurse');
  }
  public set recurse(value: boolean | cdktf.IResolvable) {
    this._recurse = value;
  }
  public resetRecurse() {
    this._recurse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recurseInput() {
    return this._recurse;
  }

  // jsonnet - computed: false, optional: true, required: false
  private _jsonnet = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnetOutputReference(this, "jsonnet");
  public get jsonnet() {
    return this._jsonnet;
  }
  public putJsonnet(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryJsonnet) {
    this._jsonnet.internalValue = value;
  }
  public resetJsonnet() {
    this._jsonnet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonnetInput() {
    return this._jsonnet.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParameters {
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name: string;
  /**
  * Path to the file containing the values for the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParameters {
  /**
  * Determines whether to tell Helm to interpret booleans and numbers as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_string PlatformGitopsApplicationset#force_string}
  */
  readonly forceString?: boolean | cdktf.IResolvable;
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    force_string: cdktf.booleanToTerraform(struct!.forceString),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    force_string: {
      value: cdktf.booleanToHclTerraform(struct!.forceString),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._forceString !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceString = this._forceString;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._forceString = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._forceString = value.forceString;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // force_string - computed: false, optional: true, required: false
  private _forceString?: boolean | cdktf.IResolvable; 
  public get forceString() {
    return this.getBooleanAttribute('force_string');
  }
  public set forceString(value: boolean | cdktf.IResolvable) {
    this._forceString = value;
  }
  public resetForceString() {
    this._forceString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceStringInput() {
    return this._forceString;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelm {
  /**
  * Prevents 'helm template' from failing when `value_files` do not exist locally by not appending them to 'helm template --values'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_missing_value_files PlatformGitopsApplicationset#ignore_missing_value_files}
  */
  readonly ignoreMissingValueFiles?: boolean | cdktf.IResolvable;
  /**
  * If true then adds '--pass-credentials' to Helm commands to pass credentials to all domains.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#pass_credentials PlatformGitopsApplicationset#pass_credentials}
  */
  readonly passCredentials?: boolean | cdktf.IResolvable;
  /**
  * Helm release name. If omitted it will use the application name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#release_name PlatformGitopsApplicationset#release_name}
  */
  readonly releaseName?: string;
  /**
  * Whether to skip custom resource definition installation step (Helm's [--skip-crds](https://helm.sh/docs/chart_best_practices/custom_resource_definitions/)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_crds PlatformGitopsApplicationset#skip_crds}
  */
  readonly skipCrds?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip schema validation during helm template. Corresponds to helm --skip-schema-validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_schema_validation PlatformGitopsApplicationset#skip_schema_validation}
  */
  readonly skipSchemaValidation?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip tests during helm template. Corresponds to helm --skip-tests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_tests PlatformGitopsApplicationset#skip_tests}
  */
  readonly skipTests?: boolean | cdktf.IResolvable;
  /**
  * List of Helm value files to use when generating a template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value_files PlatformGitopsApplicationset#value_files}
  */
  readonly valueFiles?: string[];
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values PlatformGitopsApplicationset#values}
  */
  readonly values?: string;
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values_object PlatformGitopsApplicationset#values_object}
  */
  readonly valuesObject?: { [key: string]: string };
  /**
  * Helm version to use for templating (either "2" or "3").
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
  /**
  * file_parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#file_parameters PlatformGitopsApplicationset#file_parameters}
  */
  readonly fileParameters?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable;
  /**
  * parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#parameters PlatformGitopsApplicationset#parameters}
  */
  readonly parameters?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_missing_value_files: cdktf.booleanToTerraform(struct!.ignoreMissingValueFiles),
    pass_credentials: cdktf.booleanToTerraform(struct!.passCredentials),
    release_name: cdktf.stringToTerraform(struct!.releaseName),
    skip_crds: cdktf.booleanToTerraform(struct!.skipCrds),
    skip_schema_validation: cdktf.booleanToTerraform(struct!.skipSchemaValidation),
    skip_tests: cdktf.booleanToTerraform(struct!.skipTests),
    value_files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.valueFiles),
    values: cdktf.stringToTerraform(struct!.values),
    values_object: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.valuesObject),
    version: cdktf.stringToTerraform(struct!.version),
    file_parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersToTerraform, true)(struct!.fileParameters),
    parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersToTerraform, true)(struct!.parameters),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_missing_value_files: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreMissingValueFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pass_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.passCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    release_name: {
      value: cdktf.stringToHclTerraform(struct!.releaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_crds: {
      value: cdktf.booleanToHclTerraform(struct!.skipCrds),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_schema_validation: {
      value: cdktf.booleanToHclTerraform(struct!.skipSchemaValidation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_tests: {
      value: cdktf.booleanToHclTerraform(struct!.skipTests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value_files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.valueFiles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    values: {
      value: cdktf.stringToHclTerraform(struct!.values),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values_object: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.valuesObject),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersToHclTerraform, true)(struct!.fileParameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersList",
    },
    parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersToHclTerraform, true)(struct!.parameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelm | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreMissingValueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreMissingValueFiles = this._ignoreMissingValueFiles;
    }
    if (this._passCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.passCredentials = this._passCredentials;
    }
    if (this._releaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.releaseName = this._releaseName;
    }
    if (this._skipCrds !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCrds = this._skipCrds;
    }
    if (this._skipSchemaValidation !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipSchemaValidation = this._skipSchemaValidation;
    }
    if (this._skipTests !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipTests = this._skipTests;
    }
    if (this._valueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFiles = this._valueFiles;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    if (this._valuesObject !== undefined) {
      hasAnyValues = true;
      internalValueResult.valuesObject = this._valuesObject;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._fileParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileParameters = this._fileParameters?.internalValue;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelm | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._ignoreMissingValueFiles = undefined;
      this._passCredentials = undefined;
      this._releaseName = undefined;
      this._skipCrds = undefined;
      this._skipSchemaValidation = undefined;
      this._skipTests = undefined;
      this._valueFiles = undefined;
      this._values = undefined;
      this._valuesObject = undefined;
      this._version = undefined;
      this._fileParameters.internalValue = undefined;
      this._parameters.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._ignoreMissingValueFiles = value.ignoreMissingValueFiles;
      this._passCredentials = value.passCredentials;
      this._releaseName = value.releaseName;
      this._skipCrds = value.skipCrds;
      this._skipSchemaValidation = value.skipSchemaValidation;
      this._skipTests = value.skipTests;
      this._valueFiles = value.valueFiles;
      this._values = value.values;
      this._valuesObject = value.valuesObject;
      this._version = value.version;
      this._fileParameters.internalValue = value.fileParameters;
      this._parameters.internalValue = value.parameters;
    }
  }

  // ignore_missing_value_files - computed: false, optional: true, required: false
  private _ignoreMissingValueFiles?: boolean | cdktf.IResolvable; 
  public get ignoreMissingValueFiles() {
    return this.getBooleanAttribute('ignore_missing_value_files');
  }
  public set ignoreMissingValueFiles(value: boolean | cdktf.IResolvable) {
    this._ignoreMissingValueFiles = value;
  }
  public resetIgnoreMissingValueFiles() {
    this._ignoreMissingValueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreMissingValueFilesInput() {
    return this._ignoreMissingValueFiles;
  }

  // pass_credentials - computed: false, optional: true, required: false
  private _passCredentials?: boolean | cdktf.IResolvable; 
  public get passCredentials() {
    return this.getBooleanAttribute('pass_credentials');
  }
  public set passCredentials(value: boolean | cdktf.IResolvable) {
    this._passCredentials = value;
  }
  public resetPassCredentials() {
    this._passCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passCredentialsInput() {
    return this._passCredentials;
  }

  // release_name - computed: false, optional: true, required: false
  private _releaseName?: string; 
  public get releaseName() {
    return this.getStringAttribute('release_name');
  }
  public set releaseName(value: string) {
    this._releaseName = value;
  }
  public resetReleaseName() {
    this._releaseName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get releaseNameInput() {
    return this._releaseName;
  }

  // skip_crds - computed: false, optional: true, required: false
  private _skipCrds?: boolean | cdktf.IResolvable; 
  public get skipCrds() {
    return this.getBooleanAttribute('skip_crds');
  }
  public set skipCrds(value: boolean | cdktf.IResolvable) {
    this._skipCrds = value;
  }
  public resetSkipCrds() {
    this._skipCrds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCrdsInput() {
    return this._skipCrds;
  }

  // skip_schema_validation - computed: false, optional: true, required: false
  private _skipSchemaValidation?: boolean | cdktf.IResolvable; 
  public get skipSchemaValidation() {
    return this.getBooleanAttribute('skip_schema_validation');
  }
  public set skipSchemaValidation(value: boolean | cdktf.IResolvable) {
    this._skipSchemaValidation = value;
  }
  public resetSkipSchemaValidation() {
    this._skipSchemaValidation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipSchemaValidationInput() {
    return this._skipSchemaValidation;
  }

  // skip_tests - computed: false, optional: true, required: false
  private _skipTests?: boolean | cdktf.IResolvable; 
  public get skipTests() {
    return this.getBooleanAttribute('skip_tests');
  }
  public set skipTests(value: boolean | cdktf.IResolvable) {
    this._skipTests = value;
  }
  public resetSkipTests() {
    this._skipTests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipTestsInput() {
    return this._skipTests;
  }

  // value_files - computed: false, optional: true, required: false
  private _valueFiles?: string[]; 
  public get valueFiles() {
    return this.getListAttribute('value_files');
  }
  public set valueFiles(value: string[]) {
    this._valueFiles = value;
  }
  public resetValueFiles() {
    this._valueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFilesInput() {
    return this._valueFiles;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string; 
  public get values() {
    return this.getStringAttribute('values');
  }
  public set values(value: string) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }

  // values_object - computed: false, optional: true, required: false
  private _valuesObject?: { [key: string]: string }; 
  public get valuesObject() {
    return this.getStringMapAttribute('values_object');
  }
  public set valuesObject(value: { [key: string]: string }) {
    this._valuesObject = value;
  }
  public resetValuesObject() {
    this._valuesObject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesObjectInput() {
    return this._valuesObject;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // file_parameters - computed: false, optional: true, required: false
  private _fileParameters = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParametersList(this, "file_parameters", false);
  public get fileParameters() {
    return this._fileParameters;
  }
  public putFileParameters(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable) {
    this._fileParameters.internalValue = value;
  }
  public resetFileParameters() {
    this._fileParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileParametersInput() {
    return this._fileParameters.internalValue;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParametersList(this, "parameters", false);
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomize {
  /**
  * List of additional annotations to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_annotations PlatformGitopsApplicationset#common_annotations}
  */
  readonly commonAnnotations?: { [key: string]: string };
  /**
  * List of additional labels to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_labels PlatformGitopsApplicationset#common_labels}
  */
  readonly commonLabels?: { [key: string]: string };
  /**
  * Indicates if to force applying common annotations to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_annotations PlatformGitopsApplicationset#force_common_annotations}
  */
  readonly forceCommonAnnotations?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to force apply common labels to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_labels PlatformGitopsApplicationset#force_common_labels}
  */
  readonly forceCommonLabels?: boolean | cdktf.IResolvable;
  /**
  * List of Kustomize image override specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#images PlatformGitopsApplicationset#images}
  */
  readonly images?: string[];
  /**
  * Prefix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_prefix PlatformGitopsApplicationset#name_prefix}
  */
  readonly namePrefix?: string;
  /**
  * Suffix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_suffix PlatformGitopsApplicationset#name_suffix}
  */
  readonly nameSuffix?: string;
  /**
  * Version of Kustomize to use for rendering manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    common_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonAnnotations),
    common_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonLabels),
    force_common_annotations: cdktf.booleanToTerraform(struct!.forceCommonAnnotations),
    force_common_labels: cdktf.booleanToTerraform(struct!.forceCommonLabels),
    images: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.images),
    name_prefix: cdktf.stringToTerraform(struct!.namePrefix),
    name_suffix: cdktf.stringToTerraform(struct!.nameSuffix),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    common_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    common_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    force_common_annotations: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    force_common_labels: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    images: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.images),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name_prefix: {
      value: cdktf.stringToHclTerraform(struct!.namePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.nameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomize | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonAnnotations = this._commonAnnotations;
    }
    if (this._commonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonLabels = this._commonLabels;
    }
    if (this._forceCommonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonAnnotations = this._forceCommonAnnotations;
    }
    if (this._forceCommonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonLabels = this._forceCommonLabels;
    }
    if (this._images !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images;
    }
    if (this._namePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.namePrefix = this._namePrefix;
    }
    if (this._nameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameSuffix = this._nameSuffix;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomize | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._commonAnnotations = undefined;
      this._commonLabels = undefined;
      this._forceCommonAnnotations = undefined;
      this._forceCommonLabels = undefined;
      this._images = undefined;
      this._namePrefix = undefined;
      this._nameSuffix = undefined;
      this._version = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._commonAnnotations = value.commonAnnotations;
      this._commonLabels = value.commonLabels;
      this._forceCommonAnnotations = value.forceCommonAnnotations;
      this._forceCommonLabels = value.forceCommonLabels;
      this._images = value.images;
      this._namePrefix = value.namePrefix;
      this._nameSuffix = value.nameSuffix;
      this._version = value.version;
    }
  }

  // common_annotations - computed: false, optional: true, required: false
  private _commonAnnotations?: { [key: string]: string }; 
  public get commonAnnotations() {
    return this.getStringMapAttribute('common_annotations');
  }
  public set commonAnnotations(value: { [key: string]: string }) {
    this._commonAnnotations = value;
  }
  public resetCommonAnnotations() {
    this._commonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonAnnotationsInput() {
    return this._commonAnnotations;
  }

  // common_labels - computed: false, optional: true, required: false
  private _commonLabels?: { [key: string]: string }; 
  public get commonLabels() {
    return this.getStringMapAttribute('common_labels');
  }
  public set commonLabels(value: { [key: string]: string }) {
    this._commonLabels = value;
  }
  public resetCommonLabels() {
    this._commonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonLabelsInput() {
    return this._commonLabels;
  }

  // force_common_annotations - computed: false, optional: true, required: false
  private _forceCommonAnnotations?: boolean | cdktf.IResolvable; 
  public get forceCommonAnnotations() {
    return this.getBooleanAttribute('force_common_annotations');
  }
  public set forceCommonAnnotations(value: boolean | cdktf.IResolvable) {
    this._forceCommonAnnotations = value;
  }
  public resetForceCommonAnnotations() {
    this._forceCommonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonAnnotationsInput() {
    return this._forceCommonAnnotations;
  }

  // force_common_labels - computed: false, optional: true, required: false
  private _forceCommonLabels?: boolean | cdktf.IResolvable; 
  public get forceCommonLabels() {
    return this.getBooleanAttribute('force_common_labels');
  }
  public set forceCommonLabels(value: boolean | cdktf.IResolvable) {
    this._forceCommonLabels = value;
  }
  public resetForceCommonLabels() {
    this._forceCommonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonLabelsInput() {
    return this._forceCommonLabels;
  }

  // images - computed: false, optional: true, required: false
  private _images?: string[]; 
  public get images() {
    return this.getListAttribute('images');
  }
  public set images(value: string[]) {
    this._images = value;
  }
  public resetImages() {
    this._images = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images;
  }

  // name_prefix - computed: false, optional: true, required: false
  private _namePrefix?: string; 
  public get namePrefix() {
    return this.getStringAttribute('name_prefix');
  }
  public set namePrefix(value: string) {
    this._namePrefix = value;
  }
  public resetNamePrefix() {
    this._namePrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namePrefixInput() {
    return this._namePrefix;
  }

  // name_suffix - computed: false, optional: true, required: false
  private _nameSuffix?: string; 
  public get nameSuffix() {
    return this.getStringAttribute('name_suffix');
  }
  public set nameSuffix(value: string) {
    this._nameSuffix = value;
  }
  public resetNameSuffix() {
    this._nameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameSuffixInput() {
    return this._nameSuffix;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnv {
  /**
  * Name of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPlugin {
  /**
  * Name of the plugin. Only set the plugin name if the plugin is defined in `argocd-cm`. If the plugin is defined as a sidecar, omit the name. The plugin will be automatically matched with the Application according to the plugin's discovery rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * env block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#env PlatformGitopsApplicationset#env}
  */
  readonly env?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    env: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvToTerraform, true)(struct!.env),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvToHclTerraform, true)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPlugin | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPlugin | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._env.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._env.internalValue = value.env;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // env - computed: false, optional: true, required: false
  private _env = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSources {
  /**
  * Helm chart name. Must be specified for applications sourced from a Helm repo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#chart PlatformGitopsApplicationset#chart}
  */
  readonly chart?: string;
  /**
  * Directory path within the repository. Only valid for applications sourced from Git.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path?: string;
  /**
  * Reference to another `source` within defined sources. See associated documentation on [Helm value files from external Git repository](https://argo-cd.readthedocs.io/en/stable/user-guide/multiple_sources/#helm-value-files-from-external-git-repository) regarding combining `ref` with `path` and/or `chart`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ref PlatformGitopsApplicationset#ref}
  */
  readonly ref?: string;
  /**
  * URL to the repository (Git or Helm) that contains the application manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#repo_url PlatformGitopsApplicationset#repo_url}
  */
  readonly repoUrl?: string;
  /**
  * Revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart's version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#target_revision PlatformGitopsApplicationset#target_revision}
  */
  readonly targetRevision?: string;
  /**
  * directory block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#directory PlatformGitopsApplicationset#directory}
  */
  readonly directory?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectory;
  /**
  * helm block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#helm PlatformGitopsApplicationset#helm}
  */
  readonly helm?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelm;
  /**
  * kustomize block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#kustomize PlatformGitopsApplicationset#kustomize}
  */
  readonly kustomize?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomize;
  /**
  * plugin block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#plugin PlatformGitopsApplicationset#plugin}
  */
  readonly plugin?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPlugin;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chart: cdktf.stringToTerraform(struct!.chart),
    path: cdktf.stringToTerraform(struct!.path),
    ref: cdktf.stringToTerraform(struct!.ref),
    repo_url: cdktf.stringToTerraform(struct!.repoUrl),
    target_revision: cdktf.stringToTerraform(struct!.targetRevision),
    directory: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryToTerraform(struct!.directory),
    helm: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmToTerraform(struct!.helm),
    kustomize: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeToTerraform(struct!.kustomize),
    plugin: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginToTerraform(struct!.plugin),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chart: {
      value: cdktf.stringToHclTerraform(struct!.chart),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: cdktf.stringToHclTerraform(struct!.ref),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repo_url: {
      value: cdktf.stringToHclTerraform(struct!.repoUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_revision: {
      value: cdktf.stringToHclTerraform(struct!.targetRevision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    directory: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryToHclTerraform(struct!.directory),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryList",
    },
    helm: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmToHclTerraform(struct!.helm),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmList",
    },
    kustomize: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeToHclTerraform(struct!.kustomize),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeList",
    },
    plugin: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginToHclTerraform(struct!.plugin),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chart !== undefined) {
      hasAnyValues = true;
      internalValueResult.chart = this._chart;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ref !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref;
    }
    if (this._repoUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.repoUrl = this._repoUrl;
    }
    if (this._targetRevision !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRevision = this._targetRevision;
    }
    if (this._directory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.directory = this._directory?.internalValue;
    }
    if (this._helm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.helm = this._helm?.internalValue;
    }
    if (this._kustomize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kustomize = this._kustomize?.internalValue;
    }
    if (this._plugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chart = undefined;
      this._path = undefined;
      this._ref = undefined;
      this._repoUrl = undefined;
      this._targetRevision = undefined;
      this._directory.internalValue = undefined;
      this._helm.internalValue = undefined;
      this._kustomize.internalValue = undefined;
      this._plugin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chart = value.chart;
      this._path = value.path;
      this._ref = value.ref;
      this._repoUrl = value.repoUrl;
      this._targetRevision = value.targetRevision;
      this._directory.internalValue = value.directory;
      this._helm.internalValue = value.helm;
      this._kustomize.internalValue = value.kustomize;
      this._plugin.internalValue = value.plugin;
    }
  }

  // chart - computed: false, optional: true, required: false
  private _chart?: string; 
  public get chart() {
    return this.getStringAttribute('chart');
  }
  public set chart(value: string) {
    this._chart = value;
  }
  public resetChart() {
    this._chart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chartInput() {
    return this._chart;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ref - computed: false, optional: true, required: false
  private _ref?: string; 
  public get ref() {
    return this.getStringAttribute('ref');
  }
  public set ref(value: string) {
    this._ref = value;
  }
  public resetRef() {
    this._ref = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref;
  }

  // repo_url - computed: false, optional: true, required: false
  private _repoUrl?: string; 
  public get repoUrl() {
    return this.getStringAttribute('repo_url');
  }
  public set repoUrl(value: string) {
    this._repoUrl = value;
  }
  public resetRepoUrl() {
    this._repoUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repoUrlInput() {
    return this._repoUrl;
  }

  // target_revision - computed: false, optional: true, required: false
  private _targetRevision?: string; 
  public get targetRevision() {
    return this.getStringAttribute('target_revision');
  }
  public set targetRevision(value: string) {
    this._targetRevision = value;
  }
  public resetTargetRevision() {
    this._targetRevision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRevisionInput() {
    return this._targetRevision;
  }

  // directory - computed: false, optional: true, required: false
  private _directory = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectoryOutputReference(this, "directory");
  public get directory() {
    return this._directory;
  }
  public putDirectory(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesDirectory) {
    this._directory.internalValue = value;
  }
  public resetDirectory() {
    this._directory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directoryInput() {
    return this._directory.internalValue;
  }

  // helm - computed: false, optional: true, required: false
  private _helm = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelmOutputReference(this, "helm");
  public get helm() {
    return this._helm;
  }
  public putHelm(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesHelm) {
    this._helm.internalValue = value;
  }
  public resetHelm() {
    this._helm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helmInput() {
    return this._helm.internalValue;
  }

  // kustomize - computed: false, optional: true, required: false
  private _kustomize = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomizeOutputReference(this, "kustomize");
  public get kustomize() {
    return this._kustomize;
  }
  public putKustomize(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesKustomize) {
    this._kustomize.internalValue = value;
  }
  public resetKustomize() {
    this._kustomize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kustomizeInput() {
    return this._kustomize.internalValue;
  }

  // plugin - computed: false, optional: true, required: false
  private _plugin = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPluginOutputReference(this, "plugin");
  public get plugin() {
    return this._plugin;
  }
  public putPlugin(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesPlugin) {
    this._plugin.internalValue = value;
  }
  public resetPlugin() {
    this._plugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSources[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomated {
  /**
  * Allows apps have zero live resources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#allow_empty PlatformGitopsApplicationset#allow_empty}
  */
  readonly allowEmpty?: boolean | cdktf.IResolvable;
  /**
  * Whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#prune PlatformGitopsApplicationset#prune}
  */
  readonly prune?: boolean | cdktf.IResolvable;
  /**
  * Whether to revert resources back to their desired state upon modification in the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#self_heal PlatformGitopsApplicationset#self_heal}
  */
  readonly selfHeal?: boolean | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomated): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_empty: cdktf.booleanToTerraform(struct!.allowEmpty),
    prune: cdktf.booleanToTerraform(struct!.prune),
    self_heal: cdktf.booleanToTerraform(struct!.selfHeal),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomated): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_empty: {
      value: cdktf.booleanToHclTerraform(struct!.allowEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prune: {
      value: cdktf.booleanToHclTerraform(struct!.prune),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    self_heal: {
      value: cdktf.booleanToHclTerraform(struct!.selfHeal),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomated | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowEmpty = this._allowEmpty;
    }
    if (this._prune !== undefined) {
      hasAnyValues = true;
      internalValueResult.prune = this._prune;
    }
    if (this._selfHeal !== undefined) {
      hasAnyValues = true;
      internalValueResult.selfHeal = this._selfHeal;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomated | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowEmpty = undefined;
      this._prune = undefined;
      this._selfHeal = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowEmpty = value.allowEmpty;
      this._prune = value.prune;
      this._selfHeal = value.selfHeal;
    }
  }

  // allow_empty - computed: false, optional: true, required: false
  private _allowEmpty?: boolean | cdktf.IResolvable; 
  public get allowEmpty() {
    return this.getBooleanAttribute('allow_empty');
  }
  public set allowEmpty(value: boolean | cdktf.IResolvable) {
    this._allowEmpty = value;
  }
  public resetAllowEmpty() {
    this._allowEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowEmptyInput() {
    return this._allowEmpty;
  }

  // prune - computed: false, optional: true, required: false
  private _prune?: boolean | cdktf.IResolvable; 
  public get prune() {
    return this.getBooleanAttribute('prune');
  }
  public set prune(value: boolean | cdktf.IResolvable) {
    this._prune = value;
  }
  public resetPrune() {
    this._prune = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pruneInput() {
    return this._prune;
  }

  // self_heal - computed: false, optional: true, required: false
  private _selfHeal?: boolean | cdktf.IResolvable; 
  public get selfHeal() {
    return this.getBooleanAttribute('self_heal');
  }
  public set selfHeal(value: boolean | cdktf.IResolvable) {
    this._selfHeal = value;
  }
  public resetSelfHeal() {
    this._selfHeal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selfHealInput() {
    return this._selfHeal;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadata {
  /**
  * Annotations to apply to the namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#annotations PlatformGitopsApplicationset#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Labels to apply to the namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#labels PlatformGitopsApplicationset#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadata | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadata | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoff {
  /**
  * Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. `2m`, `1h`), as a string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#duration PlatformGitopsApplicationset#duration}
  */
  readonly duration?: string;
  /**
  * Factor to multiply the base duration after each failed retry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#factor PlatformGitopsApplicationset#factor}
  */
  readonly factor?: string;
  /**
  * Maximum amount of time allowed for the backoff strategy. Default unit is seconds, but could also be a duration (e.g. `2m`, `1h`), as a string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#max_duration PlatformGitopsApplicationset#max_duration}
  */
  readonly maxDuration?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoff): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
    factor: cdktf.stringToTerraform(struct!.factor),
    max_duration: cdktf.stringToTerraform(struct!.maxDuration),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoff): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    factor: {
      value: cdktf.stringToHclTerraform(struct!.factor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoff | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    if (this._factor !== undefined) {
      hasAnyValues = true;
      internalValueResult.factor = this._factor;
    }
    if (this._maxDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDuration = this._maxDuration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoff | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._duration = undefined;
      this._factor = undefined;
      this._maxDuration = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._duration = value.duration;
      this._factor = value.factor;
      this._maxDuration = value.maxDuration;
    }
  }

  // duration - computed: false, optional: true, required: false
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  public resetDuration() {
    this._duration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }

  // factor - computed: false, optional: true, required: false
  private _factor?: string; 
  public get factor() {
    return this.getStringAttribute('factor');
  }
  public set factor(value: string) {
    this._factor = value;
  }
  public resetFactor() {
    this._factor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get factorInput() {
    return this._factor;
  }

  // max_duration - computed: false, optional: true, required: false
  private _maxDuration?: string; 
  public get maxDuration() {
    return this.getStringAttribute('max_duration');
  }
  public set maxDuration(value: string) {
    this._maxDuration = value;
  }
  public resetMaxDuration() {
    this._maxDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDurationInput() {
    return this._maxDuration;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetry {
  /**
  * Maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#limit PlatformGitopsApplicationset#limit}
  */
  readonly limit?: string;
  /**
  * backoff block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#backoff PlatformGitopsApplicationset#backoff}
  */
  readonly backoff?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoff;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetry): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limit: cdktf.stringToTerraform(struct!.limit),
    backoff: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffToTerraform(struct!.backoff),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetry): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limit: {
      value: cdktf.stringToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    backoff: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffToHclTerraform(struct!.backoff),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetry | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._backoff?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoff = this._backoff?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetry | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._limit = undefined;
      this._backoff.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._limit = value.limit;
      this._backoff.internalValue = value.backoff;
    }
  }

  // limit - computed: false, optional: true, required: false
  private _limit?: string; 
  public get limit() {
    return this.getStringAttribute('limit');
  }
  public set limit(value: string) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // backoff - computed: false, optional: true, required: false
  private _backoff = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoffOutputReference(this, "backoff");
  public get backoff() {
    return this._backoff;
  }
  public putBackoff(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryBackoff) {
    this._backoff.internalValue = value;
  }
  public resetBackoff() {
    this._backoff.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffInput() {
    return this._backoff.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicy {
  /**
  * List of sync options. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sync_options PlatformGitopsApplicationset#sync_options}
  */
  readonly syncOptions?: string[];
  /**
  * automated block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#automated PlatformGitopsApplicationset#automated}
  */
  readonly automated?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomated;
  /**
  * managed_namespace_metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#managed_namespace_metadata PlatformGitopsApplicationset#managed_namespace_metadata}
  */
  readonly managedNamespaceMetadata?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadata;
  /**
  * retry block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#retry PlatformGitopsApplicationset#retry}
  */
  readonly retry?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetry;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sync_options: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.syncOptions),
    automated: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedToTerraform(struct!.automated),
    managed_namespace_metadata: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataToTerraform(struct!.managedNamespaceMetadata),
    retry: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryToTerraform(struct!.retry),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sync_options: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.syncOptions),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    automated: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedToHclTerraform(struct!.automated),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedList",
    },
    managed_namespace_metadata: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataToHclTerraform(struct!.managedNamespaceMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataList",
    },
    retry: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryToHclTerraform(struct!.retry),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._syncOptions !== undefined) {
      hasAnyValues = true;
      internalValueResult.syncOptions = this._syncOptions;
    }
    if (this._automated?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.automated = this._automated?.internalValue;
    }
    if (this._managedNamespaceMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.managedNamespaceMetadata = this._managedNamespaceMetadata?.internalValue;
    }
    if (this._retry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retry = this._retry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._syncOptions = undefined;
      this._automated.internalValue = undefined;
      this._managedNamespaceMetadata.internalValue = undefined;
      this._retry.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._syncOptions = value.syncOptions;
      this._automated.internalValue = value.automated;
      this._managedNamespaceMetadata.internalValue = value.managedNamespaceMetadata;
      this._retry.internalValue = value.retry;
    }
  }

  // sync_options - computed: false, optional: true, required: false
  private _syncOptions?: string[]; 
  public get syncOptions() {
    return this.getListAttribute('sync_options');
  }
  public set syncOptions(value: string[]) {
    this._syncOptions = value;
  }
  public resetSyncOptions() {
    this._syncOptions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syncOptionsInput() {
    return this._syncOptions;
  }

  // automated - computed: false, optional: true, required: false
  private _automated = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomatedOutputReference(this, "automated");
  public get automated() {
    return this._automated;
  }
  public putAutomated(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyAutomated) {
    this._automated.internalValue = value;
  }
  public resetAutomated() {
    this._automated.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automatedInput() {
    return this._automated.internalValue;
  }

  // managed_namespace_metadata - computed: false, optional: true, required: false
  private _managedNamespaceMetadata = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference(this, "managed_namespace_metadata");
  public get managedNamespaceMetadata() {
    return this._managedNamespaceMetadata;
  }
  public putManagedNamespaceMetadata(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyManagedNamespaceMetadata) {
    this._managedNamespaceMetadata.internalValue = value;
  }
  public resetManagedNamespaceMetadata() {
    this._managedNamespaceMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedNamespaceMetadataInput() {
    return this._managedNamespaceMetadata.internalValue;
  }

  // retry - computed: false, optional: true, required: false
  private _retry = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetryOutputReference(this, "retry");
  public get retry() {
    return this._retry;
  }
  public putRetry(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyRetry) {
    this._retry.internalValue = value;
  }
  public resetRetry() {
    this._retry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryInput() {
    return this._retry.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpec {
  /**
  * The project the application belongs to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#project PlatformGitopsApplicationset#project}
  */
  readonly project?: string;
  /**
  * Limits the number of items kept in the application's revision history, which is used for informational purposes as well as for rollbacks to previous versions. This should only be changed in exceptional circumstances. Setting to zero will store no history. This will reduce storage used. Increasing will increase the space used to store the history, so we do not recommend increasing it. Default is 10.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#revision_history_limit PlatformGitopsApplicationset#revision_history_limit}
  */
  readonly revisionHistoryLimit?: string;
  /**
  * destination block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#destination PlatformGitopsApplicationset#destination}
  */
  readonly destination?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestination;
  /**
  * ignore_difference block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_difference PlatformGitopsApplicationset#ignore_difference}
  */
  readonly ignoreDifference?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifference[] | cdktf.IResolvable;
  /**
  * info block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#info PlatformGitopsApplicationset#info}
  */
  readonly info?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfo[] | cdktf.IResolvable;
  /**
  * source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#source PlatformGitopsApplicationset#source}
  */
  readonly source?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSource[] | cdktf.IResolvable;
  /**
  * sources block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sources PlatformGitopsApplicationset#sources}
  */
  readonly sources?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSources[] | cdktf.IResolvable;
  /**
  * sync_policy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sync_policy PlatformGitopsApplicationset#sync_policy}
  */
  readonly syncPolicy?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicy;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpec): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    project: cdktf.stringToTerraform(struct!.project),
    revision_history_limit: cdktf.stringToTerraform(struct!.revisionHistoryLimit),
    destination: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestinationToTerraform(struct!.destination),
    ignore_difference: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifferenceToTerraform, true)(struct!.ignoreDifference),
    info: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfoToTerraform, true)(struct!.info),
    source: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceToTerraform, true)(struct!.source),
    sources: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesToTerraform, true)(struct!.sources),
    sync_policy: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyToTerraform(struct!.syncPolicy),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpec): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    revision_history_limit: {
      value: cdktf.stringToHclTerraform(struct!.revisionHistoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    destination: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestinationToHclTerraform(struct!.destination),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestinationList",
    },
    ignore_difference: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifferenceToHclTerraform, true)(struct!.ignoreDifference),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifferenceList",
    },
    info: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfoToHclTerraform, true)(struct!.info),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfoList",
    },
    source: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceToHclTerraform, true)(struct!.source),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceList",
    },
    sources: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesToHclTerraform, true)(struct!.sources),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesList",
    },
    sync_policy: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyToHclTerraform(struct!.syncPolicy),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpec | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    if (this._revisionHistoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.revisionHistoryLimit = this._revisionHistoryLimit;
    }
    if (this._destination?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.destination = this._destination?.internalValue;
    }
    if (this._ignoreDifference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreDifference = this._ignoreDifference?.internalValue;
    }
    if (this._info?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.info = this._info?.internalValue;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._sources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sources = this._sources?.internalValue;
    }
    if (this._syncPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.syncPolicy = this._syncPolicy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpec | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._project = undefined;
      this._revisionHistoryLimit = undefined;
      this._destination.internalValue = undefined;
      this._ignoreDifference.internalValue = undefined;
      this._info.internalValue = undefined;
      this._source.internalValue = undefined;
      this._sources.internalValue = undefined;
      this._syncPolicy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._project = value.project;
      this._revisionHistoryLimit = value.revisionHistoryLimit;
      this._destination.internalValue = value.destination;
      this._ignoreDifference.internalValue = value.ignoreDifference;
      this._info.internalValue = value.info;
      this._source.internalValue = value.source;
      this._sources.internalValue = value.sources;
      this._syncPolicy.internalValue = value.syncPolicy;
    }
  }

  // project - computed: false, optional: true, required: false
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  public resetProject() {
    this._project = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }

  // revision_history_limit - computed: true, optional: true, required: false
  private _revisionHistoryLimit?: string; 
  public get revisionHistoryLimit() {
    return this.getStringAttribute('revision_history_limit');
  }
  public set revisionHistoryLimit(value: string) {
    this._revisionHistoryLimit = value;
  }
  public resetRevisionHistoryLimit() {
    this._revisionHistoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get revisionHistoryLimitInput() {
    return this._revisionHistoryLimit;
  }

  // destination - computed: false, optional: true, required: false
  private _destination = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestinationOutputReference(this, "destination");
  public get destination() {
    return this._destination;
  }
  public putDestination(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecDestination) {
    this._destination.internalValue = value;
  }
  public resetDestination() {
    this._destination.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationInput() {
    return this._destination.internalValue;
  }

  // ignore_difference - computed: false, optional: true, required: false
  private _ignoreDifference = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifferenceList(this, "ignore_difference", false);
  public get ignoreDifference() {
    return this._ignoreDifference;
  }
  public putIgnoreDifference(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecIgnoreDifference[] | cdktf.IResolvable) {
    this._ignoreDifference.internalValue = value;
  }
  public resetIgnoreDifference() {
    this._ignoreDifference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreDifferenceInput() {
    return this._ignoreDifference.internalValue;
  }

  // info - computed: false, optional: true, required: false
  private _info = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfoList(this, "info", false);
  public get info() {
    return this._info;
  }
  public putInfo(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecInfo[] | cdktf.IResolvable) {
    this._info.internalValue = value;
  }
  public resetInfo() {
    this._info.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get infoInput() {
    return this._info.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourceList(this, "source", false);
  public get source() {
    return this._source;
  }
  public putSource(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSource[] | cdktf.IResolvable) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // sources - computed: false, optional: true, required: false
  private _sources = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSourcesList(this, "sources", false);
  public get sources() {
    return this._sources;
  }
  public putSources(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSources[] | cdktf.IResolvable) {
    this._sources.internalValue = value;
  }
  public resetSources() {
    this._sources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcesInput() {
    return this._sources.internalValue;
  }

  // sync_policy - computed: false, optional: true, required: false
  private _syncPolicy = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicyOutputReference(this, "sync_policy");
  public get syncPolicy() {
    return this._syncPolicy;
  }
  public putSyncPolicy(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecSyncPolicy) {
    this._syncPolicy.internalValue = value;
  }
  public resetSyncPolicy() {
    this._syncPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syncPolicyInput() {
    return this._syncPolicy.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplate {
  /**
  * metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#metadata PlatformGitopsApplicationset#metadata}
  */
  readonly metadata?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadata;
  /**
  * spec block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#spec PlatformGitopsApplicationset#spec}
  */
  readonly spec?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpec;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadataToTerraform(struct!.metadata),
    spec: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecToTerraform(struct!.spec),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadataList",
    },
    spec: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplate | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplate | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequest {
  /**
  * How often to check for changes (in seconds). Default: 30min.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#requeue_after_seconds PlatformGitopsApplicationset#requeue_after_seconds}
  */
  readonly requeueAfterSeconds?: string;
  /**
  * bitbucket_server block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#bitbucket_server PlatformGitopsApplicationset#bitbucket_server}
  */
  readonly bitbucketServer?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServer;
  /**
  * filter block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#filter PlatformGitopsApplicationset#filter}
  */
  readonly filter?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilter[] | cdktf.IResolvable;
  /**
  * gitea block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#gitea PlatformGitopsApplicationset#gitea}
  */
  readonly gitea?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitea;
  /**
  * github block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#github PlatformGitopsApplicationset#github}
  */
  readonly github?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithub;
  /**
  * gitlab block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#gitlab PlatformGitopsApplicationset#gitlab}
  */
  readonly gitlab?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlab;
  /**
  * template block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#template PlatformGitopsApplicationset#template}
  */
  readonly template?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplate;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    requeue_after_seconds: cdktf.stringToTerraform(struct!.requeueAfterSeconds),
    bitbucket_server: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServerToTerraform(struct!.bitbucketServer),
    filter: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilterToTerraform, true)(struct!.filter),
    gitea: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGiteaToTerraform(struct!.gitea),
    github: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithubToTerraform(struct!.github),
    gitlab: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlabToTerraform(struct!.gitlab),
    template: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateToTerraform(struct!.template),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    requeue_after_seconds: {
      value: cdktf.stringToHclTerraform(struct!.requeueAfterSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bitbucket_server: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServerToHclTerraform(struct!.bitbucketServer),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServerList",
    },
    filter: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilterToHclTerraform, true)(struct!.filter),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilterList",
    },
    gitea: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGiteaToHclTerraform(struct!.gitea),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGiteaList",
    },
    github: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithubToHclTerraform(struct!.github),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithubList",
    },
    gitlab: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlabToHclTerraform(struct!.gitlab),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlabList",
    },
    template: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requeueAfterSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.requeueAfterSeconds = this._requeueAfterSeconds;
    }
    if (this._bitbucketServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bitbucketServer = this._bitbucketServer?.internalValue;
    }
    if (this._filter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter?.internalValue;
    }
    if (this._gitea?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitea = this._gitea?.internalValue;
    }
    if (this._github?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.github = this._github?.internalValue;
    }
    if (this._gitlab?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitlab = this._gitlab?.internalValue;
    }
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requeueAfterSeconds = undefined;
      this._bitbucketServer.internalValue = undefined;
      this._filter.internalValue = undefined;
      this._gitea.internalValue = undefined;
      this._github.internalValue = undefined;
      this._gitlab.internalValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requeueAfterSeconds = value.requeueAfterSeconds;
      this._bitbucketServer.internalValue = value.bitbucketServer;
      this._filter.internalValue = value.filter;
      this._gitea.internalValue = value.gitea;
      this._github.internalValue = value.github;
      this._gitlab.internalValue = value.gitlab;
      this._template.internalValue = value.template;
    }
  }

  // requeue_after_seconds - computed: false, optional: true, required: false
  private _requeueAfterSeconds?: string; 
  public get requeueAfterSeconds() {
    return this.getStringAttribute('requeue_after_seconds');
  }
  public set requeueAfterSeconds(value: string) {
    this._requeueAfterSeconds = value;
  }
  public resetRequeueAfterSeconds() {
    this._requeueAfterSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requeueAfterSecondsInput() {
    return this._requeueAfterSeconds;
  }

  // bitbucket_server - computed: false, optional: true, required: false
  private _bitbucketServer = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServerOutputReference(this, "bitbucket_server");
  public get bitbucketServer() {
    return this._bitbucketServer;
  }
  public putBitbucketServer(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestBitbucketServer) {
    this._bitbucketServer.internalValue = value;
  }
  public resetBitbucketServer() {
    this._bitbucketServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bitbucketServerInput() {
    return this._bitbucketServer.internalValue;
  }

  // filter - computed: false, optional: true, required: false
  private _filter = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilterList(this, "filter", false);
  public get filter() {
    return this._filter;
  }
  public putFilter(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestFilter[] | cdktf.IResolvable) {
    this._filter.internalValue = value;
  }
  public resetFilter() {
    this._filter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter.internalValue;
  }

  // gitea - computed: false, optional: true, required: false
  private _gitea = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGiteaOutputReference(this, "gitea");
  public get gitea() {
    return this._gitea;
  }
  public putGitea(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitea) {
    this._gitea.internalValue = value;
  }
  public resetGitea() {
    this._gitea.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get giteaInput() {
    return this._gitea.internalValue;
  }

  // github - computed: false, optional: true, required: false
  private _github = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithubOutputReference(this, "github");
  public get github() {
    return this._github;
  }
  public putGithub(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGithub) {
    this._github.internalValue = value;
  }
  public resetGithub() {
    this._github.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get githubInput() {
    return this._github.internalValue;
  }

  // gitlab - computed: false, optional: true, required: false
  private _gitlab = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlabOutputReference(this, "gitlab");
  public get gitlab() {
    return this._gitlab;
  }
  public putGitlab(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestGitlab) {
    this._gitlab.internalValue = value;
  }
  public resetGitlab() {
    this._gitlab.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitlabInput() {
    return this._gitlab.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequest[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRef {
  /**
  * Key containing information in Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#key PlatformGitopsApplicationset#key}
  */
  readonly key: string;
  /**
  * Name of Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#secret_name PlatformGitopsApplicationset#secret_name}
  */
  readonly secretName: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._key = undefined;
      this._secretName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._key = value.key;
      this._secretName = value.secretName;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevops {
  /**
  * Scan all branches instead of just the default branch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#all_branches PlatformGitopsApplicationset#all_branches}
  */
  readonly allBranches?: boolean | cdktf.IResolvable;
  /**
  * The URL to Azure DevOps. Defaults to https://dev.azure.com.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#api PlatformGitopsApplicationset#api}
  */
  readonly api?: string;
  /**
  * Azure Devops organization. E.g. "my-organization".
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#organization PlatformGitopsApplicationset#organization}
  */
  readonly organization: string;
  /**
  * Azure Devops team project. E.g. "my-team".
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#team_project PlatformGitopsApplicationset#team_project}
  */
  readonly teamProject: string;
  /**
  * access_token_ref block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#access_token_ref PlatformGitopsApplicationset#access_token_ref}
  */
  readonly accessTokenRef?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRef;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevops): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_branches: cdktf.booleanToTerraform(struct!.allBranches),
    api: cdktf.stringToTerraform(struct!.api),
    organization: cdktf.stringToTerraform(struct!.organization),
    team_project: cdktf.stringToTerraform(struct!.teamProject),
    access_token_ref: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefToTerraform(struct!.accessTokenRef),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevops): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_branches: {
      value: cdktf.booleanToHclTerraform(struct!.allBranches),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    api: {
      value: cdktf.stringToHclTerraform(struct!.api),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    organization: {
      value: cdktf.stringToHclTerraform(struct!.organization),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    team_project: {
      value: cdktf.stringToHclTerraform(struct!.teamProject),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    access_token_ref: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefToHclTerraform(struct!.accessTokenRef),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevops | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allBranches !== undefined) {
      hasAnyValues = true;
      internalValueResult.allBranches = this._allBranches;
    }
    if (this._api !== undefined) {
      hasAnyValues = true;
      internalValueResult.api = this._api;
    }
    if (this._organization !== undefined) {
      hasAnyValues = true;
      internalValueResult.organization = this._organization;
    }
    if (this._teamProject !== undefined) {
      hasAnyValues = true;
      internalValueResult.teamProject = this._teamProject;
    }
    if (this._accessTokenRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessTokenRef = this._accessTokenRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevops | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allBranches = undefined;
      this._api = undefined;
      this._organization = undefined;
      this._teamProject = undefined;
      this._accessTokenRef.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allBranches = value.allBranches;
      this._api = value.api;
      this._organization = value.organization;
      this._teamProject = value.teamProject;
      this._accessTokenRef.internalValue = value.accessTokenRef;
    }
  }

  // all_branches - computed: false, optional: true, required: false
  private _allBranches?: boolean | cdktf.IResolvable; 
  public get allBranches() {
    return this.getBooleanAttribute('all_branches');
  }
  public set allBranches(value: boolean | cdktf.IResolvable) {
    this._allBranches = value;
  }
  public resetAllBranches() {
    this._allBranches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allBranchesInput() {
    return this._allBranches;
  }

  // api - computed: false, optional: true, required: false
  private _api?: string; 
  public get api() {
    return this.getStringAttribute('api');
  }
  public set api(value: string) {
    this._api = value;
  }
  public resetApi() {
    this._api = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiInput() {
    return this._api;
  }

  // organization - computed: false, optional: false, required: true
  private _organization?: string; 
  public get organization() {
    return this.getStringAttribute('organization');
  }
  public set organization(value: string) {
    this._organization = value;
  }
  // Temporarily expose input value. Use with caution.
  public get organizationInput() {
    return this._organization;
  }

  // team_project - computed: false, optional: false, required: true
  private _teamProject?: string; 
  public get teamProject() {
    return this.getStringAttribute('team_project');
  }
  public set teamProject(value: string) {
    this._teamProject = value;
  }
  // Temporarily expose input value. Use with caution.
  public get teamProjectInput() {
    return this._teamProject;
  }

  // access_token_ref - computed: false, optional: true, required: false
  private _accessTokenRef = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRefOutputReference(this, "access_token_ref");
  public get accessTokenRef() {
    return this._accessTokenRef;
  }
  public putAccessTokenRef(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsAccessTokenRef) {
    this._accessTokenRef.internalValue = value;
  }
  public resetAccessTokenRef() {
    this._accessTokenRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenRefInput() {
    return this._accessTokenRef.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRef {
  /**
  * Key containing information in Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#key PlatformGitopsApplicationset#key}
  */
  readonly key: string;
  /**
  * Name of Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#secret_name PlatformGitopsApplicationset#secret_name}
  */
  readonly secretName: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._key = undefined;
      this._secretName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._key = value.key;
      this._secretName = value.secretName;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloud {
  /**
  * Scan all branches instead of just the default branch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#all_branches PlatformGitopsApplicationset#all_branches}
  */
  readonly allBranches?: boolean | cdktf.IResolvable;
  /**
  * Bitbucket workspace to scan.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#owner PlatformGitopsApplicationset#owner}
  */
  readonly owner: string;
  /**
  * Bitbucket user to use when authenticating. Should have a "member" role to be able to read all repositories and branches.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#user PlatformGitopsApplicationset#user}
  */
  readonly user: string;
  /**
  * app_password_ref block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#app_password_ref PlatformGitopsApplicationset#app_password_ref}
  */
  readonly appPasswordRef?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRef;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloud): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_branches: cdktf.booleanToTerraform(struct!.allBranches),
    owner: cdktf.stringToTerraform(struct!.owner),
    user: cdktf.stringToTerraform(struct!.user),
    app_password_ref: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefToTerraform(struct!.appPasswordRef),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloud): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_branches: {
      value: cdktf.booleanToHclTerraform(struct!.allBranches),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    owner: {
      value: cdktf.stringToHclTerraform(struct!.owner),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    app_password_ref: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefToHclTerraform(struct!.appPasswordRef),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloud | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allBranches !== undefined) {
      hasAnyValues = true;
      internalValueResult.allBranches = this._allBranches;
    }
    if (this._owner !== undefined) {
      hasAnyValues = true;
      internalValueResult.owner = this._owner;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    if (this._appPasswordRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appPasswordRef = this._appPasswordRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloud | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allBranches = undefined;
      this._owner = undefined;
      this._user = undefined;
      this._appPasswordRef.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allBranches = value.allBranches;
      this._owner = value.owner;
      this._user = value.user;
      this._appPasswordRef.internalValue = value.appPasswordRef;
    }
  }

  // all_branches - computed: false, optional: true, required: false
  private _allBranches?: boolean | cdktf.IResolvable; 
  public get allBranches() {
    return this.getBooleanAttribute('all_branches');
  }
  public set allBranches(value: boolean | cdktf.IResolvable) {
    this._allBranches = value;
  }
  public resetAllBranches() {
    this._allBranches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allBranchesInput() {
    return this._allBranches;
  }

  // owner - computed: false, optional: false, required: true
  private _owner?: string; 
  public get owner() {
    return this.getStringAttribute('owner');
  }
  public set owner(value: string) {
    this._owner = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ownerInput() {
    return this._owner;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }

  // app_password_ref - computed: false, optional: true, required: false
  private _appPasswordRef = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRefOutputReference(this, "app_password_ref");
  public get appPasswordRef() {
    return this._appPasswordRef;
  }
  public putAppPasswordRef(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudAppPasswordRef) {
    this._appPasswordRef.internalValue = value;
  }
  public resetAppPasswordRef() {
    this._appPasswordRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appPasswordRefInput() {
    return this._appPasswordRef.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRef {
  /**
  * Key containing information in Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#key PlatformGitopsApplicationset#key}
  */
  readonly key: string;
  /**
  * Name of Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#secret_name PlatformGitopsApplicationset#secret_name}
  */
  readonly secretName: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._key = undefined;
      this._secretName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._key = value.key;
      this._secretName = value.secretName;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuth {
  /**
  * Username for Basic auth.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#username PlatformGitopsApplicationset#username}
  */
  readonly username?: string;
  /**
  * password_ref block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#password_ref PlatformGitopsApplicationset#password_ref}
  */
  readonly passwordRef?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRef;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    username: cdktf.stringToTerraform(struct!.username),
    password_ref: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefToTerraform(struct!.passwordRef),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password_ref: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefToHclTerraform(struct!.passwordRef),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._passwordRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwordRef = this._passwordRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._username = undefined;
      this._passwordRef.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._username = value.username;
      this._passwordRef.internalValue = value.passwordRef;
    }
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // password_ref - computed: false, optional: true, required: false
  private _passwordRef = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRefOutputReference(this, "password_ref");
  public get passwordRef() {
    return this._passwordRef;
  }
  public putPasswordRef(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthPasswordRef) {
    this._passwordRef.internalValue = value;
  }
  public resetPasswordRef() {
    this._passwordRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordRefInput() {
    return this._passwordRef.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServer {
  /**
  * Scan all branches instead of just the default branch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#all_branches PlatformGitopsApplicationset#all_branches}
  */
  readonly allBranches?: boolean | cdktf.IResolvable;
  /**
  * The Bitbucket REST API URL to talk to e.g. https://bitbucket.org/rest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#api PlatformGitopsApplicationset#api}
  */
  readonly api: string;
  /**
  * Project to scan.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#project PlatformGitopsApplicationset#project}
  */
  readonly project: string;
  /**
  * basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#basic_auth PlatformGitopsApplicationset#basic_auth}
  */
  readonly basicAuth?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuth;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_branches: cdktf.booleanToTerraform(struct!.allBranches),
    api: cdktf.stringToTerraform(struct!.api),
    project: cdktf.stringToTerraform(struct!.project),
    basic_auth: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthToTerraform(struct!.basicAuth),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_branches: {
      value: cdktf.booleanToHclTerraform(struct!.allBranches),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    api: {
      value: cdktf.stringToHclTerraform(struct!.api),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    basic_auth: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthToHclTerraform(struct!.basicAuth),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServer | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allBranches !== undefined) {
      hasAnyValues = true;
      internalValueResult.allBranches = this._allBranches;
    }
    if (this._api !== undefined) {
      hasAnyValues = true;
      internalValueResult.api = this._api;
    }
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    if (this._basicAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.basicAuth = this._basicAuth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServer | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allBranches = undefined;
      this._api = undefined;
      this._project = undefined;
      this._basicAuth.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allBranches = value.allBranches;
      this._api = value.api;
      this._project = value.project;
      this._basicAuth.internalValue = value.basicAuth;
    }
  }

  // all_branches - computed: false, optional: true, required: false
  private _allBranches?: boolean | cdktf.IResolvable; 
  public get allBranches() {
    return this.getBooleanAttribute('all_branches');
  }
  public set allBranches(value: boolean | cdktf.IResolvable) {
    this._allBranches = value;
  }
  public resetAllBranches() {
    this._allBranches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allBranchesInput() {
    return this._allBranches;
  }

  // api - computed: false, optional: false, required: true
  private _api?: string; 
  public get api() {
    return this.getStringAttribute('api');
  }
  public set api(value: string) {
    this._api = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiInput() {
    return this._api;
  }

  // project - computed: false, optional: false, required: true
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }

  // basic_auth - computed: false, optional: true, required: false
  private _basicAuth = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuthOutputReference(this, "basic_auth");
  public get basicAuth() {
    return this._basicAuth;
  }
  public putBasicAuth(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerBasicAuth) {
    this._basicAuth.internalValue = value;
  }
  public resetBasicAuth() {
    this._basicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get basicAuthInput() {
    return this._basicAuth.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilter {
  /**
  * A regex which must match the branch name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#branch_match PlatformGitopsApplicationset#branch_match}
  */
  readonly branchMatch?: string;
  /**
  * A regex which must match at least one label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#label_match PlatformGitopsApplicationset#label_match}
  */
  readonly labelMatch?: string;
  /**
  * An array of paths, all of which must not exist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#paths_do_not_exist PlatformGitopsApplicationset#paths_do_not_exist}
  */
  readonly pathsDoNotExist?: string[];
  /**
  * An array of paths, all of which must exist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#paths_exist PlatformGitopsApplicationset#paths_exist}
  */
  readonly pathsExist?: string[];
  /**
  * A regex for repo names.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#repository_match PlatformGitopsApplicationset#repository_match}
  */
  readonly repositoryMatch?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    branch_match: cdktf.stringToTerraform(struct!.branchMatch),
    label_match: cdktf.stringToTerraform(struct!.labelMatch),
    paths_do_not_exist: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.pathsDoNotExist),
    paths_exist: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.pathsExist),
    repository_match: cdktf.stringToTerraform(struct!.repositoryMatch),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    branch_match: {
      value: cdktf.stringToHclTerraform(struct!.branchMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    label_match: {
      value: cdktf.stringToHclTerraform(struct!.labelMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    paths_do_not_exist: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.pathsDoNotExist),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    paths_exist: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.pathsExist),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    repository_match: {
      value: cdktf.stringToHclTerraform(struct!.repositoryMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._branchMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.branchMatch = this._branchMatch;
    }
    if (this._labelMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelMatch = this._labelMatch;
    }
    if (this._pathsDoNotExist !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathsDoNotExist = this._pathsDoNotExist;
    }
    if (this._pathsExist !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathsExist = this._pathsExist;
    }
    if (this._repositoryMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.repositoryMatch = this._repositoryMatch;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._branchMatch = undefined;
      this._labelMatch = undefined;
      this._pathsDoNotExist = undefined;
      this._pathsExist = undefined;
      this._repositoryMatch = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._branchMatch = value.branchMatch;
      this._labelMatch = value.labelMatch;
      this._pathsDoNotExist = value.pathsDoNotExist;
      this._pathsExist = value.pathsExist;
      this._repositoryMatch = value.repositoryMatch;
    }
  }

  // branch_match - computed: false, optional: true, required: false
  private _branchMatch?: string; 
  public get branchMatch() {
    return this.getStringAttribute('branch_match');
  }
  public set branchMatch(value: string) {
    this._branchMatch = value;
  }
  public resetBranchMatch() {
    this._branchMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get branchMatchInput() {
    return this._branchMatch;
  }

  // label_match - computed: false, optional: true, required: false
  private _labelMatch?: string; 
  public get labelMatch() {
    return this.getStringAttribute('label_match');
  }
  public set labelMatch(value: string) {
    this._labelMatch = value;
  }
  public resetLabelMatch() {
    this._labelMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelMatchInput() {
    return this._labelMatch;
  }

  // paths_do_not_exist - computed: false, optional: true, required: false
  private _pathsDoNotExist?: string[]; 
  public get pathsDoNotExist() {
    return this.getListAttribute('paths_do_not_exist');
  }
  public set pathsDoNotExist(value: string[]) {
    this._pathsDoNotExist = value;
  }
  public resetPathsDoNotExist() {
    this._pathsDoNotExist = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathsDoNotExistInput() {
    return this._pathsDoNotExist;
  }

  // paths_exist - computed: false, optional: true, required: false
  private _pathsExist?: string[]; 
  public get pathsExist() {
    return this.getListAttribute('paths_exist');
  }
  public set pathsExist(value: string[]) {
    this._pathsExist = value;
  }
  public resetPathsExist() {
    this._pathsExist = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathsExistInput() {
    return this._pathsExist;
  }

  // repository_match - computed: false, optional: true, required: false
  private _repositoryMatch?: string; 
  public get repositoryMatch() {
    return this.getStringAttribute('repository_match');
  }
  public set repositoryMatch(value: string) {
    this._repositoryMatch = value;
  }
  public resetRepositoryMatch() {
    this._repositoryMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repositoryMatchInput() {
    return this._repositoryMatch;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilter[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRef {
  /**
  * Key containing information in Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#key PlatformGitopsApplicationset#key}
  */
  readonly key: string;
  /**
  * Name of Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#secret_name PlatformGitopsApplicationset#secret_name}
  */
  readonly secretName: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._key = undefined;
      this._secretName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._key = value.key;
      this._secretName = value.secretName;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitea {
  /**
  * Scan all branches instead of just the default branch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#all_branches PlatformGitopsApplicationset#all_branches}
  */
  readonly allBranches?: boolean | cdktf.IResolvable;
  /**
  * The Gitea URL to talk to. For example https://gitea.mydomain.com/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#api PlatformGitopsApplicationset#api}
  */
  readonly api?: string;
  /**
  * Allow self-signed TLS / Certificates.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#insecure PlatformGitopsApplicationset#insecure}
  */
  readonly insecure?: boolean | cdktf.IResolvable;
  /**
  * Gitea organization or user to scan.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#owner PlatformGitopsApplicationset#owner}
  */
  readonly owner: string;
  /**
  * token_ref block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#token_ref PlatformGitopsApplicationset#token_ref}
  */
  readonly tokenRef?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRef;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitea): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_branches: cdktf.booleanToTerraform(struct!.allBranches),
    api: cdktf.stringToTerraform(struct!.api),
    insecure: cdktf.booleanToTerraform(struct!.insecure),
    owner: cdktf.stringToTerraform(struct!.owner),
    token_ref: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefToTerraform(struct!.tokenRef),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitea): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_branches: {
      value: cdktf.booleanToHclTerraform(struct!.allBranches),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    api: {
      value: cdktf.stringToHclTerraform(struct!.api),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure: {
      value: cdktf.booleanToHclTerraform(struct!.insecure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    owner: {
      value: cdktf.stringToHclTerraform(struct!.owner),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_ref: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefToHclTerraform(struct!.tokenRef),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitea | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allBranches !== undefined) {
      hasAnyValues = true;
      internalValueResult.allBranches = this._allBranches;
    }
    if (this._api !== undefined) {
      hasAnyValues = true;
      internalValueResult.api = this._api;
    }
    if (this._insecure !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecure = this._insecure;
    }
    if (this._owner !== undefined) {
      hasAnyValues = true;
      internalValueResult.owner = this._owner;
    }
    if (this._tokenRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenRef = this._tokenRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitea | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allBranches = undefined;
      this._api = undefined;
      this._insecure = undefined;
      this._owner = undefined;
      this._tokenRef.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allBranches = value.allBranches;
      this._api = value.api;
      this._insecure = value.insecure;
      this._owner = value.owner;
      this._tokenRef.internalValue = value.tokenRef;
    }
  }

  // all_branches - computed: false, optional: true, required: false
  private _allBranches?: boolean | cdktf.IResolvable; 
  public get allBranches() {
    return this.getBooleanAttribute('all_branches');
  }
  public set allBranches(value: boolean | cdktf.IResolvable) {
    this._allBranches = value;
  }
  public resetAllBranches() {
    this._allBranches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allBranchesInput() {
    return this._allBranches;
  }

  // api - computed: false, optional: true, required: false
  private _api?: string; 
  public get api() {
    return this.getStringAttribute('api');
  }
  public set api(value: string) {
    this._api = value;
  }
  public resetApi() {
    this._api = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiInput() {
    return this._api;
  }

  // insecure - computed: false, optional: true, required: false
  private _insecure?: boolean | cdktf.IResolvable; 
  public get insecure() {
    return this.getBooleanAttribute('insecure');
  }
  public set insecure(value: boolean | cdktf.IResolvable) {
    this._insecure = value;
  }
  public resetInsecure() {
    this._insecure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureInput() {
    return this._insecure;
  }

  // owner - computed: false, optional: false, required: true
  private _owner?: string; 
  public get owner() {
    return this.getStringAttribute('owner');
  }
  public set owner(value: string) {
    this._owner = value;
  }
  // Temporarily expose input value. Use with caution.
  public get ownerInput() {
    return this._owner;
  }

  // token_ref - computed: false, optional: true, required: false
  private _tokenRef = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRefOutputReference(this, "token_ref");
  public get tokenRef() {
    return this._tokenRef;
  }
  public putTokenRef(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaTokenRef) {
    this._tokenRef.internalValue = value;
  }
  public resetTokenRef() {
    this._tokenRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenRefInput() {
    return this._tokenRef.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRef {
  /**
  * Key containing information in Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#key PlatformGitopsApplicationset#key}
  */
  readonly key: string;
  /**
  * Name of Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#secret_name PlatformGitopsApplicationset#secret_name}
  */
  readonly secretName: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._key = undefined;
      this._secretName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._key = value.key;
      this._secretName = value.secretName;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithub {
  /**
  * If true, scan every branch of every repository. If false, scan only the default branch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#all_branches PlatformGitopsApplicationset#all_branches}
  */
  readonly allBranches?: boolean | cdktf.IResolvable;
  /**
  * The GitHub API URL to talk to. Default https://api.github.com/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#api PlatformGitopsApplicationset#api}
  */
  readonly api?: string;
  /**
  * Reference to a GitHub App repo-creds secret. Uses a GitHub App to access the API instead of a PAT.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#app_secret_name PlatformGitopsApplicationset#app_secret_name}
  */
  readonly appSecretName?: string;
  /**
  * GitHub org to scan.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#organization PlatformGitopsApplicationset#organization}
  */
  readonly organization: string;
  /**
  * token_ref block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#token_ref PlatformGitopsApplicationset#token_ref}
  */
  readonly tokenRef?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRef;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithub): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_branches: cdktf.booleanToTerraform(struct!.allBranches),
    api: cdktf.stringToTerraform(struct!.api),
    app_secret_name: cdktf.stringToTerraform(struct!.appSecretName),
    organization: cdktf.stringToTerraform(struct!.organization),
    token_ref: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefToTerraform(struct!.tokenRef),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithub): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_branches: {
      value: cdktf.booleanToHclTerraform(struct!.allBranches),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    api: {
      value: cdktf.stringToHclTerraform(struct!.api),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    app_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.appSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    organization: {
      value: cdktf.stringToHclTerraform(struct!.organization),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_ref: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefToHclTerraform(struct!.tokenRef),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithub | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allBranches !== undefined) {
      hasAnyValues = true;
      internalValueResult.allBranches = this._allBranches;
    }
    if (this._api !== undefined) {
      hasAnyValues = true;
      internalValueResult.api = this._api;
    }
    if (this._appSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.appSecretName = this._appSecretName;
    }
    if (this._organization !== undefined) {
      hasAnyValues = true;
      internalValueResult.organization = this._organization;
    }
    if (this._tokenRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenRef = this._tokenRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithub | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allBranches = undefined;
      this._api = undefined;
      this._appSecretName = undefined;
      this._organization = undefined;
      this._tokenRef.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allBranches = value.allBranches;
      this._api = value.api;
      this._appSecretName = value.appSecretName;
      this._organization = value.organization;
      this._tokenRef.internalValue = value.tokenRef;
    }
  }

  // all_branches - computed: false, optional: true, required: false
  private _allBranches?: boolean | cdktf.IResolvable; 
  public get allBranches() {
    return this.getBooleanAttribute('all_branches');
  }
  public set allBranches(value: boolean | cdktf.IResolvable) {
    this._allBranches = value;
  }
  public resetAllBranches() {
    this._allBranches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allBranchesInput() {
    return this._allBranches;
  }

  // api - computed: false, optional: true, required: false
  private _api?: string; 
  public get api() {
    return this.getStringAttribute('api');
  }
  public set api(value: string) {
    this._api = value;
  }
  public resetApi() {
    this._api = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiInput() {
    return this._api;
  }

  // app_secret_name - computed: false, optional: true, required: false
  private _appSecretName?: string; 
  public get appSecretName() {
    return this.getStringAttribute('app_secret_name');
  }
  public set appSecretName(value: string) {
    this._appSecretName = value;
  }
  public resetAppSecretName() {
    this._appSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appSecretNameInput() {
    return this._appSecretName;
  }

  // organization - computed: false, optional: false, required: true
  private _organization?: string; 
  public get organization() {
    return this.getStringAttribute('organization');
  }
  public set organization(value: string) {
    this._organization = value;
  }
  // Temporarily expose input value. Use with caution.
  public get organizationInput() {
    return this._organization;
  }

  // token_ref - computed: false, optional: true, required: false
  private _tokenRef = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRefOutputReference(this, "token_ref");
  public get tokenRef() {
    return this._tokenRef;
  }
  public putTokenRef(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubTokenRef) {
    this._tokenRef.internalValue = value;
  }
  public resetTokenRef() {
    this._tokenRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenRefInput() {
    return this._tokenRef.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRef {
  /**
  * Key containing information in Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#key PlatformGitopsApplicationset#key}
  */
  readonly key: string;
  /**
  * Name of Kubernetes `Secret`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#secret_name PlatformGitopsApplicationset#secret_name}
  */
  readonly secretName: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._key = undefined;
      this._secretName = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._key = value.key;
      this._secretName = value.secretName;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlab {
  /**
  * If true, scan every branch of every repository. If false, scan only the default branch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#all_branches PlatformGitopsApplicationset#all_branches}
  */
  readonly allBranches?: boolean | cdktf.IResolvable;
  /**
  * The Gitlab API URL to talk to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#api PlatformGitopsApplicationset#api}
  */
  readonly api?: string;
  /**
  * Gitlab group to scan. You can use either the project id (recommended) or the full namespaced path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#group PlatformGitopsApplicationset#group}
  */
  readonly group: string;
  /**
  * Recurse through subgroups (true) or scan only the base group (false). Defaults to `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#include_subgroups PlatformGitopsApplicationset#include_subgroups}
  */
  readonly includeSubgroups?: boolean | cdktf.IResolvable;
  /**
  * token_ref block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#token_ref PlatformGitopsApplicationset#token_ref}
  */
  readonly tokenRef?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRef;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlab): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_branches: cdktf.booleanToTerraform(struct!.allBranches),
    api: cdktf.stringToTerraform(struct!.api),
    group: cdktf.stringToTerraform(struct!.group),
    include_subgroups: cdktf.booleanToTerraform(struct!.includeSubgroups),
    token_ref: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefToTerraform(struct!.tokenRef),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlab): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_branches: {
      value: cdktf.booleanToHclTerraform(struct!.allBranches),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    api: {
      value: cdktf.stringToHclTerraform(struct!.api),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_subgroups: {
      value: cdktf.booleanToHclTerraform(struct!.includeSubgroups),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    token_ref: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefToHclTerraform(struct!.tokenRef),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlab | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allBranches !== undefined) {
      hasAnyValues = true;
      internalValueResult.allBranches = this._allBranches;
    }
    if (this._api !== undefined) {
      hasAnyValues = true;
      internalValueResult.api = this._api;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._includeSubgroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeSubgroups = this._includeSubgroups;
    }
    if (this._tokenRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenRef = this._tokenRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlab | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allBranches = undefined;
      this._api = undefined;
      this._group = undefined;
      this._includeSubgroups = undefined;
      this._tokenRef.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allBranches = value.allBranches;
      this._api = value.api;
      this._group = value.group;
      this._includeSubgroups = value.includeSubgroups;
      this._tokenRef.internalValue = value.tokenRef;
    }
  }

  // all_branches - computed: false, optional: true, required: false
  private _allBranches?: boolean | cdktf.IResolvable; 
  public get allBranches() {
    return this.getBooleanAttribute('all_branches');
  }
  public set allBranches(value: boolean | cdktf.IResolvable) {
    this._allBranches = value;
  }
  public resetAllBranches() {
    this._allBranches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allBranchesInput() {
    return this._allBranches;
  }

  // api - computed: false, optional: true, required: false
  private _api?: string; 
  public get api() {
    return this.getStringAttribute('api');
  }
  public set api(value: string) {
    this._api = value;
  }
  public resetApi() {
    this._api = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiInput() {
    return this._api;
  }

  // group - computed: false, optional: false, required: true
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // include_subgroups - computed: false, optional: true, required: false
  private _includeSubgroups?: boolean | cdktf.IResolvable; 
  public get includeSubgroups() {
    return this.getBooleanAttribute('include_subgroups');
  }
  public set includeSubgroups(value: boolean | cdktf.IResolvable) {
    this._includeSubgroups = value;
  }
  public resetIncludeSubgroups() {
    this._includeSubgroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeSubgroupsInput() {
    return this._includeSubgroups;
  }

  // token_ref - computed: false, optional: true, required: false
  private _tokenRef = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRefOutputReference(this, "token_ref");
  public get tokenRef() {
    return this._tokenRef;
  }
  public putTokenRef(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabTokenRef) {
    this._tokenRef.internalValue = value;
  }
  public resetTokenRef() {
    this._tokenRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenRefInput() {
    return this._tokenRef.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadata {
  /**
  * An unstructured key value map that may be used to store arbitrary metadata for the resulting Application.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#annotations PlatformGitopsApplicationset#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * List of finalizers to apply to the resulting Application.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#finalizers PlatformGitopsApplicationset#finalizers}
  */
  readonly finalizers?: string[];
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) the resulting Application.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#labels PlatformGitopsApplicationset#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Name of the resulting Application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resulting Application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#namespace PlatformGitopsApplicationset#namespace}
  */
  readonly namespace?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    finalizers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.finalizers),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    finalizers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.finalizers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadata | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._finalizers !== undefined) {
      hasAnyValues = true;
      internalValueResult.finalizers = this._finalizers;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadata | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._annotations = undefined;
      this._finalizers = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._annotations = value.annotations;
      this._finalizers = value.finalizers;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // finalizers - computed: false, optional: true, required: false
  private _finalizers?: string[]; 
  public get finalizers() {
    return this.getListAttribute('finalizers');
  }
  public set finalizers(value: string[]) {
    this._finalizers = value;
  }
  public resetFinalizers() {
    this._finalizers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get finalizersInput() {
    return this._finalizers;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestination {
  /**
  * Name of the target cluster. Can be used instead of `server`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Target namespace for the application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#namespace PlatformGitopsApplicationset#namespace}
  */
  readonly namespace?: string;
  /**
  * URL of the target cluster and must be set to the Kubernetes control plane API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#server PlatformGitopsApplicationset#server}
  */
  readonly server?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestination): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    server: cdktf.stringToTerraform(struct!.server),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestination): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server: {
      value: cdktf.stringToHclTerraform(struct!.server),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestination | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._server !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestination | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._namespace = undefined;
      this._server = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._namespace = value.namespace;
      this._server = value.server;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // server - computed: false, optional: true, required: false
  private _server?: string; 
  public get server() {
    return this.getStringAttribute('server');
  }
  public set server(value: string) {
    this._server = value;
  }
  public resetServer() {
    this._server = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifference {
  /**
  * The Kubernetes resource Group to match for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#group PlatformGitopsApplicationset#group}
  */
  readonly group?: string;
  /**
  * List of JQ path expression strings targeting the field(s) to ignore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#jq_path_expressions PlatformGitopsApplicationset#jq_path_expressions}
  */
  readonly jqPathExpressions?: string[];
  /**
  * List of JSONPaths strings targeting the field(s) to ignore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#json_pointers PlatformGitopsApplicationset#json_pointers}
  */
  readonly jsonPointers?: string[];
  /**
  * The Kubernetes resource Kind to match for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#kind PlatformGitopsApplicationset#kind}
  */
  readonly kind?: string;
  /**
  * The Kubernetes resource Name to match for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * The Kubernetes resource Namespace to match for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#namespace PlatformGitopsApplicationset#namespace}
  */
  readonly namespace?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group: cdktf.stringToTerraform(struct!.group),
    jq_path_expressions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.jqPathExpressions),
    json_pointers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.jsonPointers),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jq_path_expressions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.jqPathExpressions),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    json_pointers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.jsonPointers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._jqPathExpressions !== undefined) {
      hasAnyValues = true;
      internalValueResult.jqPathExpressions = this._jqPathExpressions;
    }
    if (this._jsonPointers !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPointers = this._jsonPointers;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._group = undefined;
      this._jqPathExpressions = undefined;
      this._jsonPointers = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._group = value.group;
      this._jqPathExpressions = value.jqPathExpressions;
      this._jsonPointers = value.jsonPointers;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // jq_path_expressions - computed: false, optional: true, required: false
  private _jqPathExpressions?: string[]; 
  public get jqPathExpressions() {
    return this.getListAttribute('jq_path_expressions');
  }
  public set jqPathExpressions(value: string[]) {
    this._jqPathExpressions = value;
  }
  public resetJqPathExpressions() {
    this._jqPathExpressions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jqPathExpressionsInput() {
    return this._jqPathExpressions;
  }

  // json_pointers - computed: false, optional: true, required: false
  private _jsonPointers?: string[]; 
  public get jsonPointers() {
    return this.getListAttribute('json_pointers');
  }
  public set jsonPointers(value: string[]) {
    this._jsonPointers = value;
  }
  public resetJsonPointers() {
    this._jsonPointers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPointersInput() {
    return this._jsonPointers;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifference[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfo {
  /**
  * Name of the information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVar {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVar | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVar | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVar[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlas {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlas | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlas | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlas[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnet {
  /**
  * Additional library search dirs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#libs PlatformGitopsApplicationset#libs}
  */
  readonly libs?: string[];
  /**
  * ext_var block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ext_var PlatformGitopsApplicationset#ext_var}
  */
  readonly extVar?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVar[] | cdktf.IResolvable;
  /**
  * tlas block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#tlas PlatformGitopsApplicationset#tlas}
  */
  readonly tlas?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlas[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    libs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.libs),
    ext_var: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarToTerraform, true)(struct!.extVar),
    tlas: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasToTerraform, true)(struct!.tlas),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    libs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.libs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ext_var: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarToHclTerraform, true)(struct!.extVar),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarList",
    },
    tlas: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasToHclTerraform, true)(struct!.tlas),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._libs !== undefined) {
      hasAnyValues = true;
      internalValueResult.libs = this._libs;
    }
    if (this._extVar?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extVar = this._extVar?.internalValue;
    }
    if (this._tlas?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlas = this._tlas?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._libs = undefined;
      this._extVar.internalValue = undefined;
      this._tlas.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._libs = value.libs;
      this._extVar.internalValue = value.extVar;
      this._tlas.internalValue = value.tlas;
    }
  }

  // libs - computed: false, optional: true, required: false
  private _libs?: string[]; 
  public get libs() {
    return this.getListAttribute('libs');
  }
  public set libs(value: string[]) {
    this._libs = value;
  }
  public resetLibs() {
    this._libs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get libsInput() {
    return this._libs;
  }

  // ext_var - computed: false, optional: true, required: false
  private _extVar = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVarList(this, "ext_var", false);
  public get extVar() {
    return this._extVar;
  }
  public putExtVar(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetExtVar[] | cdktf.IResolvable) {
    this._extVar.internalValue = value;
  }
  public resetExtVar() {
    this._extVar.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extVarInput() {
    return this._extVar.internalValue;
  }

  // tlas - computed: false, optional: true, required: false
  private _tlas = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlasList(this, "tlas", false);
  public get tlas() {
    return this._tlas;
  }
  public putTlas(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetTlas[] | cdktf.IResolvable) {
    this._tlas.internalValue = value;
  }
  public resetTlas() {
    this._tlas.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlasInput() {
    return this._tlas.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectory {
  /**
  * Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation. This takes precedence over the `include` field. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{config.yaml,env-use2/*}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#exclude PlatformGitopsApplicationset#exclude}
  */
  readonly exclude?: string;
  /**
  * Glob pattern to match paths against that should be explicitly included during manifest generation. If this field is set, only matching manifests will be included. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{*.yml,*.yaml}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#include PlatformGitopsApplicationset#include}
  */
  readonly include?: string;
  /**
  * Whether to scan a directory recursively for manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#recurse PlatformGitopsApplicationset#recurse}
  */
  readonly recurse?: boolean | cdktf.IResolvable;
  /**
  * jsonnet block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#jsonnet PlatformGitopsApplicationset#jsonnet}
  */
  readonly jsonnet?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnet;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exclude: cdktf.stringToTerraform(struct!.exclude),
    include: cdktf.stringToTerraform(struct!.include),
    recurse: cdktf.booleanToTerraform(struct!.recurse),
    jsonnet: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetToTerraform(struct!.jsonnet),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exclude: {
      value: cdktf.stringToHclTerraform(struct!.exclude),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include: {
      value: cdktf.stringToHclTerraform(struct!.include),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    recurse: {
      value: cdktf.booleanToHclTerraform(struct!.recurse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    jsonnet: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetToHclTerraform(struct!.jsonnet),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectory | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exclude !== undefined) {
      hasAnyValues = true;
      internalValueResult.exclude = this._exclude;
    }
    if (this._include !== undefined) {
      hasAnyValues = true;
      internalValueResult.include = this._include;
    }
    if (this._recurse !== undefined) {
      hasAnyValues = true;
      internalValueResult.recurse = this._recurse;
    }
    if (this._jsonnet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonnet = this._jsonnet?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectory | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._exclude = undefined;
      this._include = undefined;
      this._recurse = undefined;
      this._jsonnet.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._exclude = value.exclude;
      this._include = value.include;
      this._recurse = value.recurse;
      this._jsonnet.internalValue = value.jsonnet;
    }
  }

  // exclude - computed: false, optional: true, required: false
  private _exclude?: string; 
  public get exclude() {
    return this.getStringAttribute('exclude');
  }
  public set exclude(value: string) {
    this._exclude = value;
  }
  public resetExclude() {
    this._exclude = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeInput() {
    return this._exclude;
  }

  // include - computed: false, optional: true, required: false
  private _include?: string; 
  public get include() {
    return this.getStringAttribute('include');
  }
  public set include(value: string) {
    this._include = value;
  }
  public resetInclude() {
    this._include = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeInput() {
    return this._include;
  }

  // recurse - computed: false, optional: true, required: false
  private _recurse?: boolean | cdktf.IResolvable; 
  public get recurse() {
    return this.getBooleanAttribute('recurse');
  }
  public set recurse(value: boolean | cdktf.IResolvable) {
    this._recurse = value;
  }
  public resetRecurse() {
    this._recurse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recurseInput() {
    return this._recurse;
  }

  // jsonnet - computed: false, optional: true, required: false
  private _jsonnet = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnetOutputReference(this, "jsonnet");
  public get jsonnet() {
    return this._jsonnet;
  }
  public putJsonnet(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryJsonnet) {
    this._jsonnet.internalValue = value;
  }
  public resetJsonnet() {
    this._jsonnet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonnetInput() {
    return this._jsonnet.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParameters {
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name: string;
  /**
  * Path to the file containing the values for the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParameters {
  /**
  * Determines whether to tell Helm to interpret booleans and numbers as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_string PlatformGitopsApplicationset#force_string}
  */
  readonly forceString?: boolean | cdktf.IResolvable;
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    force_string: cdktf.booleanToTerraform(struct!.forceString),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    force_string: {
      value: cdktf.booleanToHclTerraform(struct!.forceString),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._forceString !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceString = this._forceString;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._forceString = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._forceString = value.forceString;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // force_string - computed: false, optional: true, required: false
  private _forceString?: boolean | cdktf.IResolvable; 
  public get forceString() {
    return this.getBooleanAttribute('force_string');
  }
  public set forceString(value: boolean | cdktf.IResolvable) {
    this._forceString = value;
  }
  public resetForceString() {
    this._forceString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceStringInput() {
    return this._forceString;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelm {
  /**
  * Prevents 'helm template' from failing when `value_files` do not exist locally by not appending them to 'helm template --values'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_missing_value_files PlatformGitopsApplicationset#ignore_missing_value_files}
  */
  readonly ignoreMissingValueFiles?: boolean | cdktf.IResolvable;
  /**
  * If true then adds '--pass-credentials' to Helm commands to pass credentials to all domains.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#pass_credentials PlatformGitopsApplicationset#pass_credentials}
  */
  readonly passCredentials?: boolean | cdktf.IResolvable;
  /**
  * Helm release name. If omitted it will use the application name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#release_name PlatformGitopsApplicationset#release_name}
  */
  readonly releaseName?: string;
  /**
  * Whether to skip custom resource definition installation step (Helm's [--skip-crds](https://helm.sh/docs/chart_best_practices/custom_resource_definitions/)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_crds PlatformGitopsApplicationset#skip_crds}
  */
  readonly skipCrds?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip schema validation during helm template. Corresponds to helm --skip-schema-validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_schema_validation PlatformGitopsApplicationset#skip_schema_validation}
  */
  readonly skipSchemaValidation?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip tests during helm template. Corresponds to helm --skip-tests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_tests PlatformGitopsApplicationset#skip_tests}
  */
  readonly skipTests?: boolean | cdktf.IResolvable;
  /**
  * List of Helm value files to use when generating a template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value_files PlatformGitopsApplicationset#value_files}
  */
  readonly valueFiles?: string[];
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values PlatformGitopsApplicationset#values}
  */
  readonly values?: string;
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values_object PlatformGitopsApplicationset#values_object}
  */
  readonly valuesObject?: { [key: string]: string };
  /**
  * Helm version to use for templating (either "2" or "3").
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
  /**
  * file_parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#file_parameters PlatformGitopsApplicationset#file_parameters}
  */
  readonly fileParameters?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParameters[] | cdktf.IResolvable;
  /**
  * parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#parameters PlatformGitopsApplicationset#parameters}
  */
  readonly parameters?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParameters[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_missing_value_files: cdktf.booleanToTerraform(struct!.ignoreMissingValueFiles),
    pass_credentials: cdktf.booleanToTerraform(struct!.passCredentials),
    release_name: cdktf.stringToTerraform(struct!.releaseName),
    skip_crds: cdktf.booleanToTerraform(struct!.skipCrds),
    skip_schema_validation: cdktf.booleanToTerraform(struct!.skipSchemaValidation),
    skip_tests: cdktf.booleanToTerraform(struct!.skipTests),
    value_files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.valueFiles),
    values: cdktf.stringToTerraform(struct!.values),
    values_object: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.valuesObject),
    version: cdktf.stringToTerraform(struct!.version),
    file_parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersToTerraform, true)(struct!.fileParameters),
    parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersToTerraform, true)(struct!.parameters),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_missing_value_files: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreMissingValueFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pass_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.passCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    release_name: {
      value: cdktf.stringToHclTerraform(struct!.releaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_crds: {
      value: cdktf.booleanToHclTerraform(struct!.skipCrds),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_schema_validation: {
      value: cdktf.booleanToHclTerraform(struct!.skipSchemaValidation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_tests: {
      value: cdktf.booleanToHclTerraform(struct!.skipTests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value_files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.valueFiles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    values: {
      value: cdktf.stringToHclTerraform(struct!.values),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values_object: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.valuesObject),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersToHclTerraform, true)(struct!.fileParameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersList",
    },
    parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersToHclTerraform, true)(struct!.parameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelm | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreMissingValueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreMissingValueFiles = this._ignoreMissingValueFiles;
    }
    if (this._passCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.passCredentials = this._passCredentials;
    }
    if (this._releaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.releaseName = this._releaseName;
    }
    if (this._skipCrds !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCrds = this._skipCrds;
    }
    if (this._skipSchemaValidation !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipSchemaValidation = this._skipSchemaValidation;
    }
    if (this._skipTests !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipTests = this._skipTests;
    }
    if (this._valueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFiles = this._valueFiles;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    if (this._valuesObject !== undefined) {
      hasAnyValues = true;
      internalValueResult.valuesObject = this._valuesObject;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._fileParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileParameters = this._fileParameters?.internalValue;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelm | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._ignoreMissingValueFiles = undefined;
      this._passCredentials = undefined;
      this._releaseName = undefined;
      this._skipCrds = undefined;
      this._skipSchemaValidation = undefined;
      this._skipTests = undefined;
      this._valueFiles = undefined;
      this._values = undefined;
      this._valuesObject = undefined;
      this._version = undefined;
      this._fileParameters.internalValue = undefined;
      this._parameters.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._ignoreMissingValueFiles = value.ignoreMissingValueFiles;
      this._passCredentials = value.passCredentials;
      this._releaseName = value.releaseName;
      this._skipCrds = value.skipCrds;
      this._skipSchemaValidation = value.skipSchemaValidation;
      this._skipTests = value.skipTests;
      this._valueFiles = value.valueFiles;
      this._values = value.values;
      this._valuesObject = value.valuesObject;
      this._version = value.version;
      this._fileParameters.internalValue = value.fileParameters;
      this._parameters.internalValue = value.parameters;
    }
  }

  // ignore_missing_value_files - computed: false, optional: true, required: false
  private _ignoreMissingValueFiles?: boolean | cdktf.IResolvable; 
  public get ignoreMissingValueFiles() {
    return this.getBooleanAttribute('ignore_missing_value_files');
  }
  public set ignoreMissingValueFiles(value: boolean | cdktf.IResolvable) {
    this._ignoreMissingValueFiles = value;
  }
  public resetIgnoreMissingValueFiles() {
    this._ignoreMissingValueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreMissingValueFilesInput() {
    return this._ignoreMissingValueFiles;
  }

  // pass_credentials - computed: false, optional: true, required: false
  private _passCredentials?: boolean | cdktf.IResolvable; 
  public get passCredentials() {
    return this.getBooleanAttribute('pass_credentials');
  }
  public set passCredentials(value: boolean | cdktf.IResolvable) {
    this._passCredentials = value;
  }
  public resetPassCredentials() {
    this._passCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passCredentialsInput() {
    return this._passCredentials;
  }

  // release_name - computed: false, optional: true, required: false
  private _releaseName?: string; 
  public get releaseName() {
    return this.getStringAttribute('release_name');
  }
  public set releaseName(value: string) {
    this._releaseName = value;
  }
  public resetReleaseName() {
    this._releaseName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get releaseNameInput() {
    return this._releaseName;
  }

  // skip_crds - computed: false, optional: true, required: false
  private _skipCrds?: boolean | cdktf.IResolvable; 
  public get skipCrds() {
    return this.getBooleanAttribute('skip_crds');
  }
  public set skipCrds(value: boolean | cdktf.IResolvable) {
    this._skipCrds = value;
  }
  public resetSkipCrds() {
    this._skipCrds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCrdsInput() {
    return this._skipCrds;
  }

  // skip_schema_validation - computed: false, optional: true, required: false
  private _skipSchemaValidation?: boolean | cdktf.IResolvable; 
  public get skipSchemaValidation() {
    return this.getBooleanAttribute('skip_schema_validation');
  }
  public set skipSchemaValidation(value: boolean | cdktf.IResolvable) {
    this._skipSchemaValidation = value;
  }
  public resetSkipSchemaValidation() {
    this._skipSchemaValidation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipSchemaValidationInput() {
    return this._skipSchemaValidation;
  }

  // skip_tests - computed: false, optional: true, required: false
  private _skipTests?: boolean | cdktf.IResolvable; 
  public get skipTests() {
    return this.getBooleanAttribute('skip_tests');
  }
  public set skipTests(value: boolean | cdktf.IResolvable) {
    this._skipTests = value;
  }
  public resetSkipTests() {
    this._skipTests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipTestsInput() {
    return this._skipTests;
  }

  // value_files - computed: false, optional: true, required: false
  private _valueFiles?: string[]; 
  public get valueFiles() {
    return this.getListAttribute('value_files');
  }
  public set valueFiles(value: string[]) {
    this._valueFiles = value;
  }
  public resetValueFiles() {
    this._valueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFilesInput() {
    return this._valueFiles;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string; 
  public get values() {
    return this.getStringAttribute('values');
  }
  public set values(value: string) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }

  // values_object - computed: false, optional: true, required: false
  private _valuesObject?: { [key: string]: string }; 
  public get valuesObject() {
    return this.getStringMapAttribute('values_object');
  }
  public set valuesObject(value: { [key: string]: string }) {
    this._valuesObject = value;
  }
  public resetValuesObject() {
    this._valuesObject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesObjectInput() {
    return this._valuesObject;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // file_parameters - computed: false, optional: true, required: false
  private _fileParameters = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParametersList(this, "file_parameters", false);
  public get fileParameters() {
    return this._fileParameters;
  }
  public putFileParameters(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmFileParameters[] | cdktf.IResolvable) {
    this._fileParameters.internalValue = value;
  }
  public resetFileParameters() {
    this._fileParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileParametersInput() {
    return this._fileParameters.internalValue;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParametersList(this, "parameters", false);
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmParameters[] | cdktf.IResolvable) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomize {
  /**
  * List of additional annotations to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_annotations PlatformGitopsApplicationset#common_annotations}
  */
  readonly commonAnnotations?: { [key: string]: string };
  /**
  * List of additional labels to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_labels PlatformGitopsApplicationset#common_labels}
  */
  readonly commonLabels?: { [key: string]: string };
  /**
  * Indicates if to force applying common annotations to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_annotations PlatformGitopsApplicationset#force_common_annotations}
  */
  readonly forceCommonAnnotations?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to force apply common labels to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_labels PlatformGitopsApplicationset#force_common_labels}
  */
  readonly forceCommonLabels?: boolean | cdktf.IResolvable;
  /**
  * List of Kustomize image override specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#images PlatformGitopsApplicationset#images}
  */
  readonly images?: string[];
  /**
  * Prefix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_prefix PlatformGitopsApplicationset#name_prefix}
  */
  readonly namePrefix?: string;
  /**
  * Suffix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_suffix PlatformGitopsApplicationset#name_suffix}
  */
  readonly nameSuffix?: string;
  /**
  * Version of Kustomize to use for rendering manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    common_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonAnnotations),
    common_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonLabels),
    force_common_annotations: cdktf.booleanToTerraform(struct!.forceCommonAnnotations),
    force_common_labels: cdktf.booleanToTerraform(struct!.forceCommonLabels),
    images: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.images),
    name_prefix: cdktf.stringToTerraform(struct!.namePrefix),
    name_suffix: cdktf.stringToTerraform(struct!.nameSuffix),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    common_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    common_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    force_common_annotations: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    force_common_labels: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    images: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.images),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name_prefix: {
      value: cdktf.stringToHclTerraform(struct!.namePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.nameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomize | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonAnnotations = this._commonAnnotations;
    }
    if (this._commonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonLabels = this._commonLabels;
    }
    if (this._forceCommonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonAnnotations = this._forceCommonAnnotations;
    }
    if (this._forceCommonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonLabels = this._forceCommonLabels;
    }
    if (this._images !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images;
    }
    if (this._namePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.namePrefix = this._namePrefix;
    }
    if (this._nameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameSuffix = this._nameSuffix;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomize | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._commonAnnotations = undefined;
      this._commonLabels = undefined;
      this._forceCommonAnnotations = undefined;
      this._forceCommonLabels = undefined;
      this._images = undefined;
      this._namePrefix = undefined;
      this._nameSuffix = undefined;
      this._version = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._commonAnnotations = value.commonAnnotations;
      this._commonLabels = value.commonLabels;
      this._forceCommonAnnotations = value.forceCommonAnnotations;
      this._forceCommonLabels = value.forceCommonLabels;
      this._images = value.images;
      this._namePrefix = value.namePrefix;
      this._nameSuffix = value.nameSuffix;
      this._version = value.version;
    }
  }

  // common_annotations - computed: false, optional: true, required: false
  private _commonAnnotations?: { [key: string]: string }; 
  public get commonAnnotations() {
    return this.getStringMapAttribute('common_annotations');
  }
  public set commonAnnotations(value: { [key: string]: string }) {
    this._commonAnnotations = value;
  }
  public resetCommonAnnotations() {
    this._commonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonAnnotationsInput() {
    return this._commonAnnotations;
  }

  // common_labels - computed: false, optional: true, required: false
  private _commonLabels?: { [key: string]: string }; 
  public get commonLabels() {
    return this.getStringMapAttribute('common_labels');
  }
  public set commonLabels(value: { [key: string]: string }) {
    this._commonLabels = value;
  }
  public resetCommonLabels() {
    this._commonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonLabelsInput() {
    return this._commonLabels;
  }

  // force_common_annotations - computed: false, optional: true, required: false
  private _forceCommonAnnotations?: boolean | cdktf.IResolvable; 
  public get forceCommonAnnotations() {
    return this.getBooleanAttribute('force_common_annotations');
  }
  public set forceCommonAnnotations(value: boolean | cdktf.IResolvable) {
    this._forceCommonAnnotations = value;
  }
  public resetForceCommonAnnotations() {
    this._forceCommonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonAnnotationsInput() {
    return this._forceCommonAnnotations;
  }

  // force_common_labels - computed: false, optional: true, required: false
  private _forceCommonLabels?: boolean | cdktf.IResolvable; 
  public get forceCommonLabels() {
    return this.getBooleanAttribute('force_common_labels');
  }
  public set forceCommonLabels(value: boolean | cdktf.IResolvable) {
    this._forceCommonLabels = value;
  }
  public resetForceCommonLabels() {
    this._forceCommonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonLabelsInput() {
    return this._forceCommonLabels;
  }

  // images - computed: false, optional: true, required: false
  private _images?: string[]; 
  public get images() {
    return this.getListAttribute('images');
  }
  public set images(value: string[]) {
    this._images = value;
  }
  public resetImages() {
    this._images = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images;
  }

  // name_prefix - computed: false, optional: true, required: false
  private _namePrefix?: string; 
  public get namePrefix() {
    return this.getStringAttribute('name_prefix');
  }
  public set namePrefix(value: string) {
    this._namePrefix = value;
  }
  public resetNamePrefix() {
    this._namePrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namePrefixInput() {
    return this._namePrefix;
  }

  // name_suffix - computed: false, optional: true, required: false
  private _nameSuffix?: string; 
  public get nameSuffix() {
    return this.getStringAttribute('name_suffix');
  }
  public set nameSuffix(value: string) {
    this._nameSuffix = value;
  }
  public resetNameSuffix() {
    this._nameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameSuffixInput() {
    return this._nameSuffix;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnv {
  /**
  * Name of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePlugin {
  /**
  * Name of the plugin. Only set the plugin name if the plugin is defined in `argocd-cm`. If the plugin is defined as a sidecar, omit the name. The plugin will be automatically matched with the Application according to the plugin's discovery rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * env block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#env PlatformGitopsApplicationset#env}
  */
  readonly env?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnv[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    env: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvToTerraform, true)(struct!.env),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvToHclTerraform, true)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePlugin | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePlugin | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._env.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._env.internalValue = value.env;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // env - computed: false, optional: true, required: false
  private _env = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSource {
  /**
  * Helm chart name. Must be specified for applications sourced from a Helm repo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#chart PlatformGitopsApplicationset#chart}
  */
  readonly chart?: string;
  /**
  * Directory path within the repository. Only valid for applications sourced from Git.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path?: string;
  /**
  * Reference to another `source` within defined sources. See associated documentation on [Helm value files from external Git repository](https://argo-cd.readthedocs.io/en/stable/user-guide/multiple_sources/#helm-value-files-from-external-git-repository) regarding combining `ref` with `path` and/or `chart`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ref PlatformGitopsApplicationset#ref}
  */
  readonly ref?: string;
  /**
  * URL to the repository (Git or Helm) that contains the application manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#repo_url PlatformGitopsApplicationset#repo_url}
  */
  readonly repoUrl?: string;
  /**
  * Revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart's version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#target_revision PlatformGitopsApplicationset#target_revision}
  */
  readonly targetRevision?: string;
  /**
  * directory block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#directory PlatformGitopsApplicationset#directory}
  */
  readonly directory?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectory;
  /**
  * helm block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#helm PlatformGitopsApplicationset#helm}
  */
  readonly helm?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelm;
  /**
  * kustomize block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#kustomize PlatformGitopsApplicationset#kustomize}
  */
  readonly kustomize?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomize;
  /**
  * plugin block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#plugin PlatformGitopsApplicationset#plugin}
  */
  readonly plugin?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePlugin;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chart: cdktf.stringToTerraform(struct!.chart),
    path: cdktf.stringToTerraform(struct!.path),
    ref: cdktf.stringToTerraform(struct!.ref),
    repo_url: cdktf.stringToTerraform(struct!.repoUrl),
    target_revision: cdktf.stringToTerraform(struct!.targetRevision),
    directory: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryToTerraform(struct!.directory),
    helm: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmToTerraform(struct!.helm),
    kustomize: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeToTerraform(struct!.kustomize),
    plugin: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginToTerraform(struct!.plugin),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chart: {
      value: cdktf.stringToHclTerraform(struct!.chart),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: cdktf.stringToHclTerraform(struct!.ref),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repo_url: {
      value: cdktf.stringToHclTerraform(struct!.repoUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_revision: {
      value: cdktf.stringToHclTerraform(struct!.targetRevision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    directory: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryToHclTerraform(struct!.directory),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryList",
    },
    helm: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmToHclTerraform(struct!.helm),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmList",
    },
    kustomize: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeToHclTerraform(struct!.kustomize),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeList",
    },
    plugin: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginToHclTerraform(struct!.plugin),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chart !== undefined) {
      hasAnyValues = true;
      internalValueResult.chart = this._chart;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ref !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref;
    }
    if (this._repoUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.repoUrl = this._repoUrl;
    }
    if (this._targetRevision !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRevision = this._targetRevision;
    }
    if (this._directory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.directory = this._directory?.internalValue;
    }
    if (this._helm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.helm = this._helm?.internalValue;
    }
    if (this._kustomize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kustomize = this._kustomize?.internalValue;
    }
    if (this._plugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chart = undefined;
      this._path = undefined;
      this._ref = undefined;
      this._repoUrl = undefined;
      this._targetRevision = undefined;
      this._directory.internalValue = undefined;
      this._helm.internalValue = undefined;
      this._kustomize.internalValue = undefined;
      this._plugin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chart = value.chart;
      this._path = value.path;
      this._ref = value.ref;
      this._repoUrl = value.repoUrl;
      this._targetRevision = value.targetRevision;
      this._directory.internalValue = value.directory;
      this._helm.internalValue = value.helm;
      this._kustomize.internalValue = value.kustomize;
      this._plugin.internalValue = value.plugin;
    }
  }

  // chart - computed: false, optional: true, required: false
  private _chart?: string; 
  public get chart() {
    return this.getStringAttribute('chart');
  }
  public set chart(value: string) {
    this._chart = value;
  }
  public resetChart() {
    this._chart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chartInput() {
    return this._chart;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ref - computed: false, optional: true, required: false
  private _ref?: string; 
  public get ref() {
    return this.getStringAttribute('ref');
  }
  public set ref(value: string) {
    this._ref = value;
  }
  public resetRef() {
    this._ref = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref;
  }

  // repo_url - computed: false, optional: true, required: false
  private _repoUrl?: string; 
  public get repoUrl() {
    return this.getStringAttribute('repo_url');
  }
  public set repoUrl(value: string) {
    this._repoUrl = value;
  }
  public resetRepoUrl() {
    this._repoUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repoUrlInput() {
    return this._repoUrl;
  }

  // target_revision - computed: false, optional: true, required: false
  private _targetRevision?: string; 
  public get targetRevision() {
    return this.getStringAttribute('target_revision');
  }
  public set targetRevision(value: string) {
    this._targetRevision = value;
  }
  public resetTargetRevision() {
    this._targetRevision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRevisionInput() {
    return this._targetRevision;
  }

  // directory - computed: false, optional: true, required: false
  private _directory = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectoryOutputReference(this, "directory");
  public get directory() {
    return this._directory;
  }
  public putDirectory(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceDirectory) {
    this._directory.internalValue = value;
  }
  public resetDirectory() {
    this._directory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directoryInput() {
    return this._directory.internalValue;
  }

  // helm - computed: false, optional: true, required: false
  private _helm = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelmOutputReference(this, "helm");
  public get helm() {
    return this._helm;
  }
  public putHelm(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceHelm) {
    this._helm.internalValue = value;
  }
  public resetHelm() {
    this._helm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helmInput() {
    return this._helm.internalValue;
  }

  // kustomize - computed: false, optional: true, required: false
  private _kustomize = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomizeOutputReference(this, "kustomize");
  public get kustomize() {
    return this._kustomize;
  }
  public putKustomize(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceKustomize) {
    this._kustomize.internalValue = value;
  }
  public resetKustomize() {
    this._kustomize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kustomizeInput() {
    return this._kustomize.internalValue;
  }

  // plugin - computed: false, optional: true, required: false
  private _plugin = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePluginOutputReference(this, "plugin");
  public get plugin() {
    return this._plugin;
  }
  public putPlugin(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcePlugin) {
    this._plugin.internalValue = value;
  }
  public resetPlugin() {
    this._plugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSource[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVar {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlas {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnet {
  /**
  * Additional library search dirs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#libs PlatformGitopsApplicationset#libs}
  */
  readonly libs?: string[];
  /**
  * ext_var block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ext_var PlatformGitopsApplicationset#ext_var}
  */
  readonly extVar?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable;
  /**
  * tlas block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#tlas PlatformGitopsApplicationset#tlas}
  */
  readonly tlas?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    libs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.libs),
    ext_var: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarToTerraform, true)(struct!.extVar),
    tlas: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasToTerraform, true)(struct!.tlas),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    libs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.libs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ext_var: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarToHclTerraform, true)(struct!.extVar),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarList",
    },
    tlas: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasToHclTerraform, true)(struct!.tlas),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._libs !== undefined) {
      hasAnyValues = true;
      internalValueResult.libs = this._libs;
    }
    if (this._extVar?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extVar = this._extVar?.internalValue;
    }
    if (this._tlas?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlas = this._tlas?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._libs = undefined;
      this._extVar.internalValue = undefined;
      this._tlas.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._libs = value.libs;
      this._extVar.internalValue = value.extVar;
      this._tlas.internalValue = value.tlas;
    }
  }

  // libs - computed: false, optional: true, required: false
  private _libs?: string[]; 
  public get libs() {
    return this.getListAttribute('libs');
  }
  public set libs(value: string[]) {
    this._libs = value;
  }
  public resetLibs() {
    this._libs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get libsInput() {
    return this._libs;
  }

  // ext_var - computed: false, optional: true, required: false
  private _extVar = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVarList(this, "ext_var", false);
  public get extVar() {
    return this._extVar;
  }
  public putExtVar(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable) {
    this._extVar.internalValue = value;
  }
  public resetExtVar() {
    this._extVar.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extVarInput() {
    return this._extVar.internalValue;
  }

  // tlas - computed: false, optional: true, required: false
  private _tlas = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlasList(this, "tlas", false);
  public get tlas() {
    return this._tlas;
  }
  public putTlas(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable) {
    this._tlas.internalValue = value;
  }
  public resetTlas() {
    this._tlas.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlasInput() {
    return this._tlas.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectory {
  /**
  * Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation. This takes precedence over the `include` field. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{config.yaml,env-use2/*}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#exclude PlatformGitopsApplicationset#exclude}
  */
  readonly exclude?: string;
  /**
  * Glob pattern to match paths against that should be explicitly included during manifest generation. If this field is set, only matching manifests will be included. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{*.yml,*.yaml}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#include PlatformGitopsApplicationset#include}
  */
  readonly include?: string;
  /**
  * Whether to scan a directory recursively for manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#recurse PlatformGitopsApplicationset#recurse}
  */
  readonly recurse?: boolean | cdktf.IResolvable;
  /**
  * jsonnet block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#jsonnet PlatformGitopsApplicationset#jsonnet}
  */
  readonly jsonnet?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnet;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exclude: cdktf.stringToTerraform(struct!.exclude),
    include: cdktf.stringToTerraform(struct!.include),
    recurse: cdktf.booleanToTerraform(struct!.recurse),
    jsonnet: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetToTerraform(struct!.jsonnet),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exclude: {
      value: cdktf.stringToHclTerraform(struct!.exclude),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include: {
      value: cdktf.stringToHclTerraform(struct!.include),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    recurse: {
      value: cdktf.booleanToHclTerraform(struct!.recurse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    jsonnet: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetToHclTerraform(struct!.jsonnet),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectory | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exclude !== undefined) {
      hasAnyValues = true;
      internalValueResult.exclude = this._exclude;
    }
    if (this._include !== undefined) {
      hasAnyValues = true;
      internalValueResult.include = this._include;
    }
    if (this._recurse !== undefined) {
      hasAnyValues = true;
      internalValueResult.recurse = this._recurse;
    }
    if (this._jsonnet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonnet = this._jsonnet?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectory | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._exclude = undefined;
      this._include = undefined;
      this._recurse = undefined;
      this._jsonnet.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._exclude = value.exclude;
      this._include = value.include;
      this._recurse = value.recurse;
      this._jsonnet.internalValue = value.jsonnet;
    }
  }

  // exclude - computed: false, optional: true, required: false
  private _exclude?: string; 
  public get exclude() {
    return this.getStringAttribute('exclude');
  }
  public set exclude(value: string) {
    this._exclude = value;
  }
  public resetExclude() {
    this._exclude = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeInput() {
    return this._exclude;
  }

  // include - computed: false, optional: true, required: false
  private _include?: string; 
  public get include() {
    return this.getStringAttribute('include');
  }
  public set include(value: string) {
    this._include = value;
  }
  public resetInclude() {
    this._include = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeInput() {
    return this._include;
  }

  // recurse - computed: false, optional: true, required: false
  private _recurse?: boolean | cdktf.IResolvable; 
  public get recurse() {
    return this.getBooleanAttribute('recurse');
  }
  public set recurse(value: boolean | cdktf.IResolvable) {
    this._recurse = value;
  }
  public resetRecurse() {
    this._recurse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recurseInput() {
    return this._recurse;
  }

  // jsonnet - computed: false, optional: true, required: false
  private _jsonnet = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnetOutputReference(this, "jsonnet");
  public get jsonnet() {
    return this._jsonnet;
  }
  public putJsonnet(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryJsonnet) {
    this._jsonnet.internalValue = value;
  }
  public resetJsonnet() {
    this._jsonnet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonnetInput() {
    return this._jsonnet.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParameters {
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name: string;
  /**
  * Path to the file containing the values for the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParameters {
  /**
  * Determines whether to tell Helm to interpret booleans and numbers as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_string PlatformGitopsApplicationset#force_string}
  */
  readonly forceString?: boolean | cdktf.IResolvable;
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    force_string: cdktf.booleanToTerraform(struct!.forceString),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    force_string: {
      value: cdktf.booleanToHclTerraform(struct!.forceString),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._forceString !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceString = this._forceString;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._forceString = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._forceString = value.forceString;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // force_string - computed: false, optional: true, required: false
  private _forceString?: boolean | cdktf.IResolvable; 
  public get forceString() {
    return this.getBooleanAttribute('force_string');
  }
  public set forceString(value: boolean | cdktf.IResolvable) {
    this._forceString = value;
  }
  public resetForceString() {
    this._forceString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceStringInput() {
    return this._forceString;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelm {
  /**
  * Prevents 'helm template' from failing when `value_files` do not exist locally by not appending them to 'helm template --values'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_missing_value_files PlatformGitopsApplicationset#ignore_missing_value_files}
  */
  readonly ignoreMissingValueFiles?: boolean | cdktf.IResolvable;
  /**
  * If true then adds '--pass-credentials' to Helm commands to pass credentials to all domains.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#pass_credentials PlatformGitopsApplicationset#pass_credentials}
  */
  readonly passCredentials?: boolean | cdktf.IResolvable;
  /**
  * Helm release name. If omitted it will use the application name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#release_name PlatformGitopsApplicationset#release_name}
  */
  readonly releaseName?: string;
  /**
  * Whether to skip custom resource definition installation step (Helm's [--skip-crds](https://helm.sh/docs/chart_best_practices/custom_resource_definitions/)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_crds PlatformGitopsApplicationset#skip_crds}
  */
  readonly skipCrds?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip schema validation during helm template. Corresponds to helm --skip-schema-validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_schema_validation PlatformGitopsApplicationset#skip_schema_validation}
  */
  readonly skipSchemaValidation?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip tests during helm template. Corresponds to helm --skip-tests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_tests PlatformGitopsApplicationset#skip_tests}
  */
  readonly skipTests?: boolean | cdktf.IResolvable;
  /**
  * List of Helm value files to use when generating a template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value_files PlatformGitopsApplicationset#value_files}
  */
  readonly valueFiles?: string[];
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values PlatformGitopsApplicationset#values}
  */
  readonly values?: string;
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values_object PlatformGitopsApplicationset#values_object}
  */
  readonly valuesObject?: { [key: string]: string };
  /**
  * Helm version to use for templating (either "2" or "3").
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
  /**
  * file_parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#file_parameters PlatformGitopsApplicationset#file_parameters}
  */
  readonly fileParameters?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable;
  /**
  * parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#parameters PlatformGitopsApplicationset#parameters}
  */
  readonly parameters?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_missing_value_files: cdktf.booleanToTerraform(struct!.ignoreMissingValueFiles),
    pass_credentials: cdktf.booleanToTerraform(struct!.passCredentials),
    release_name: cdktf.stringToTerraform(struct!.releaseName),
    skip_crds: cdktf.booleanToTerraform(struct!.skipCrds),
    skip_schema_validation: cdktf.booleanToTerraform(struct!.skipSchemaValidation),
    skip_tests: cdktf.booleanToTerraform(struct!.skipTests),
    value_files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.valueFiles),
    values: cdktf.stringToTerraform(struct!.values),
    values_object: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.valuesObject),
    version: cdktf.stringToTerraform(struct!.version),
    file_parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersToTerraform, true)(struct!.fileParameters),
    parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersToTerraform, true)(struct!.parameters),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_missing_value_files: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreMissingValueFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pass_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.passCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    release_name: {
      value: cdktf.stringToHclTerraform(struct!.releaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_crds: {
      value: cdktf.booleanToHclTerraform(struct!.skipCrds),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_schema_validation: {
      value: cdktf.booleanToHclTerraform(struct!.skipSchemaValidation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_tests: {
      value: cdktf.booleanToHclTerraform(struct!.skipTests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value_files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.valueFiles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    values: {
      value: cdktf.stringToHclTerraform(struct!.values),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values_object: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.valuesObject),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersToHclTerraform, true)(struct!.fileParameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersList",
    },
    parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersToHclTerraform, true)(struct!.parameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelm | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreMissingValueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreMissingValueFiles = this._ignoreMissingValueFiles;
    }
    if (this._passCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.passCredentials = this._passCredentials;
    }
    if (this._releaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.releaseName = this._releaseName;
    }
    if (this._skipCrds !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCrds = this._skipCrds;
    }
    if (this._skipSchemaValidation !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipSchemaValidation = this._skipSchemaValidation;
    }
    if (this._skipTests !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipTests = this._skipTests;
    }
    if (this._valueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFiles = this._valueFiles;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    if (this._valuesObject !== undefined) {
      hasAnyValues = true;
      internalValueResult.valuesObject = this._valuesObject;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._fileParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileParameters = this._fileParameters?.internalValue;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelm | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._ignoreMissingValueFiles = undefined;
      this._passCredentials = undefined;
      this._releaseName = undefined;
      this._skipCrds = undefined;
      this._skipSchemaValidation = undefined;
      this._skipTests = undefined;
      this._valueFiles = undefined;
      this._values = undefined;
      this._valuesObject = undefined;
      this._version = undefined;
      this._fileParameters.internalValue = undefined;
      this._parameters.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._ignoreMissingValueFiles = value.ignoreMissingValueFiles;
      this._passCredentials = value.passCredentials;
      this._releaseName = value.releaseName;
      this._skipCrds = value.skipCrds;
      this._skipSchemaValidation = value.skipSchemaValidation;
      this._skipTests = value.skipTests;
      this._valueFiles = value.valueFiles;
      this._values = value.values;
      this._valuesObject = value.valuesObject;
      this._version = value.version;
      this._fileParameters.internalValue = value.fileParameters;
      this._parameters.internalValue = value.parameters;
    }
  }

  // ignore_missing_value_files - computed: false, optional: true, required: false
  private _ignoreMissingValueFiles?: boolean | cdktf.IResolvable; 
  public get ignoreMissingValueFiles() {
    return this.getBooleanAttribute('ignore_missing_value_files');
  }
  public set ignoreMissingValueFiles(value: boolean | cdktf.IResolvable) {
    this._ignoreMissingValueFiles = value;
  }
  public resetIgnoreMissingValueFiles() {
    this._ignoreMissingValueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreMissingValueFilesInput() {
    return this._ignoreMissingValueFiles;
  }

  // pass_credentials - computed: false, optional: true, required: false
  private _passCredentials?: boolean | cdktf.IResolvable; 
  public get passCredentials() {
    return this.getBooleanAttribute('pass_credentials');
  }
  public set passCredentials(value: boolean | cdktf.IResolvable) {
    this._passCredentials = value;
  }
  public resetPassCredentials() {
    this._passCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passCredentialsInput() {
    return this._passCredentials;
  }

  // release_name - computed: false, optional: true, required: false
  private _releaseName?: string; 
  public get releaseName() {
    return this.getStringAttribute('release_name');
  }
  public set releaseName(value: string) {
    this._releaseName = value;
  }
  public resetReleaseName() {
    this._releaseName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get releaseNameInput() {
    return this._releaseName;
  }

  // skip_crds - computed: false, optional: true, required: false
  private _skipCrds?: boolean | cdktf.IResolvable; 
  public get skipCrds() {
    return this.getBooleanAttribute('skip_crds');
  }
  public set skipCrds(value: boolean | cdktf.IResolvable) {
    this._skipCrds = value;
  }
  public resetSkipCrds() {
    this._skipCrds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCrdsInput() {
    return this._skipCrds;
  }

  // skip_schema_validation - computed: false, optional: true, required: false
  private _skipSchemaValidation?: boolean | cdktf.IResolvable; 
  public get skipSchemaValidation() {
    return this.getBooleanAttribute('skip_schema_validation');
  }
  public set skipSchemaValidation(value: boolean | cdktf.IResolvable) {
    this._skipSchemaValidation = value;
  }
  public resetSkipSchemaValidation() {
    this._skipSchemaValidation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipSchemaValidationInput() {
    return this._skipSchemaValidation;
  }

  // skip_tests - computed: false, optional: true, required: false
  private _skipTests?: boolean | cdktf.IResolvable; 
  public get skipTests() {
    return this.getBooleanAttribute('skip_tests');
  }
  public set skipTests(value: boolean | cdktf.IResolvable) {
    this._skipTests = value;
  }
  public resetSkipTests() {
    this._skipTests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipTestsInput() {
    return this._skipTests;
  }

  // value_files - computed: false, optional: true, required: false
  private _valueFiles?: string[]; 
  public get valueFiles() {
    return this.getListAttribute('value_files');
  }
  public set valueFiles(value: string[]) {
    this._valueFiles = value;
  }
  public resetValueFiles() {
    this._valueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFilesInput() {
    return this._valueFiles;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string; 
  public get values() {
    return this.getStringAttribute('values');
  }
  public set values(value: string) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }

  // values_object - computed: false, optional: true, required: false
  private _valuesObject?: { [key: string]: string }; 
  public get valuesObject() {
    return this.getStringMapAttribute('values_object');
  }
  public set valuesObject(value: { [key: string]: string }) {
    this._valuesObject = value;
  }
  public resetValuesObject() {
    this._valuesObject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesObjectInput() {
    return this._valuesObject;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // file_parameters - computed: false, optional: true, required: false
  private _fileParameters = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParametersList(this, "file_parameters", false);
  public get fileParameters() {
    return this._fileParameters;
  }
  public putFileParameters(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable) {
    this._fileParameters.internalValue = value;
  }
  public resetFileParameters() {
    this._fileParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileParametersInput() {
    return this._fileParameters.internalValue;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParametersList(this, "parameters", false);
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomize {
  /**
  * List of additional annotations to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_annotations PlatformGitopsApplicationset#common_annotations}
  */
  readonly commonAnnotations?: { [key: string]: string };
  /**
  * List of additional labels to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_labels PlatformGitopsApplicationset#common_labels}
  */
  readonly commonLabels?: { [key: string]: string };
  /**
  * Indicates if to force applying common annotations to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_annotations PlatformGitopsApplicationset#force_common_annotations}
  */
  readonly forceCommonAnnotations?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to force apply common labels to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_labels PlatformGitopsApplicationset#force_common_labels}
  */
  readonly forceCommonLabels?: boolean | cdktf.IResolvable;
  /**
  * List of Kustomize image override specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#images PlatformGitopsApplicationset#images}
  */
  readonly images?: string[];
  /**
  * Prefix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_prefix PlatformGitopsApplicationset#name_prefix}
  */
  readonly namePrefix?: string;
  /**
  * Suffix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_suffix PlatformGitopsApplicationset#name_suffix}
  */
  readonly nameSuffix?: string;
  /**
  * Version of Kustomize to use for rendering manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    common_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonAnnotations),
    common_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonLabels),
    force_common_annotations: cdktf.booleanToTerraform(struct!.forceCommonAnnotations),
    force_common_labels: cdktf.booleanToTerraform(struct!.forceCommonLabels),
    images: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.images),
    name_prefix: cdktf.stringToTerraform(struct!.namePrefix),
    name_suffix: cdktf.stringToTerraform(struct!.nameSuffix),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    common_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    common_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    force_common_annotations: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    force_common_labels: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    images: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.images),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name_prefix: {
      value: cdktf.stringToHclTerraform(struct!.namePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.nameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomize | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonAnnotations = this._commonAnnotations;
    }
    if (this._commonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonLabels = this._commonLabels;
    }
    if (this._forceCommonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonAnnotations = this._forceCommonAnnotations;
    }
    if (this._forceCommonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonLabels = this._forceCommonLabels;
    }
    if (this._images !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images;
    }
    if (this._namePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.namePrefix = this._namePrefix;
    }
    if (this._nameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameSuffix = this._nameSuffix;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomize | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._commonAnnotations = undefined;
      this._commonLabels = undefined;
      this._forceCommonAnnotations = undefined;
      this._forceCommonLabels = undefined;
      this._images = undefined;
      this._namePrefix = undefined;
      this._nameSuffix = undefined;
      this._version = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._commonAnnotations = value.commonAnnotations;
      this._commonLabels = value.commonLabels;
      this._forceCommonAnnotations = value.forceCommonAnnotations;
      this._forceCommonLabels = value.forceCommonLabels;
      this._images = value.images;
      this._namePrefix = value.namePrefix;
      this._nameSuffix = value.nameSuffix;
      this._version = value.version;
    }
  }

  // common_annotations - computed: false, optional: true, required: false
  private _commonAnnotations?: { [key: string]: string }; 
  public get commonAnnotations() {
    return this.getStringMapAttribute('common_annotations');
  }
  public set commonAnnotations(value: { [key: string]: string }) {
    this._commonAnnotations = value;
  }
  public resetCommonAnnotations() {
    this._commonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonAnnotationsInput() {
    return this._commonAnnotations;
  }

  // common_labels - computed: false, optional: true, required: false
  private _commonLabels?: { [key: string]: string }; 
  public get commonLabels() {
    return this.getStringMapAttribute('common_labels');
  }
  public set commonLabels(value: { [key: string]: string }) {
    this._commonLabels = value;
  }
  public resetCommonLabels() {
    this._commonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonLabelsInput() {
    return this._commonLabels;
  }

  // force_common_annotations - computed: false, optional: true, required: false
  private _forceCommonAnnotations?: boolean | cdktf.IResolvable; 
  public get forceCommonAnnotations() {
    return this.getBooleanAttribute('force_common_annotations');
  }
  public set forceCommonAnnotations(value: boolean | cdktf.IResolvable) {
    this._forceCommonAnnotations = value;
  }
  public resetForceCommonAnnotations() {
    this._forceCommonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonAnnotationsInput() {
    return this._forceCommonAnnotations;
  }

  // force_common_labels - computed: false, optional: true, required: false
  private _forceCommonLabels?: boolean | cdktf.IResolvable; 
  public get forceCommonLabels() {
    return this.getBooleanAttribute('force_common_labels');
  }
  public set forceCommonLabels(value: boolean | cdktf.IResolvable) {
    this._forceCommonLabels = value;
  }
  public resetForceCommonLabels() {
    this._forceCommonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonLabelsInput() {
    return this._forceCommonLabels;
  }

  // images - computed: false, optional: true, required: false
  private _images?: string[]; 
  public get images() {
    return this.getListAttribute('images');
  }
  public set images(value: string[]) {
    this._images = value;
  }
  public resetImages() {
    this._images = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images;
  }

  // name_prefix - computed: false, optional: true, required: false
  private _namePrefix?: string; 
  public get namePrefix() {
    return this.getStringAttribute('name_prefix');
  }
  public set namePrefix(value: string) {
    this._namePrefix = value;
  }
  public resetNamePrefix() {
    this._namePrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namePrefixInput() {
    return this._namePrefix;
  }

  // name_suffix - computed: false, optional: true, required: false
  private _nameSuffix?: string; 
  public get nameSuffix() {
    return this.getStringAttribute('name_suffix');
  }
  public set nameSuffix(value: string) {
    this._nameSuffix = value;
  }
  public resetNameSuffix() {
    this._nameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameSuffixInput() {
    return this._nameSuffix;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnv {
  /**
  * Name of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPlugin {
  /**
  * Name of the plugin. Only set the plugin name if the plugin is defined in `argocd-cm`. If the plugin is defined as a sidecar, omit the name. The plugin will be automatically matched with the Application according to the plugin's discovery rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * env block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#env PlatformGitopsApplicationset#env}
  */
  readonly env?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    env: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvToTerraform, true)(struct!.env),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvToHclTerraform, true)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPlugin | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPlugin | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._env.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._env.internalValue = value.env;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // env - computed: false, optional: true, required: false
  private _env = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSources {
  /**
  * Helm chart name. Must be specified for applications sourced from a Helm repo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#chart PlatformGitopsApplicationset#chart}
  */
  readonly chart?: string;
  /**
  * Directory path within the repository. Only valid for applications sourced from Git.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path?: string;
  /**
  * Reference to another `source` within defined sources. See associated documentation on [Helm value files from external Git repository](https://argo-cd.readthedocs.io/en/stable/user-guide/multiple_sources/#helm-value-files-from-external-git-repository) regarding combining `ref` with `path` and/or `chart`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ref PlatformGitopsApplicationset#ref}
  */
  readonly ref?: string;
  /**
  * URL to the repository (Git or Helm) that contains the application manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#repo_url PlatformGitopsApplicationset#repo_url}
  */
  readonly repoUrl?: string;
  /**
  * Revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart's version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#target_revision PlatformGitopsApplicationset#target_revision}
  */
  readonly targetRevision?: string;
  /**
  * directory block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#directory PlatformGitopsApplicationset#directory}
  */
  readonly directory?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectory;
  /**
  * helm block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#helm PlatformGitopsApplicationset#helm}
  */
  readonly helm?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelm;
  /**
  * kustomize block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#kustomize PlatformGitopsApplicationset#kustomize}
  */
  readonly kustomize?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomize;
  /**
  * plugin block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#plugin PlatformGitopsApplicationset#plugin}
  */
  readonly plugin?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPlugin;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chart: cdktf.stringToTerraform(struct!.chart),
    path: cdktf.stringToTerraform(struct!.path),
    ref: cdktf.stringToTerraform(struct!.ref),
    repo_url: cdktf.stringToTerraform(struct!.repoUrl),
    target_revision: cdktf.stringToTerraform(struct!.targetRevision),
    directory: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryToTerraform(struct!.directory),
    helm: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmToTerraform(struct!.helm),
    kustomize: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeToTerraform(struct!.kustomize),
    plugin: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginToTerraform(struct!.plugin),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chart: {
      value: cdktf.stringToHclTerraform(struct!.chart),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: cdktf.stringToHclTerraform(struct!.ref),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repo_url: {
      value: cdktf.stringToHclTerraform(struct!.repoUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_revision: {
      value: cdktf.stringToHclTerraform(struct!.targetRevision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    directory: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryToHclTerraform(struct!.directory),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryList",
    },
    helm: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmToHclTerraform(struct!.helm),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmList",
    },
    kustomize: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeToHclTerraform(struct!.kustomize),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeList",
    },
    plugin: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginToHclTerraform(struct!.plugin),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chart !== undefined) {
      hasAnyValues = true;
      internalValueResult.chart = this._chart;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ref !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref;
    }
    if (this._repoUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.repoUrl = this._repoUrl;
    }
    if (this._targetRevision !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRevision = this._targetRevision;
    }
    if (this._directory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.directory = this._directory?.internalValue;
    }
    if (this._helm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.helm = this._helm?.internalValue;
    }
    if (this._kustomize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kustomize = this._kustomize?.internalValue;
    }
    if (this._plugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chart = undefined;
      this._path = undefined;
      this._ref = undefined;
      this._repoUrl = undefined;
      this._targetRevision = undefined;
      this._directory.internalValue = undefined;
      this._helm.internalValue = undefined;
      this._kustomize.internalValue = undefined;
      this._plugin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chart = value.chart;
      this._path = value.path;
      this._ref = value.ref;
      this._repoUrl = value.repoUrl;
      this._targetRevision = value.targetRevision;
      this._directory.internalValue = value.directory;
      this._helm.internalValue = value.helm;
      this._kustomize.internalValue = value.kustomize;
      this._plugin.internalValue = value.plugin;
    }
  }

  // chart - computed: false, optional: true, required: false
  private _chart?: string; 
  public get chart() {
    return this.getStringAttribute('chart');
  }
  public set chart(value: string) {
    this._chart = value;
  }
  public resetChart() {
    this._chart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chartInput() {
    return this._chart;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ref - computed: false, optional: true, required: false
  private _ref?: string; 
  public get ref() {
    return this.getStringAttribute('ref');
  }
  public set ref(value: string) {
    this._ref = value;
  }
  public resetRef() {
    this._ref = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref;
  }

  // repo_url - computed: false, optional: true, required: false
  private _repoUrl?: string; 
  public get repoUrl() {
    return this.getStringAttribute('repo_url');
  }
  public set repoUrl(value: string) {
    this._repoUrl = value;
  }
  public resetRepoUrl() {
    this._repoUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get repoUrlInput() {
    return this._repoUrl;
  }

  // target_revision - computed: false, optional: true, required: false
  private _targetRevision?: string; 
  public get targetRevision() {
    return this.getStringAttribute('target_revision');
  }
  public set targetRevision(value: string) {
    this._targetRevision = value;
  }
  public resetTargetRevision() {
    this._targetRevision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRevisionInput() {
    return this._targetRevision;
  }

  // directory - computed: false, optional: true, required: false
  private _directory = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectoryOutputReference(this, "directory");
  public get directory() {
    return this._directory;
  }
  public putDirectory(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesDirectory) {
    this._directory.internalValue = value;
  }
  public resetDirectory() {
    this._directory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directoryInput() {
    return this._directory.internalValue;
  }

  // helm - computed: false, optional: true, required: false
  private _helm = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelmOutputReference(this, "helm");
  public get helm() {
    return this._helm;
  }
  public putHelm(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesHelm) {
    this._helm.internalValue = value;
  }
  public resetHelm() {
    this._helm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helmInput() {
    return this._helm.internalValue;
  }

  // kustomize - computed: false, optional: true, required: false
  private _kustomize = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomizeOutputReference(this, "kustomize");
  public get kustomize() {
    return this._kustomize;
  }
  public putKustomize(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesKustomize) {
    this._kustomize.internalValue = value;
  }
  public resetKustomize() {
    this._kustomize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kustomizeInput() {
    return this._kustomize.internalValue;
  }

  // plugin - computed: false, optional: true, required: false
  private _plugin = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPluginOutputReference(this, "plugin");
  public get plugin() {
    return this._plugin;
  }
  public putPlugin(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesPlugin) {
    this._plugin.internalValue = value;
  }
  public resetPlugin() {
    this._plugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSources[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomated {
  /**
  * Allows apps have zero live resources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#allow_empty PlatformGitopsApplicationset#allow_empty}
  */
  readonly allowEmpty?: boolean | cdktf.IResolvable;
  /**
  * Whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#prune PlatformGitopsApplicationset#prune}
  */
  readonly prune?: boolean | cdktf.IResolvable;
  /**
  * Whether to revert resources back to their desired state upon modification in the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#self_heal PlatformGitopsApplicationset#self_heal}
  */
  readonly selfHeal?: boolean | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomated): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_empty: cdktf.booleanToTerraform(struct!.allowEmpty),
    prune: cdktf.booleanToTerraform(struct!.prune),
    self_heal: cdktf.booleanToTerraform(struct!.selfHeal),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomated): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_empty: {
      value: cdktf.booleanToHclTerraform(struct!.allowEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prune: {
      value: cdktf.booleanToHclTerraform(struct!.prune),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    self_heal: {
      value: cdktf.booleanToHclTerraform(struct!.selfHeal),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomated | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowEmpty = this._allowEmpty;
    }
    if (this._prune !== undefined) {
      hasAnyValues = true;
      internalValueResult.prune = this._prune;
    }
    if (this._selfHeal !== undefined) {
      hasAnyValues = true;
      internalValueResult.selfHeal = this._selfHeal;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomated | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowEmpty = undefined;
      this._prune = undefined;
      this._selfHeal = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowEmpty = value.allowEmpty;
      this._prune = value.prune;
      this._selfHeal = value.selfHeal;
    }
  }

  // allow_empty - computed: false, optional: true, required: false
  private _allowEmpty?: boolean | cdktf.IResolvable; 
  public get allowEmpty() {
    return this.getBooleanAttribute('allow_empty');
  }
  public set allowEmpty(value: boolean | cdktf.IResolvable) {
    this._allowEmpty = value;
  }
  public resetAllowEmpty() {
    this._allowEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowEmptyInput() {
    return this._allowEmpty;
  }

  // prune - computed: false, optional: true, required: false
  private _prune?: boolean | cdktf.IResolvable; 
  public get prune() {
    return this.getBooleanAttribute('prune');
  }
  public set prune(value: boolean | cdktf.IResolvable) {
    this._prune = value;
  }
  public resetPrune() {
    this._prune = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pruneInput() {
    return this._prune;
  }

  // self_heal - computed: false, optional: true, required: false
  private _selfHeal?: boolean | cdktf.IResolvable; 
  public get selfHeal() {
    return this.getBooleanAttribute('self_heal');
  }
  public set selfHeal(value: boolean | cdktf.IResolvable) {
    this._selfHeal = value;
  }
  public resetSelfHeal() {
    this._selfHeal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selfHealInput() {
    return this._selfHeal;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadata {
  /**
  * Annotations to apply to the namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#annotations PlatformGitopsApplicationset#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Labels to apply to the namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#labels PlatformGitopsApplicationset#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadata | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadata | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoff {
  /**
  * Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. `2m`, `1h`), as a string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#duration PlatformGitopsApplicationset#duration}
  */
  readonly duration?: string;
  /**
  * Factor to multiply the base duration after each failed retry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#factor PlatformGitopsApplicationset#factor}
  */
  readonly factor?: string;
  /**
  * Maximum amount of time allowed for the backoff strategy. Default unit is seconds, but could also be a duration (e.g. `2m`, `1h`), as a string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#max_duration PlatformGitopsApplicationset#max_duration}
  */
  readonly maxDuration?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoff): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
    factor: cdktf.stringToTerraform(struct!.factor),
    max_duration: cdktf.stringToTerraform(struct!.maxDuration),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoff): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    factor: {
      value: cdktf.stringToHclTerraform(struct!.factor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoff | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    if (this._factor !== undefined) {
      hasAnyValues = true;
      internalValueResult.factor = this._factor;
    }
    if (this._maxDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDuration = this._maxDuration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoff | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._duration = undefined;
      this._factor = undefined;
      this._maxDuration = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._duration = value.duration;
      this._factor = value.factor;
      this._maxDuration = value.maxDuration;
    }
  }

  // duration - computed: false, optional: true, required: false
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  public resetDuration() {
    this._duration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }

  // factor - computed: false, optional: true, required: false
  private _factor?: string; 
  public get factor() {
    return this.getStringAttribute('factor');
  }
  public set factor(value: string) {
    this._factor = value;
  }
  public resetFactor() {
    this._factor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get factorInput() {
    return this._factor;
  }

  // max_duration - computed: false, optional: true, required: false
  private _maxDuration?: string; 
  public get maxDuration() {
    return this.getStringAttribute('max_duration');
  }
  public set maxDuration(value: string) {
    this._maxDuration = value;
  }
  public resetMaxDuration() {
    this._maxDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDurationInput() {
    return this._maxDuration;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetry {
  /**
  * Maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#limit PlatformGitopsApplicationset#limit}
  */
  readonly limit?: string;
  /**
  * backoff block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#backoff PlatformGitopsApplicationset#backoff}
  */
  readonly backoff?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoff;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetry): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limit: cdktf.stringToTerraform(struct!.limit),
    backoff: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffToTerraform(struct!.backoff),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetry): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limit: {
      value: cdktf.stringToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    backoff: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffToHclTerraform(struct!.backoff),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetry | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._backoff?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoff = this._backoff?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetry | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._limit = undefined;
      this._backoff.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._limit = value.limit;
      this._backoff.internalValue = value.backoff;
    }
  }

  // limit - computed: false, optional: true, required: false
  private _limit?: string; 
  public get limit() {
    return this.getStringAttribute('limit');
  }
  public set limit(value: string) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // backoff - computed: false, optional: true, required: false
  private _backoff = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoffOutputReference(this, "backoff");
  public get backoff() {
    return this._backoff;
  }
  public putBackoff(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryBackoff) {
    this._backoff.internalValue = value;
  }
  public resetBackoff() {
    this._backoff.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffInput() {
    return this._backoff.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicy {
  /**
  * List of sync options. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sync_options PlatformGitopsApplicationset#sync_options}
  */
  readonly syncOptions?: string[];
  /**
  * automated block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#automated PlatformGitopsApplicationset#automated}
  */
  readonly automated?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomated;
  /**
  * managed_namespace_metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#managed_namespace_metadata PlatformGitopsApplicationset#managed_namespace_metadata}
  */
  readonly managedNamespaceMetadata?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadata;
  /**
  * retry block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#retry PlatformGitopsApplicationset#retry}
  */
  readonly retry?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetry;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sync_options: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.syncOptions),
    automated: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedToTerraform(struct!.automated),
    managed_namespace_metadata: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataToTerraform(struct!.managedNamespaceMetadata),
    retry: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryToTerraform(struct!.retry),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sync_options: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.syncOptions),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    automated: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedToHclTerraform(struct!.automated),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedList",
    },
    managed_namespace_metadata: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataToHclTerraform(struct!.managedNamespaceMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataList",
    },
    retry: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryToHclTerraform(struct!.retry),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._syncOptions !== undefined) {
      hasAnyValues = true;
      internalValueResult.syncOptions = this._syncOptions;
    }
    if (this._automated?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.automated = this._automated?.internalValue;
    }
    if (this._managedNamespaceMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.managedNamespaceMetadata = this._managedNamespaceMetadata?.internalValue;
    }
    if (this._retry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retry = this._retry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._syncOptions = undefined;
      this._automated.internalValue = undefined;
      this._managedNamespaceMetadata.internalValue = undefined;
      this._retry.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._syncOptions = value.syncOptions;
      this._automated.internalValue = value.automated;
      this._managedNamespaceMetadata.internalValue = value.managedNamespaceMetadata;
      this._retry.internalValue = value.retry;
    }
  }

  // sync_options - computed: false, optional: true, required: false
  private _syncOptions?: string[]; 
  public get syncOptions() {
    return this.getListAttribute('sync_options');
  }
  public set syncOptions(value: string[]) {
    this._syncOptions = value;
  }
  public resetSyncOptions() {
    this._syncOptions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syncOptionsInput() {
    return this._syncOptions;
  }

  // automated - computed: false, optional: true, required: false
  private _automated = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomatedOutputReference(this, "automated");
  public get automated() {
    return this._automated;
  }
  public putAutomated(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyAutomated) {
    this._automated.internalValue = value;
  }
  public resetAutomated() {
    this._automated.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automatedInput() {
    return this._automated.internalValue;
  }

  // managed_namespace_metadata - computed: false, optional: true, required: false
  private _managedNamespaceMetadata = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference(this, "managed_namespace_metadata");
  public get managedNamespaceMetadata() {
    return this._managedNamespaceMetadata;
  }
  public putManagedNamespaceMetadata(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyManagedNamespaceMetadata) {
    this._managedNamespaceMetadata.internalValue = value;
  }
  public resetManagedNamespaceMetadata() {
    this._managedNamespaceMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedNamespaceMetadataInput() {
    return this._managedNamespaceMetadata.internalValue;
  }

  // retry - computed: false, optional: true, required: false
  private _retry = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetryOutputReference(this, "retry");
  public get retry() {
    return this._retry;
  }
  public putRetry(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyRetry) {
    this._retry.internalValue = value;
  }
  public resetRetry() {
    this._retry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryInput() {
    return this._retry.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpec {
  /**
  * The project the application belongs to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#project PlatformGitopsApplicationset#project}
  */
  readonly project?: string;
  /**
  * Limits the number of items kept in the application's revision history, which is used for informational purposes as well as for rollbacks to previous versions. This should only be changed in exceptional circumstances. Setting to zero will store no history. This will reduce storage used. Increasing will increase the space used to store the history, so we do not recommend increasing it. Default is 10.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#revision_history_limit PlatformGitopsApplicationset#revision_history_limit}
  */
  readonly revisionHistoryLimit?: string;
  /**
  * destination block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#destination PlatformGitopsApplicationset#destination}
  */
  readonly destination?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestination;
  /**
  * ignore_difference block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_difference PlatformGitopsApplicationset#ignore_difference}
  */
  readonly ignoreDifference?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifference[] | cdktf.IResolvable;
  /**
  * info block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#info PlatformGitopsApplicationset#info}
  */
  readonly info?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfo[] | cdktf.IResolvable;
  /**
  * source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#source PlatformGitopsApplicationset#source}
  */
  readonly source?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSource[] | cdktf.IResolvable;
  /**
  * sources block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sources PlatformGitopsApplicationset#sources}
  */
  readonly sources?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSources[] | cdktf.IResolvable;
  /**
  * sync_policy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sync_policy PlatformGitopsApplicationset#sync_policy}
  */
  readonly syncPolicy?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicy;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpec): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    project: cdktf.stringToTerraform(struct!.project),
    revision_history_limit: cdktf.stringToTerraform(struct!.revisionHistoryLimit),
    destination: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationToTerraform(struct!.destination),
    ignore_difference: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceToTerraform, true)(struct!.ignoreDifference),
    info: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoToTerraform, true)(struct!.info),
    source: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceToTerraform, true)(struct!.source),
    sources: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesToTerraform, true)(struct!.sources),
    sync_policy: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyToTerraform(struct!.syncPolicy),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpec): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    revision_history_limit: {
      value: cdktf.stringToHclTerraform(struct!.revisionHistoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    destination: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationToHclTerraform(struct!.destination),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationList",
    },
    ignore_difference: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceToHclTerraform, true)(struct!.ignoreDifference),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceList",
    },
    info: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoToHclTerraform, true)(struct!.info),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoList",
    },
    source: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceToHclTerraform, true)(struct!.source),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceList",
    },
    sources: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesToHclTerraform, true)(struct!.sources),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesList",
    },
    sync_policy: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyToHclTerraform(struct!.syncPolicy),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpec | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    if (this._revisionHistoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.revisionHistoryLimit = this._revisionHistoryLimit;
    }
    if (this._destination?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.destination = this._destination?.internalValue;
    }
    if (this._ignoreDifference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreDifference = this._ignoreDifference?.internalValue;
    }
    if (this._info?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.info = this._info?.internalValue;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._sources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sources = this._sources?.internalValue;
    }
    if (this._syncPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.syncPolicy = this._syncPolicy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpec | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._project = undefined;
      this._revisionHistoryLimit = undefined;
      this._destination.internalValue = undefined;
      this._ignoreDifference.internalValue = undefined;
      this._info.internalValue = undefined;
      this._source.internalValue = undefined;
      this._sources.internalValue = undefined;
      this._syncPolicy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._project = value.project;
      this._revisionHistoryLimit = value.revisionHistoryLimit;
      this._destination.internalValue = value.destination;
      this._ignoreDifference.internalValue = value.ignoreDifference;
      this._info.internalValue = value.info;
      this._source.internalValue = value.source;
      this._sources.internalValue = value.sources;
      this._syncPolicy.internalValue = value.syncPolicy;
    }
  }

  // project - computed: false, optional: true, required: false
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  public resetProject() {
    this._project = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }

  // revision_history_limit - computed: true, optional: true, required: false
  private _revisionHistoryLimit?: string; 
  public get revisionHistoryLimit() {
    return this.getStringAttribute('revision_history_limit');
  }
  public set revisionHistoryLimit(value: string) {
    this._revisionHistoryLimit = value;
  }
  public resetRevisionHistoryLimit() {
    this._revisionHistoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get revisionHistoryLimitInput() {
    return this._revisionHistoryLimit;
  }

  // destination - computed: false, optional: true, required: false
  private _destination = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestinationOutputReference(this, "destination");
  public get destination() {
    return this._destination;
  }
  public putDestination(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecDestination) {
    this._destination.internalValue = value;
  }
  public resetDestination() {
    this._destination.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationInput() {
    return this._destination.internalValue;
  }

  // ignore_difference - computed: false, optional: true, required: false
  private _ignoreDifference = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifferenceList(this, "ignore_difference", false);
  public get ignoreDifference() {
    return this._ignoreDifference;
  }
  public putIgnoreDifference(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecIgnoreDifference[] | cdktf.IResolvable) {
    this._ignoreDifference.internalValue = value;
  }
  public resetIgnoreDifference() {
    this._ignoreDifference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreDifferenceInput() {
    return this._ignoreDifference.internalValue;
  }

  // info - computed: false, optional: true, required: false
  private _info = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfoList(this, "info", false);
  public get info() {
    return this._info;
  }
  public putInfo(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecInfo[] | cdktf.IResolvable) {
    this._info.internalValue = value;
  }
  public resetInfo() {
    this._info.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get infoInput() {
    return this._info.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourceList(this, "source", false);
  public get source() {
    return this._source;
  }
  public putSource(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSource[] | cdktf.IResolvable) {
    this._source.internalValue = value;
  }
  public resetSource() {
    this._source.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // sources - computed: false, optional: true, required: false
  private _sources = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSourcesList(this, "sources", false);
  public get sources() {
    return this._sources;
  }
  public putSources(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSources[] | cdktf.IResolvable) {
    this._sources.internalValue = value;
  }
  public resetSources() {
    this._sources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcesInput() {
    return this._sources.internalValue;
  }

  // sync_policy - computed: false, optional: true, required: false
  private _syncPolicy = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicyOutputReference(this, "sync_policy");
  public get syncPolicy() {
    return this._syncPolicy;
  }
  public putSyncPolicy(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecSyncPolicy) {
    this._syncPolicy.internalValue = value;
  }
  public resetSyncPolicy() {
    this._syncPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syncPolicyInput() {
    return this._syncPolicy.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplate {
  /**
  * metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#metadata PlatformGitopsApplicationset#metadata}
  */
  readonly metadata?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadata;
  /**
  * spec block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#spec PlatformGitopsApplicationset#spec}
  */
  readonly spec?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpec;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataToTerraform(struct!.metadata),
    spec: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecToTerraform(struct!.spec),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataList",
    },
    spec: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplate | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplate | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProvider {
  /**
  * Which protocol to use for the SCM URL. Default is provider-specific but ssh if possible. Not all providers necessarily support all protocols.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#clone_protocol PlatformGitopsApplicationset#clone_protocol}
  */
  readonly cloneProtocol?: string;
  /**
  * How often to check for changes (in seconds). Default: 3min.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#requeue_after_seconds PlatformGitopsApplicationset#requeue_after_seconds}
  */
  readonly requeueAfterSeconds?: string;
  /**
  * azure_devops block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#azure_devops PlatformGitopsApplicationset#azure_devops}
  */
  readonly azureDevops?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevops;
  /**
  * bitbucket_cloud block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#bitbucket_cloud PlatformGitopsApplicationset#bitbucket_cloud}
  */
  readonly bitbucketCloud?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloud;
  /**
  * bitbucket_server block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#bitbucket_server PlatformGitopsApplicationset#bitbucket_server}
  */
  readonly bitbucketServer?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServer;
  /**
  * filter block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#filter PlatformGitopsApplicationset#filter}
  */
  readonly filter?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilter[] | cdktf.IResolvable;
  /**
  * gitea block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#gitea PlatformGitopsApplicationset#gitea}
  */
  readonly gitea?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitea;
  /**
  * github block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#github PlatformGitopsApplicationset#github}
  */
  readonly github?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithub;
  /**
  * gitlab block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#gitlab PlatformGitopsApplicationset#gitlab}
  */
  readonly gitlab?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlab;
  /**
  * template block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#template PlatformGitopsApplicationset#template}
  */
  readonly template?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplate;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    clone_protocol: cdktf.stringToTerraform(struct!.cloneProtocol),
    requeue_after_seconds: cdktf.stringToTerraform(struct!.requeueAfterSeconds),
    azure_devops: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsToTerraform(struct!.azureDevops),
    bitbucket_cloud: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudToTerraform(struct!.bitbucketCloud),
    bitbucket_server: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerToTerraform(struct!.bitbucketServer),
    filter: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterToTerraform, true)(struct!.filter),
    gitea: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaToTerraform(struct!.gitea),
    github: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubToTerraform(struct!.github),
    gitlab: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabToTerraform(struct!.gitlab),
    template: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateToTerraform(struct!.template),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    clone_protocol: {
      value: cdktf.stringToHclTerraform(struct!.cloneProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    requeue_after_seconds: {
      value: cdktf.stringToHclTerraform(struct!.requeueAfterSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    azure_devops: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsToHclTerraform(struct!.azureDevops),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsList",
    },
    bitbucket_cloud: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudToHclTerraform(struct!.bitbucketCloud),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudList",
    },
    bitbucket_server: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerToHclTerraform(struct!.bitbucketServer),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerList",
    },
    filter: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterToHclTerraform, true)(struct!.filter),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterList",
    },
    gitea: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaToHclTerraform(struct!.gitea),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaList",
    },
    github: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubToHclTerraform(struct!.github),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubList",
    },
    gitlab: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabToHclTerraform(struct!.gitlab),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabList",
    },
    template: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cloneProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloneProtocol = this._cloneProtocol;
    }
    if (this._requeueAfterSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.requeueAfterSeconds = this._requeueAfterSeconds;
    }
    if (this._azureDevops?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureDevops = this._azureDevops?.internalValue;
    }
    if (this._bitbucketCloud?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bitbucketCloud = this._bitbucketCloud?.internalValue;
    }
    if (this._bitbucketServer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bitbucketServer = this._bitbucketServer?.internalValue;
    }
    if (this._filter?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter?.internalValue;
    }
    if (this._gitea?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitea = this._gitea?.internalValue;
    }
    if (this._github?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.github = this._github?.internalValue;
    }
    if (this._gitlab?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitlab = this._gitlab?.internalValue;
    }
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cloneProtocol = undefined;
      this._requeueAfterSeconds = undefined;
      this._azureDevops.internalValue = undefined;
      this._bitbucketCloud.internalValue = undefined;
      this._bitbucketServer.internalValue = undefined;
      this._filter.internalValue = undefined;
      this._gitea.internalValue = undefined;
      this._github.internalValue = undefined;
      this._gitlab.internalValue = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cloneProtocol = value.cloneProtocol;
      this._requeueAfterSeconds = value.requeueAfterSeconds;
      this._azureDevops.internalValue = value.azureDevops;
      this._bitbucketCloud.internalValue = value.bitbucketCloud;
      this._bitbucketServer.internalValue = value.bitbucketServer;
      this._filter.internalValue = value.filter;
      this._gitea.internalValue = value.gitea;
      this._github.internalValue = value.github;
      this._gitlab.internalValue = value.gitlab;
      this._template.internalValue = value.template;
    }
  }

  // clone_protocol - computed: false, optional: true, required: false
  private _cloneProtocol?: string; 
  public get cloneProtocol() {
    return this.getStringAttribute('clone_protocol');
  }
  public set cloneProtocol(value: string) {
    this._cloneProtocol = value;
  }
  public resetCloneProtocol() {
    this._cloneProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloneProtocolInput() {
    return this._cloneProtocol;
  }

  // requeue_after_seconds - computed: false, optional: true, required: false
  private _requeueAfterSeconds?: string; 
  public get requeueAfterSeconds() {
    return this.getStringAttribute('requeue_after_seconds');
  }
  public set requeueAfterSeconds(value: string) {
    this._requeueAfterSeconds = value;
  }
  public resetRequeueAfterSeconds() {
    this._requeueAfterSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requeueAfterSecondsInput() {
    return this._requeueAfterSeconds;
  }

  // azure_devops - computed: false, optional: true, required: false
  private _azureDevops = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevopsOutputReference(this, "azure_devops");
  public get azureDevops() {
    return this._azureDevops;
  }
  public putAzureDevops(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderAzureDevops) {
    this._azureDevops.internalValue = value;
  }
  public resetAzureDevops() {
    this._azureDevops.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureDevopsInput() {
    return this._azureDevops.internalValue;
  }

  // bitbucket_cloud - computed: false, optional: true, required: false
  private _bitbucketCloud = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloudOutputReference(this, "bitbucket_cloud");
  public get bitbucketCloud() {
    return this._bitbucketCloud;
  }
  public putBitbucketCloud(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketCloud) {
    this._bitbucketCloud.internalValue = value;
  }
  public resetBitbucketCloud() {
    this._bitbucketCloud.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bitbucketCloudInput() {
    return this._bitbucketCloud.internalValue;
  }

  // bitbucket_server - computed: false, optional: true, required: false
  private _bitbucketServer = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServerOutputReference(this, "bitbucket_server");
  public get bitbucketServer() {
    return this._bitbucketServer;
  }
  public putBitbucketServer(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderBitbucketServer) {
    this._bitbucketServer.internalValue = value;
  }
  public resetBitbucketServer() {
    this._bitbucketServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bitbucketServerInput() {
    return this._bitbucketServer.internalValue;
  }

  // filter - computed: false, optional: true, required: false
  private _filter = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilterList(this, "filter", false);
  public get filter() {
    return this._filter;
  }
  public putFilter(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderFilter[] | cdktf.IResolvable) {
    this._filter.internalValue = value;
  }
  public resetFilter() {
    this._filter.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter.internalValue;
  }

  // gitea - computed: false, optional: true, required: false
  private _gitea = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGiteaOutputReference(this, "gitea");
  public get gitea() {
    return this._gitea;
  }
  public putGitea(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitea) {
    this._gitea.internalValue = value;
  }
  public resetGitea() {
    this._gitea.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get giteaInput() {
    return this._gitea.internalValue;
  }

  // github - computed: false, optional: true, required: false
  private _github = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithubOutputReference(this, "github");
  public get github() {
    return this._github;
  }
  public putGithub(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGithub) {
    this._github.internalValue = value;
  }
  public resetGithub() {
    this._github.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get githubInput() {
    return this._github.internalValue;
  }

  // gitlab - computed: false, optional: true, required: false
  private _gitlab = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlabOutputReference(this, "gitlab");
  public get gitlab() {
    return this._gitlab;
  }
  public putGitlab(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderGitlab) {
    this._gitlab.internalValue = value;
  }
  public resetGitlab() {
    this._gitlab.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitlabInput() {
    return this._gitlab.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderTemplate) {
    this._template.internalValue = value;
  }
  public resetTemplate() {
    this._template.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProvider[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressions {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#key PlatformGitopsApplicationset#key}
  */
  readonly key?: string;
  /**
  * A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#operator PlatformGitopsApplicationset#operator}
  */
  readonly operator?: string;
  /**
  * An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values PlatformGitopsApplicationset#values}
  */
  readonly values?: string[];
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelector {
  /**
  * A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#match_labels PlatformGitopsApplicationset#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#match_expressions PlatformGitopsApplicationset#match_expressions}
  */
  readonly matchExpressions?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressions[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorSelectorToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
    match_expressions: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorSelectorToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorOutputReference | PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelector): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelector | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelector | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._matchLabels = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._matchLabels = value.matchLabels;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecGenerator {
  /**
  * cluster_decision_resource block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#cluster_decision_resource PlatformGitopsApplicationset#cluster_decision_resource}
  */
  readonly clusterDecisionResource?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResource[] | cdktf.IResolvable;
  /**
  * clusters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#clusters PlatformGitopsApplicationset#clusters}
  */
  readonly clusters?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusters[] | cdktf.IResolvable;
  /**
  * git block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#git PlatformGitopsApplicationset#git}
  */
  readonly git?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorGit[] | cdktf.IResolvable;
  /**
  * list block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#list PlatformGitopsApplicationset#list}
  */
  readonly list?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorListStruct[] | cdktf.IResolvable;
  /**
  * matrix block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#matrix PlatformGitopsApplicationset#matrix}
  */
  readonly matrix?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorMatrix[] | cdktf.IResolvable;
  /**
  * merge block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#merge PlatformGitopsApplicationset#merge}
  */
  readonly merge?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorMerge[] | cdktf.IResolvable;
  /**
  * pull_request block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#pull_request PlatformGitopsApplicationset#pull_request}
  */
  readonly pullRequest?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequest[] | cdktf.IResolvable;
  /**
  * scm_provider block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#scm_provider PlatformGitopsApplicationset#scm_provider}
  */
  readonly scmProvider?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProvider[] | cdktf.IResolvable;
  /**
  * selector block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#selector PlatformGitopsApplicationset#selector}
  */
  readonly selector?: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelector;
}

export function platformGitopsApplicationsetApplicationsetSpecGeneratorToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGenerator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_decision_resource: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResourceToTerraform, true)(struct!.clusterDecisionResource),
    clusters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorClustersToTerraform, true)(struct!.clusters),
    git: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorGitToTerraform, true)(struct!.git),
    list: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorListStructToTerraform, true)(struct!.list),
    matrix: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorMatrixToTerraform, true)(struct!.matrix),
    merge: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorMergeToTerraform, true)(struct!.merge),
    pull_request: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestToTerraform, true)(struct!.pullRequest),
    scm_provider: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderToTerraform, true)(struct!.scmProvider),
    selector: platformGitopsApplicationsetApplicationsetSpecGeneratorSelectorToTerraform(struct!.selector),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecGeneratorToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecGenerator | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_decision_resource: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResourceToHclTerraform, true)(struct!.clusterDecisionResource),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResourceList",
    },
    clusters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorClustersToHclTerraform, true)(struct!.clusters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorClustersList",
    },
    git: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorGitToHclTerraform, true)(struct!.git),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorGitList",
    },
    list: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorListStructToHclTerraform, true)(struct!.list),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorListStructList",
    },
    matrix: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorMatrixToHclTerraform, true)(struct!.matrix),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorMatrixList",
    },
    merge: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorMergeToHclTerraform, true)(struct!.merge),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorMergeList",
    },
    pull_request: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestToHclTerraform, true)(struct!.pullRequest),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestList",
    },
    scm_provider: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderToHclTerraform, true)(struct!.scmProvider),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderList",
    },
    selector: {
      value: platformGitopsApplicationsetApplicationsetSpecGeneratorSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecGenerator | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterDecisionResource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterDecisionResource = this._clusterDecisionResource?.internalValue;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._git?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.git = this._git?.internalValue;
    }
    if (this._list?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.list = this._list?.internalValue;
    }
    if (this._matrix?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matrix = this._matrix?.internalValue;
    }
    if (this._merge?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.merge = this._merge?.internalValue;
    }
    if (this._pullRequest?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pullRequest = this._pullRequest?.internalValue;
    }
    if (this._scmProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.scmProvider = this._scmProvider?.internalValue;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecGenerator | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterDecisionResource.internalValue = undefined;
      this._clusters.internalValue = undefined;
      this._git.internalValue = undefined;
      this._list.internalValue = undefined;
      this._matrix.internalValue = undefined;
      this._merge.internalValue = undefined;
      this._pullRequest.internalValue = undefined;
      this._scmProvider.internalValue = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterDecisionResource.internalValue = value.clusterDecisionResource;
      this._clusters.internalValue = value.clusters;
      this._git.internalValue = value.git;
      this._list.internalValue = value.list;
      this._matrix.internalValue = value.matrix;
      this._merge.internalValue = value.merge;
      this._pullRequest.internalValue = value.pullRequest;
      this._scmProvider.internalValue = value.scmProvider;
      this._selector.internalValue = value.selector;
    }
  }

  // cluster_decision_resource - computed: false, optional: true, required: false
  private _clusterDecisionResource = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResourceList(this, "cluster_decision_resource", false);
  public get clusterDecisionResource() {
    return this._clusterDecisionResource;
  }
  public putClusterDecisionResource(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusterDecisionResource[] | cdktf.IResolvable) {
    this._clusterDecisionResource.internalValue = value;
  }
  public resetClusterDecisionResource() {
    this._clusterDecisionResource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterDecisionResourceInput() {
    return this._clusterDecisionResource.internalValue;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorClustersList(this, "clusters", false);
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorClusters[] | cdktf.IResolvable) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // git - computed: false, optional: true, required: false
  private _git = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorGitList(this, "git", false);
  public get git() {
    return this._git;
  }
  public putGit(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorGit[] | cdktf.IResolvable) {
    this._git.internalValue = value;
  }
  public resetGit() {
    this._git.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitInput() {
    return this._git.internalValue;
  }

  // list - computed: false, optional: true, required: false
  private _list = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorListStructList(this, "list", false);
  public get list() {
    return this._list;
  }
  public putList(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorListStruct[] | cdktf.IResolvable) {
    this._list.internalValue = value;
  }
  public resetList() {
    this._list.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get listInput() {
    return this._list.internalValue;
  }

  // matrix - computed: false, optional: true, required: false
  private _matrix = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorMatrixList(this, "matrix", false);
  public get matrix() {
    return this._matrix;
  }
  public putMatrix(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorMatrix[] | cdktf.IResolvable) {
    this._matrix.internalValue = value;
  }
  public resetMatrix() {
    this._matrix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matrixInput() {
    return this._matrix.internalValue;
  }

  // merge - computed: false, optional: true, required: false
  private _merge = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorMergeList(this, "merge", false);
  public get merge() {
    return this._merge;
  }
  public putMerge(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorMerge[] | cdktf.IResolvable) {
    this._merge.internalValue = value;
  }
  public resetMerge() {
    this._merge.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mergeInput() {
    return this._merge.internalValue;
  }

  // pull_request - computed: false, optional: true, required: false
  private _pullRequest = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequestList(this, "pull_request", false);
  public get pullRequest() {
    return this._pullRequest;
  }
  public putPullRequest(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorPullRequest[] | cdktf.IResolvable) {
    this._pullRequest.internalValue = value;
  }
  public resetPullRequest() {
    this._pullRequest.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pullRequestInput() {
    return this._pullRequest.internalValue;
  }

  // scm_provider - computed: false, optional: true, required: false
  private _scmProvider = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProviderList(this, "scm_provider", false);
  public get scmProvider() {
    return this._scmProvider;
  }
  public putScmProvider(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorScmProvider[] | cdktf.IResolvable) {
    this._scmProvider.internalValue = value;
  }
  public resetScmProvider() {
    this._scmProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scmProviderInput() {
    return this._scmProvider.internalValue;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: PlatformGitopsApplicationsetApplicationsetSpecGeneratorSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecGeneratorList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecGenerator[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecGeneratorOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecGeneratorOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferences {
  /**
  * jq path to ignore differences
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#jq_path_expressions PlatformGitopsApplicationset#jq_path_expressions}
  */
  readonly jqPathExpressions?: string[];
  /**
  * Json pointers to ignore differences
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#json_pointers PlatformGitopsApplicationset#json_pointers}
  */
  readonly jsonPointers?: string[];
  /**
  * name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferences | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jq_path_expressions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.jqPathExpressions),
    json_pointers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.jsonPointers),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferences | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jq_path_expressions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.jqPathExpressions),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    json_pointers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.jsonPointers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferences | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jqPathExpressions !== undefined) {
      hasAnyValues = true;
      internalValueResult.jqPathExpressions = this._jqPathExpressions;
    }
    if (this._jsonPointers !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPointers = this._jsonPointers;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferences | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jqPathExpressions = undefined;
      this._jsonPointers = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jqPathExpressions = value.jqPathExpressions;
      this._jsonPointers = value.jsonPointers;
      this._name = value.name;
    }
  }

  // jq_path_expressions - computed: false, optional: true, required: false
  private _jqPathExpressions?: string[]; 
  public get jqPathExpressions() {
    return this.getListAttribute('jq_path_expressions');
  }
  public set jqPathExpressions(value: string[]) {
    this._jqPathExpressions = value;
  }
  public resetJqPathExpressions() {
    this._jqPathExpressions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jqPathExpressionsInput() {
    return this._jqPathExpressions;
  }

  // json_pointers - computed: false, optional: true, required: false
  private _jsonPointers?: string[]; 
  public get jsonPointers() {
    return this.getListAttribute('json_pointers');
  }
  public set jsonPointers(value: string[]) {
    this._jsonPointers = value;
  }
  public resetJsonPointers() {
    this._jsonPointers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPointersInput() {
    return this._jsonPointers;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferences[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressions {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#key PlatformGitopsApplicationset#key}
  */
  readonly key?: string;
  /**
  * A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#operator PlatformGitopsApplicationset#operator}
  */
  readonly operator?: string;
  /**
  * An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values PlatformGitopsApplicationset#values}
  */
  readonly values?: string[];
}

export function platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStep {
  /**
  * Maximum number of simultaneous Application updates in a group. Supports both integer and percentage string values (rounds down, but floored at 1 Application for >0%). Default is 100%, unbounded.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#max_update PlatformGitopsApplicationset#max_update}
  */
  readonly maxUpdate?: string;
  /**
  * match_expressions block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#match_expressions PlatformGitopsApplicationset#match_expressions}
  */
  readonly matchExpressions?: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressions[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_update: cdktf.stringToTerraform(struct!.maxUpdate),
    match_expressions: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsToTerraform, true)(struct!.matchExpressions),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_update: {
      value: cdktf.stringToHclTerraform(struct!.maxUpdate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match_expressions: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsToHclTerraform, true)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStep | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxUpdate !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxUpdate = this._maxUpdate;
    }
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStep | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxUpdate = undefined;
      this._matchExpressions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxUpdate = value.maxUpdate;
      this._matchExpressions.internalValue = value.matchExpressions;
    }
  }

  // max_update - computed: false, optional: true, required: false
  private _maxUpdate?: string; 
  public get maxUpdate() {
    return this.getStringAttribute('max_update');
  }
  public set maxUpdate(value: string) {
    this._maxUpdate = value;
  }
  public resetMaxUpdate() {
    this._maxUpdate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxUpdateInput() {
    return this._maxUpdate;
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStep[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSync {
  /**
  * step block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#step PlatformGitopsApplicationset#step}
  */
  readonly step: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStep[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSync | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    step: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepToTerraform, true)(struct!.step),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSync | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    step: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepToHclTerraform, true)(struct!.step),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSync | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._step?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.step = this._step?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSync | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._step.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._step.internalValue = value.step;
    }
  }

  // step - computed: false, optional: false, required: true
  private _step = new PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStepList(this, "step", false);
  public get step() {
    return this._step;
  }
  public putStep(value: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncStep[] | cdktf.IResolvable) {
    this._step.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get stepInput() {
    return this._step.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSync[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecStrategy {
  /**
  * Type of progressive sync.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#type PlatformGitopsApplicationset#type}
  */
  readonly type: string;
  /**
  * rolling_sync block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#rolling_sync PlatformGitopsApplicationset#rolling_sync}
  */
  readonly rollingSync?: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSync[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecStrategyToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecStrategyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    rolling_sync: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncToTerraform, true)(struct!.rollingSync),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecStrategyToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecStrategyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecStrategy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rolling_sync: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncToHclTerraform, true)(struct!.rollingSync),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecStrategyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecStrategy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._rollingSync?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rollingSync = this._rollingSync?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecStrategy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._type = undefined;
      this._rollingSync.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._type = value.type;
      this._rollingSync.internalValue = value.rollingSync;
    }
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // rolling_sync - computed: false, optional: true, required: false
  private _rollingSync = new PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSyncList(this, "rolling_sync", false);
  public get rollingSync() {
    return this._rollingSync;
  }
  public putRollingSync(value: PlatformGitopsApplicationsetApplicationsetSpecStrategyRollingSync[] | cdktf.IResolvable) {
    this._rollingSync.internalValue = value;
  }
  public resetRollingSync() {
    this._rollingSync.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rollingSyncInput() {
    return this._rollingSync.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecSyncPolicy {
  /**
  * Represents the policy applied on the generated applications. Possible values are create-only, create-update, create-delete, and sync.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#applications_sync PlatformGitopsApplicationset#applications_sync}
  */
  readonly applicationsSync?: string;
  /**
  * Label selector used to narrow the scope of targeted clusters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#preserve_resources_on_deletion PlatformGitopsApplicationset#preserve_resources_on_deletion}
  */
  readonly preserveResourcesOnDeletion?: boolean | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecSyncPolicyToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecSyncPolicyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecSyncPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    applications_sync: cdktf.stringToTerraform(struct!.applicationsSync),
    preserve_resources_on_deletion: cdktf.booleanToTerraform(struct!.preserveResourcesOnDeletion),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecSyncPolicyToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecSyncPolicyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecSyncPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    applications_sync: {
      value: cdktf.stringToHclTerraform(struct!.applicationsSync),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    preserve_resources_on_deletion: {
      value: cdktf.booleanToHclTerraform(struct!.preserveResourcesOnDeletion),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecSyncPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecSyncPolicy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._applicationsSync !== undefined) {
      hasAnyValues = true;
      internalValueResult.applicationsSync = this._applicationsSync;
    }
    if (this._preserveResourcesOnDeletion !== undefined) {
      hasAnyValues = true;
      internalValueResult.preserveResourcesOnDeletion = this._preserveResourcesOnDeletion;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecSyncPolicy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._applicationsSync = undefined;
      this._preserveResourcesOnDeletion = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._applicationsSync = value.applicationsSync;
      this._preserveResourcesOnDeletion = value.preserveResourcesOnDeletion;
    }
  }

  // applications_sync - computed: false, optional: true, required: false
  private _applicationsSync?: string; 
  public get applicationsSync() {
    return this.getStringAttribute('applications_sync');
  }
  public set applicationsSync(value: string) {
    this._applicationsSync = value;
  }
  public resetApplicationsSync() {
    this._applicationsSync = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applicationsSyncInput() {
    return this._applicationsSync;
  }

  // preserve_resources_on_deletion - computed: false, optional: true, required: false
  private _preserveResourcesOnDeletion?: boolean | cdktf.IResolvable; 
  public get preserveResourcesOnDeletion() {
    return this.getBooleanAttribute('preserve_resources_on_deletion');
  }
  public set preserveResourcesOnDeletion(value: boolean | cdktf.IResolvable) {
    this._preserveResourcesOnDeletion = value;
  }
  public resetPreserveResourcesOnDeletion() {
    this._preserveResourcesOnDeletion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preserveResourcesOnDeletionInput() {
    return this._preserveResourcesOnDeletion;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadata {
  /**
  * An unstructured key value map that may be used to store arbitrary metadata for the resulting Application.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#annotations PlatformGitopsApplicationset#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * List of finalizers to apply to the resulting Application.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#finalizers PlatformGitopsApplicationset#finalizers}
  */
  readonly finalizers?: string[];
  /**
  * Map of string keys and values that can be used to organize and categorize (scope and select) the resulting Application.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#labels PlatformGitopsApplicationset#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Name of the resulting Application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name: string;
  /**
  * Namespace of the resulting Application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#namespace PlatformGitopsApplicationset#namespace}
  */
  readonly namespace?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateMetadataToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    finalizers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.finalizers),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateMetadataToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    finalizers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.finalizers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadata | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._finalizers !== undefined) {
      hasAnyValues = true;
      internalValueResult.finalizers = this._finalizers;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadata | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._annotations = undefined;
      this._finalizers = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._annotations = value.annotations;
      this._finalizers = value.finalizers;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // finalizers - computed: false, optional: true, required: false
  private _finalizers?: string[]; 
  public get finalizers() {
    return this.getListAttribute('finalizers');
  }
  public set finalizers(value: string[]) {
    this._finalizers = value;
  }
  public resetFinalizers() {
    this._finalizers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get finalizersInput() {
    return this._finalizers;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestination {
  /**
  * Name of the target cluster. Can be used instead of `server`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Target namespace for the application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#namespace PlatformGitopsApplicationset#namespace}
  */
  readonly namespace?: string;
  /**
  * URL of the target cluster and must be set to the Kubernetes control plane API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#server PlatformGitopsApplicationset#server}
  */
  readonly server?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestination): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    server: cdktf.stringToTerraform(struct!.server),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestination): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server: {
      value: cdktf.stringToHclTerraform(struct!.server),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestination | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._server !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestination | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._namespace = undefined;
      this._server = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._namespace = value.namespace;
      this._server = value.server;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // server - computed: false, optional: true, required: false
  private _server?: string; 
  public get server() {
    return this.getStringAttribute('server');
  }
  public set server(value: string) {
    this._server = value;
  }
  public resetServer() {
    this._server = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifference {
  /**
  * The Kubernetes resource Group to match for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#group PlatformGitopsApplicationset#group}
  */
  readonly group?: string;
  /**
  * List of JQ path expression strings targeting the field(s) to ignore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#jq_path_expressions PlatformGitopsApplicationset#jq_path_expressions}
  */
  readonly jqPathExpressions?: string[];
  /**
  * List of JSONPaths strings targeting the field(s) to ignore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#json_pointers PlatformGitopsApplicationset#json_pointers}
  */
  readonly jsonPointers?: string[];
  /**
  * The Kubernetes resource Kind to match for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#kind PlatformGitopsApplicationset#kind}
  */
  readonly kind?: string;
  /**
  * The Kubernetes resource Name to match for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * The Kubernetes resource Namespace to match for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#namespace PlatformGitopsApplicationset#namespace}
  */
  readonly namespace?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group: cdktf.stringToTerraform(struct!.group),
    jq_path_expressions: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.jqPathExpressions),
    json_pointers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.jsonPointers),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jq_path_expressions: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.jqPathExpressions),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    json_pointers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.jsonPointers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._jqPathExpressions !== undefined) {
      hasAnyValues = true;
      internalValueResult.jqPathExpressions = this._jqPathExpressions;
    }
    if (this._jsonPointers !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPointers = this._jsonPointers;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._group = undefined;
      this._jqPathExpressions = undefined;
      this._jsonPointers = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._group = value.group;
      this._jqPathExpressions = value.jqPathExpressions;
      this._jsonPointers = value.jsonPointers;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // jq_path_expressions - computed: false, optional: true, required: false
  private _jqPathExpressions?: string[]; 
  public get jqPathExpressions() {
    return this.getListAttribute('jq_path_expressions');
  }
  public set jqPathExpressions(value: string[]) {
    this._jqPathExpressions = value;
  }
  public resetJqPathExpressions() {
    this._jqPathExpressions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jqPathExpressionsInput() {
    return this._jqPathExpressions;
  }

  // json_pointers - computed: false, optional: true, required: false
  private _jsonPointers?: string[]; 
  public get jsonPointers() {
    return this.getListAttribute('json_pointers');
  }
  public set jsonPointers(value: string[]) {
    this._jsonPointers = value;
  }
  public resetJsonPointers() {
    this._jsonPointers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPointersInput() {
    return this._jsonPointers;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifference[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfo {
  /**
  * Name of the information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfo[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVar {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVar | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVar | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVar[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlas {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlas | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlas | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlas[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnet {
  /**
  * Additional library search dirs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#libs PlatformGitopsApplicationset#libs}
  */
  readonly libs?: string[];
  /**
  * ext_var block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ext_var PlatformGitopsApplicationset#ext_var}
  */
  readonly extVar?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVar[] | cdktf.IResolvable;
  /**
  * tlas block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#tlas PlatformGitopsApplicationset#tlas}
  */
  readonly tlas?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlas[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    libs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.libs),
    ext_var: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarToTerraform, true)(struct!.extVar),
    tlas: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasToTerraform, true)(struct!.tlas),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    libs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.libs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ext_var: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarToHclTerraform, true)(struct!.extVar),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarList",
    },
    tlas: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasToHclTerraform, true)(struct!.tlas),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._libs !== undefined) {
      hasAnyValues = true;
      internalValueResult.libs = this._libs;
    }
    if (this._extVar?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extVar = this._extVar?.internalValue;
    }
    if (this._tlas?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlas = this._tlas?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._libs = undefined;
      this._extVar.internalValue = undefined;
      this._tlas.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._libs = value.libs;
      this._extVar.internalValue = value.extVar;
      this._tlas.internalValue = value.tlas;
    }
  }

  // libs - computed: false, optional: true, required: false
  private _libs?: string[]; 
  public get libs() {
    return this.getListAttribute('libs');
  }
  public set libs(value: string[]) {
    this._libs = value;
  }
  public resetLibs() {
    this._libs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get libsInput() {
    return this._libs;
  }

  // ext_var - computed: false, optional: true, required: false
  private _extVar = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVarList(this, "ext_var", false);
  public get extVar() {
    return this._extVar;
  }
  public putExtVar(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetExtVar[] | cdktf.IResolvable) {
    this._extVar.internalValue = value;
  }
  public resetExtVar() {
    this._extVar.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extVarInput() {
    return this._extVar.internalValue;
  }

  // tlas - computed: false, optional: true, required: false
  private _tlas = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlasList(this, "tlas", false);
  public get tlas() {
    return this._tlas;
  }
  public putTlas(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetTlas[] | cdktf.IResolvable) {
    this._tlas.internalValue = value;
  }
  public resetTlas() {
    this._tlas.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlasInput() {
    return this._tlas.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectory {
  /**
  * Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation. This takes precedence over the `include` field. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{config.yaml,env-use2/*}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#exclude PlatformGitopsApplicationset#exclude}
  */
  readonly exclude?: string;
  /**
  * Glob pattern to match paths against that should be explicitly included during manifest generation. If this field is set, only matching manifests will be included. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{*.yml,*.yaml}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#include PlatformGitopsApplicationset#include}
  */
  readonly include?: string;
  /**
  * Whether to scan a directory recursively for manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#recurse PlatformGitopsApplicationset#recurse}
  */
  readonly recurse?: boolean | cdktf.IResolvable;
  /**
  * jsonnet block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#jsonnet PlatformGitopsApplicationset#jsonnet}
  */
  readonly jsonnet?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnet;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exclude: cdktf.stringToTerraform(struct!.exclude),
    include: cdktf.stringToTerraform(struct!.include),
    recurse: cdktf.booleanToTerraform(struct!.recurse),
    jsonnet: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetToTerraform(struct!.jsonnet),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exclude: {
      value: cdktf.stringToHclTerraform(struct!.exclude),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include: {
      value: cdktf.stringToHclTerraform(struct!.include),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    recurse: {
      value: cdktf.booleanToHclTerraform(struct!.recurse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    jsonnet: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetToHclTerraform(struct!.jsonnet),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectory | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exclude !== undefined) {
      hasAnyValues = true;
      internalValueResult.exclude = this._exclude;
    }
    if (this._include !== undefined) {
      hasAnyValues = true;
      internalValueResult.include = this._include;
    }
    if (this._recurse !== undefined) {
      hasAnyValues = true;
      internalValueResult.recurse = this._recurse;
    }
    if (this._jsonnet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonnet = this._jsonnet?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectory | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._exclude = undefined;
      this._include = undefined;
      this._recurse = undefined;
      this._jsonnet.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._exclude = value.exclude;
      this._include = value.include;
      this._recurse = value.recurse;
      this._jsonnet.internalValue = value.jsonnet;
    }
  }

  // exclude - computed: false, optional: true, required: false
  private _exclude?: string; 
  public get exclude() {
    return this.getStringAttribute('exclude');
  }
  public set exclude(value: string) {
    this._exclude = value;
  }
  public resetExclude() {
    this._exclude = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeInput() {
    return this._exclude;
  }

  // include - computed: false, optional: true, required: false
  private _include?: string; 
  public get include() {
    return this.getStringAttribute('include');
  }
  public set include(value: string) {
    this._include = value;
  }
  public resetInclude() {
    this._include = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeInput() {
    return this._include;
  }

  // recurse - computed: false, optional: true, required: false
  private _recurse?: boolean | cdktf.IResolvable; 
  public get recurse() {
    return this.getBooleanAttribute('recurse');
  }
  public set recurse(value: boolean | cdktf.IResolvable) {
    this._recurse = value;
  }
  public resetRecurse() {
    this._recurse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recurseInput() {
    return this._recurse;
  }

  // jsonnet - computed: false, optional: true, required: false
  private _jsonnet = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnetOutputReference(this, "jsonnet");
  public get jsonnet() {
    return this._jsonnet;
  }
  public putJsonnet(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryJsonnet) {
    this._jsonnet.internalValue = value;
  }
  public resetJsonnet() {
    this._jsonnet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonnetInput() {
    return this._jsonnet.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParameters {
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name: string;
  /**
  * Path to the file containing the values for the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParameters {
  /**
  * Determines whether to tell Helm to interpret booleans and numbers as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_string PlatformGitopsApplicationset#force_string}
  */
  readonly forceString?: boolean | cdktf.IResolvable;
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    force_string: cdktf.booleanToTerraform(struct!.forceString),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    force_string: {
      value: cdktf.booleanToHclTerraform(struct!.forceString),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._forceString !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceString = this._forceString;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._forceString = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._forceString = value.forceString;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // force_string - computed: false, optional: true, required: false
  private _forceString?: boolean | cdktf.IResolvable; 
  public get forceString() {
    return this.getBooleanAttribute('force_string');
  }
  public set forceString(value: boolean | cdktf.IResolvable) {
    this._forceString = value;
  }
  public resetForceString() {
    this._forceString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceStringInput() {
    return this._forceString;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelm {
  /**
  * Prevents 'helm template' from failing when `value_files` do not exist locally by not appending them to 'helm template --values'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_missing_value_files PlatformGitopsApplicationset#ignore_missing_value_files}
  */
  readonly ignoreMissingValueFiles?: boolean | cdktf.IResolvable;
  /**
  * If true then adds '--pass-credentials' to Helm commands to pass credentials to all domains.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#pass_credentials PlatformGitopsApplicationset#pass_credentials}
  */
  readonly passCredentials?: boolean | cdktf.IResolvable;
  /**
  * Helm release name. If omitted it will use the application name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#release_name PlatformGitopsApplicationset#release_name}
  */
  readonly releaseName?: string;
  /**
  * Whether to skip custom resource definition installation step (Helm's [--skip-crds](https://helm.sh/docs/chart_best_practices/custom_resource_definitions/)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_crds PlatformGitopsApplicationset#skip_crds}
  */
  readonly skipCrds?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip schema validation during helm template. Corresponds to helm --skip-schema-validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_schema_validation PlatformGitopsApplicationset#skip_schema_validation}
  */
  readonly skipSchemaValidation?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip tests during helm template. Corresponds to helm --skip-tests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_tests PlatformGitopsApplicationset#skip_tests}
  */
  readonly skipTests?: boolean | cdktf.IResolvable;
  /**
  * List of Helm value files to use when generating a template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value_files PlatformGitopsApplicationset#value_files}
  */
  readonly valueFiles?: string[];
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values PlatformGitopsApplicationset#values}
  */
  readonly values?: string;
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values_object PlatformGitopsApplicationset#values_object}
  */
  readonly valuesObject?: { [key: string]: string };
  /**
  * Helm version to use for templating (either "2" or "3").
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
  /**
  * file_parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#file_parameters PlatformGitopsApplicationset#file_parameters}
  */
  readonly fileParameters?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParameters[] | cdktf.IResolvable;
  /**
  * parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#parameters PlatformGitopsApplicationset#parameters}
  */
  readonly parameters?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParameters[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_missing_value_files: cdktf.booleanToTerraform(struct!.ignoreMissingValueFiles),
    pass_credentials: cdktf.booleanToTerraform(struct!.passCredentials),
    release_name: cdktf.stringToTerraform(struct!.releaseName),
    skip_crds: cdktf.booleanToTerraform(struct!.skipCrds),
    skip_schema_validation: cdktf.booleanToTerraform(struct!.skipSchemaValidation),
    skip_tests: cdktf.booleanToTerraform(struct!.skipTests),
    value_files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.valueFiles),
    values: cdktf.stringToTerraform(struct!.values),
    values_object: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.valuesObject),
    version: cdktf.stringToTerraform(struct!.version),
    file_parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersToTerraform, true)(struct!.fileParameters),
    parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersToTerraform, true)(struct!.parameters),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_missing_value_files: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreMissingValueFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pass_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.passCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    release_name: {
      value: cdktf.stringToHclTerraform(struct!.releaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_crds: {
      value: cdktf.booleanToHclTerraform(struct!.skipCrds),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_schema_validation: {
      value: cdktf.booleanToHclTerraform(struct!.skipSchemaValidation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_tests: {
      value: cdktf.booleanToHclTerraform(struct!.skipTests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value_files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.valueFiles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    values: {
      value: cdktf.stringToHclTerraform(struct!.values),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values_object: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.valuesObject),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersToHclTerraform, true)(struct!.fileParameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersList",
    },
    parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersToHclTerraform, true)(struct!.parameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelm | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreMissingValueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreMissingValueFiles = this._ignoreMissingValueFiles;
    }
    if (this._passCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.passCredentials = this._passCredentials;
    }
    if (this._releaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.releaseName = this._releaseName;
    }
    if (this._skipCrds !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCrds = this._skipCrds;
    }
    if (this._skipSchemaValidation !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipSchemaValidation = this._skipSchemaValidation;
    }
    if (this._skipTests !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipTests = this._skipTests;
    }
    if (this._valueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFiles = this._valueFiles;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    if (this._valuesObject !== undefined) {
      hasAnyValues = true;
      internalValueResult.valuesObject = this._valuesObject;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._fileParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileParameters = this._fileParameters?.internalValue;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelm | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._ignoreMissingValueFiles = undefined;
      this._passCredentials = undefined;
      this._releaseName = undefined;
      this._skipCrds = undefined;
      this._skipSchemaValidation = undefined;
      this._skipTests = undefined;
      this._valueFiles = undefined;
      this._values = undefined;
      this._valuesObject = undefined;
      this._version = undefined;
      this._fileParameters.internalValue = undefined;
      this._parameters.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._ignoreMissingValueFiles = value.ignoreMissingValueFiles;
      this._passCredentials = value.passCredentials;
      this._releaseName = value.releaseName;
      this._skipCrds = value.skipCrds;
      this._skipSchemaValidation = value.skipSchemaValidation;
      this._skipTests = value.skipTests;
      this._valueFiles = value.valueFiles;
      this._values = value.values;
      this._valuesObject = value.valuesObject;
      this._version = value.version;
      this._fileParameters.internalValue = value.fileParameters;
      this._parameters.internalValue = value.parameters;
    }
  }

  // ignore_missing_value_files - computed: false, optional: true, required: false
  private _ignoreMissingValueFiles?: boolean | cdktf.IResolvable; 
  public get ignoreMissingValueFiles() {
    return this.getBooleanAttribute('ignore_missing_value_files');
  }
  public set ignoreMissingValueFiles(value: boolean | cdktf.IResolvable) {
    this._ignoreMissingValueFiles = value;
  }
  public resetIgnoreMissingValueFiles() {
    this._ignoreMissingValueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreMissingValueFilesInput() {
    return this._ignoreMissingValueFiles;
  }

  // pass_credentials - computed: false, optional: true, required: false
  private _passCredentials?: boolean | cdktf.IResolvable; 
  public get passCredentials() {
    return this.getBooleanAttribute('pass_credentials');
  }
  public set passCredentials(value: boolean | cdktf.IResolvable) {
    this._passCredentials = value;
  }
  public resetPassCredentials() {
    this._passCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passCredentialsInput() {
    return this._passCredentials;
  }

  // release_name - computed: false, optional: true, required: false
  private _releaseName?: string; 
  public get releaseName() {
    return this.getStringAttribute('release_name');
  }
  public set releaseName(value: string) {
    this._releaseName = value;
  }
  public resetReleaseName() {
    this._releaseName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get releaseNameInput() {
    return this._releaseName;
  }

  // skip_crds - computed: false, optional: true, required: false
  private _skipCrds?: boolean | cdktf.IResolvable; 
  public get skipCrds() {
    return this.getBooleanAttribute('skip_crds');
  }
  public set skipCrds(value: boolean | cdktf.IResolvable) {
    this._skipCrds = value;
  }
  public resetSkipCrds() {
    this._skipCrds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCrdsInput() {
    return this._skipCrds;
  }

  // skip_schema_validation - computed: false, optional: true, required: false
  private _skipSchemaValidation?: boolean | cdktf.IResolvable; 
  public get skipSchemaValidation() {
    return this.getBooleanAttribute('skip_schema_validation');
  }
  public set skipSchemaValidation(value: boolean | cdktf.IResolvable) {
    this._skipSchemaValidation = value;
  }
  public resetSkipSchemaValidation() {
    this._skipSchemaValidation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipSchemaValidationInput() {
    return this._skipSchemaValidation;
  }

  // skip_tests - computed: false, optional: true, required: false
  private _skipTests?: boolean | cdktf.IResolvable; 
  public get skipTests() {
    return this.getBooleanAttribute('skip_tests');
  }
  public set skipTests(value: boolean | cdktf.IResolvable) {
    this._skipTests = value;
  }
  public resetSkipTests() {
    this._skipTests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipTestsInput() {
    return this._skipTests;
  }

  // value_files - computed: false, optional: true, required: false
  private _valueFiles?: string[]; 
  public get valueFiles() {
    return this.getListAttribute('value_files');
  }
  public set valueFiles(value: string[]) {
    this._valueFiles = value;
  }
  public resetValueFiles() {
    this._valueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFilesInput() {
    return this._valueFiles;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string; 
  public get values() {
    return this.getStringAttribute('values');
  }
  public set values(value: string) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }

  // values_object - computed: false, optional: true, required: false
  private _valuesObject?: { [key: string]: string }; 
  public get valuesObject() {
    return this.getStringMapAttribute('values_object');
  }
  public set valuesObject(value: { [key: string]: string }) {
    this._valuesObject = value;
  }
  public resetValuesObject() {
    this._valuesObject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesObjectInput() {
    return this._valuesObject;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // file_parameters - computed: false, optional: true, required: false
  private _fileParameters = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParametersList(this, "file_parameters", false);
  public get fileParameters() {
    return this._fileParameters;
  }
  public putFileParameters(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmFileParameters[] | cdktf.IResolvable) {
    this._fileParameters.internalValue = value;
  }
  public resetFileParameters() {
    this._fileParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileParametersInput() {
    return this._fileParameters.internalValue;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParametersList(this, "parameters", false);
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmParameters[] | cdktf.IResolvable) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomize {
  /**
  * List of additional annotations to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_annotations PlatformGitopsApplicationset#common_annotations}
  */
  readonly commonAnnotations?: { [key: string]: string };
  /**
  * List of additional labels to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_labels PlatformGitopsApplicationset#common_labels}
  */
  readonly commonLabels?: { [key: string]: string };
  /**
  * Indicates if to force applying common annotations to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_annotations PlatformGitopsApplicationset#force_common_annotations}
  */
  readonly forceCommonAnnotations?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to force apply common labels to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_labels PlatformGitopsApplicationset#force_common_labels}
  */
  readonly forceCommonLabels?: boolean | cdktf.IResolvable;
  /**
  * List of Kustomize image override specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#images PlatformGitopsApplicationset#images}
  */
  readonly images?: string[];
  /**
  * Prefix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_prefix PlatformGitopsApplicationset#name_prefix}
  */
  readonly namePrefix?: string;
  /**
  * Suffix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_suffix PlatformGitopsApplicationset#name_suffix}
  */
  readonly nameSuffix?: string;
  /**
  * Version of Kustomize to use for rendering manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    common_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonAnnotations),
    common_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonLabels),
    force_common_annotations: cdktf.booleanToTerraform(struct!.forceCommonAnnotations),
    force_common_labels: cdktf.booleanToTerraform(struct!.forceCommonLabels),
    images: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.images),
    name_prefix: cdktf.stringToTerraform(struct!.namePrefix),
    name_suffix: cdktf.stringToTerraform(struct!.nameSuffix),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    common_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    common_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    force_common_annotations: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    force_common_labels: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    images: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.images),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name_prefix: {
      value: cdktf.stringToHclTerraform(struct!.namePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.nameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomize | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonAnnotations = this._commonAnnotations;
    }
    if (this._commonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonLabels = this._commonLabels;
    }
    if (this._forceCommonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonAnnotations = this._forceCommonAnnotations;
    }
    if (this._forceCommonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonLabels = this._forceCommonLabels;
    }
    if (this._images !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images;
    }
    if (this._namePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.namePrefix = this._namePrefix;
    }
    if (this._nameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameSuffix = this._nameSuffix;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomize | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._commonAnnotations = undefined;
      this._commonLabels = undefined;
      this._forceCommonAnnotations = undefined;
      this._forceCommonLabels = undefined;
      this._images = undefined;
      this._namePrefix = undefined;
      this._nameSuffix = undefined;
      this._version = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._commonAnnotations = value.commonAnnotations;
      this._commonLabels = value.commonLabels;
      this._forceCommonAnnotations = value.forceCommonAnnotations;
      this._forceCommonLabels = value.forceCommonLabels;
      this._images = value.images;
      this._namePrefix = value.namePrefix;
      this._nameSuffix = value.nameSuffix;
      this._version = value.version;
    }
  }

  // common_annotations - computed: false, optional: true, required: false
  private _commonAnnotations?: { [key: string]: string }; 
  public get commonAnnotations() {
    return this.getStringMapAttribute('common_annotations');
  }
  public set commonAnnotations(value: { [key: string]: string }) {
    this._commonAnnotations = value;
  }
  public resetCommonAnnotations() {
    this._commonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonAnnotationsInput() {
    return this._commonAnnotations;
  }

  // common_labels - computed: false, optional: true, required: false
  private _commonLabels?: { [key: string]: string }; 
  public get commonLabels() {
    return this.getStringMapAttribute('common_labels');
  }
  public set commonLabels(value: { [key: string]: string }) {
    this._commonLabels = value;
  }
  public resetCommonLabels() {
    this._commonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonLabelsInput() {
    return this._commonLabels;
  }

  // force_common_annotations - computed: false, optional: true, required: false
  private _forceCommonAnnotations?: boolean | cdktf.IResolvable; 
  public get forceCommonAnnotations() {
    return this.getBooleanAttribute('force_common_annotations');
  }
  public set forceCommonAnnotations(value: boolean | cdktf.IResolvable) {
    this._forceCommonAnnotations = value;
  }
  public resetForceCommonAnnotations() {
    this._forceCommonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonAnnotationsInput() {
    return this._forceCommonAnnotations;
  }

  // force_common_labels - computed: false, optional: true, required: false
  private _forceCommonLabels?: boolean | cdktf.IResolvable; 
  public get forceCommonLabels() {
    return this.getBooleanAttribute('force_common_labels');
  }
  public set forceCommonLabels(value: boolean | cdktf.IResolvable) {
    this._forceCommonLabels = value;
  }
  public resetForceCommonLabels() {
    this._forceCommonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonLabelsInput() {
    return this._forceCommonLabels;
  }

  // images - computed: false, optional: true, required: false
  private _images?: string[]; 
  public get images() {
    return this.getListAttribute('images');
  }
  public set images(value: string[]) {
    this._images = value;
  }
  public resetImages() {
    this._images = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images;
  }

  // name_prefix - computed: false, optional: true, required: false
  private _namePrefix?: string; 
  public get namePrefix() {
    return this.getStringAttribute('name_prefix');
  }
  public set namePrefix(value: string) {
    this._namePrefix = value;
  }
  public resetNamePrefix() {
    this._namePrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namePrefixInput() {
    return this._namePrefix;
  }

  // name_suffix - computed: false, optional: true, required: false
  private _nameSuffix?: string; 
  public get nameSuffix() {
    return this.getStringAttribute('name_suffix');
  }
  public set nameSuffix(value: string) {
    this._nameSuffix = value;
  }
  public resetNameSuffix() {
    this._nameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameSuffixInput() {
    return this._nameSuffix;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnv {
  /**
  * Name of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePlugin {
  /**
  * Name of the plugin. Only set the plugin name if the plugin is defined in `argocd-cm`. If the plugin is defined as a sidecar, omit the name. The plugin will be automatically matched with the Application according to the plugin's discovery rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * env block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#env PlatformGitopsApplicationset#env}
  */
  readonly env?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnv[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    env: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvToTerraform, true)(struct!.env),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvToHclTerraform, true)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePlugin | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePlugin | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._env.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._env.internalValue = value.env;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // env - computed: false, optional: true, required: false
  private _env = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSource {
  /**
  * Helm chart name. Must be specified for applications sourced from a Helm repo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#chart PlatformGitopsApplicationset#chart}
  */
  readonly chart?: string;
  /**
  * Directory path within the repository. Only valid for applications sourced from Git.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path?: string;
  /**
  * Reference to another `source` within defined sources. See associated documentation on [Helm value files from external Git repository](https://argo-cd.readthedocs.io/en/stable/user-guide/multiple_sources/#helm-value-files-from-external-git-repository) regarding combining `ref` with `path` and/or `chart`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ref PlatformGitopsApplicationset#ref}
  */
  readonly ref?: string;
  /**
  * URL to the repository (Git or Helm) that contains the application manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#repo_url PlatformGitopsApplicationset#repo_url}
  */
  readonly repoUrl: string;
  /**
  * Revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart's version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#target_revision PlatformGitopsApplicationset#target_revision}
  */
  readonly targetRevision?: string;
  /**
  * directory block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#directory PlatformGitopsApplicationset#directory}
  */
  readonly directory?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectory;
  /**
  * helm block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#helm PlatformGitopsApplicationset#helm}
  */
  readonly helm?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelm;
  /**
  * kustomize block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#kustomize PlatformGitopsApplicationset#kustomize}
  */
  readonly kustomize?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomize;
  /**
  * plugin block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#plugin PlatformGitopsApplicationset#plugin}
  */
  readonly plugin?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePlugin;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chart: cdktf.stringToTerraform(struct!.chart),
    path: cdktf.stringToTerraform(struct!.path),
    ref: cdktf.stringToTerraform(struct!.ref),
    repo_url: cdktf.stringToTerraform(struct!.repoUrl),
    target_revision: cdktf.stringToTerraform(struct!.targetRevision),
    directory: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryToTerraform(struct!.directory),
    helm: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmToTerraform(struct!.helm),
    kustomize: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeToTerraform(struct!.kustomize),
    plugin: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginToTerraform(struct!.plugin),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chart: {
      value: cdktf.stringToHclTerraform(struct!.chart),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: cdktf.stringToHclTerraform(struct!.ref),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repo_url: {
      value: cdktf.stringToHclTerraform(struct!.repoUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_revision: {
      value: cdktf.stringToHclTerraform(struct!.targetRevision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    directory: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryToHclTerraform(struct!.directory),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryList",
    },
    helm: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmToHclTerraform(struct!.helm),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmList",
    },
    kustomize: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeToHclTerraform(struct!.kustomize),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeList",
    },
    plugin: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginToHclTerraform(struct!.plugin),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chart !== undefined) {
      hasAnyValues = true;
      internalValueResult.chart = this._chart;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ref !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref;
    }
    if (this._repoUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.repoUrl = this._repoUrl;
    }
    if (this._targetRevision !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRevision = this._targetRevision;
    }
    if (this._directory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.directory = this._directory?.internalValue;
    }
    if (this._helm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.helm = this._helm?.internalValue;
    }
    if (this._kustomize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kustomize = this._kustomize?.internalValue;
    }
    if (this._plugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chart = undefined;
      this._path = undefined;
      this._ref = undefined;
      this._repoUrl = undefined;
      this._targetRevision = undefined;
      this._directory.internalValue = undefined;
      this._helm.internalValue = undefined;
      this._kustomize.internalValue = undefined;
      this._plugin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chart = value.chart;
      this._path = value.path;
      this._ref = value.ref;
      this._repoUrl = value.repoUrl;
      this._targetRevision = value.targetRevision;
      this._directory.internalValue = value.directory;
      this._helm.internalValue = value.helm;
      this._kustomize.internalValue = value.kustomize;
      this._plugin.internalValue = value.plugin;
    }
  }

  // chart - computed: false, optional: true, required: false
  private _chart?: string; 
  public get chart() {
    return this.getStringAttribute('chart');
  }
  public set chart(value: string) {
    this._chart = value;
  }
  public resetChart() {
    this._chart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chartInput() {
    return this._chart;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ref - computed: false, optional: true, required: false
  private _ref?: string; 
  public get ref() {
    return this.getStringAttribute('ref');
  }
  public set ref(value: string) {
    this._ref = value;
  }
  public resetRef() {
    this._ref = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref;
  }

  // repo_url - computed: false, optional: false, required: true
  private _repoUrl?: string; 
  public get repoUrl() {
    return this.getStringAttribute('repo_url');
  }
  public set repoUrl(value: string) {
    this._repoUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get repoUrlInput() {
    return this._repoUrl;
  }

  // target_revision - computed: false, optional: true, required: false
  private _targetRevision?: string; 
  public get targetRevision() {
    return this.getStringAttribute('target_revision');
  }
  public set targetRevision(value: string) {
    this._targetRevision = value;
  }
  public resetTargetRevision() {
    this._targetRevision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRevisionInput() {
    return this._targetRevision;
  }

  // directory - computed: false, optional: true, required: false
  private _directory = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectoryOutputReference(this, "directory");
  public get directory() {
    return this._directory;
  }
  public putDirectory(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceDirectory) {
    this._directory.internalValue = value;
  }
  public resetDirectory() {
    this._directory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directoryInput() {
    return this._directory.internalValue;
  }

  // helm - computed: false, optional: true, required: false
  private _helm = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelmOutputReference(this, "helm");
  public get helm() {
    return this._helm;
  }
  public putHelm(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceHelm) {
    this._helm.internalValue = value;
  }
  public resetHelm() {
    this._helm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helmInput() {
    return this._helm.internalValue;
  }

  // kustomize - computed: false, optional: true, required: false
  private _kustomize = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomizeOutputReference(this, "kustomize");
  public get kustomize() {
    return this._kustomize;
  }
  public putKustomize(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceKustomize) {
    this._kustomize.internalValue = value;
  }
  public resetKustomize() {
    this._kustomize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kustomizeInput() {
    return this._kustomize.internalValue;
  }

  // plugin - computed: false, optional: true, required: false
  private _plugin = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePluginOutputReference(this, "plugin");
  public get plugin() {
    return this._plugin;
  }
  public putPlugin(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcePlugin) {
    this._plugin.internalValue = value;
  }
  public resetPlugin() {
    this._plugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSource[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVar {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVar | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlas {
  /**
  * Determines whether the variable should be evaluated as jsonnet code or treated as string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#code PlatformGitopsApplicationset#code}
  */
  readonly code?: boolean | cdktf.IResolvable;
  /**
  * Name of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of Jsonnet variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    code: cdktf.booleanToTerraform(struct!.code),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    code: {
      value: cdktf.booleanToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlas | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._code = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._code = value.code;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // code - computed: false, optional: true, required: false
  private _code?: boolean | cdktf.IResolvable; 
  public get code() {
    return this.getBooleanAttribute('code');
  }
  public set code(value: boolean | cdktf.IResolvable) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnet {
  /**
  * Additional library search dirs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#libs PlatformGitopsApplicationset#libs}
  */
  readonly libs?: string[];
  /**
  * ext_var block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ext_var PlatformGitopsApplicationset#ext_var}
  */
  readonly extVar?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable;
  /**
  * tlas block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#tlas PlatformGitopsApplicationset#tlas}
  */
  readonly tlas?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    libs: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.libs),
    ext_var: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarToTerraform, true)(struct!.extVar),
    tlas: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasToTerraform, true)(struct!.tlas),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    libs: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.libs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ext_var: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarToHclTerraform, true)(struct!.extVar),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarList",
    },
    tlas: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasToHclTerraform, true)(struct!.tlas),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._libs !== undefined) {
      hasAnyValues = true;
      internalValueResult.libs = this._libs;
    }
    if (this._extVar?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extVar = this._extVar?.internalValue;
    }
    if (this._tlas?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlas = this._tlas?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._libs = undefined;
      this._extVar.internalValue = undefined;
      this._tlas.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._libs = value.libs;
      this._extVar.internalValue = value.extVar;
      this._tlas.internalValue = value.tlas;
    }
  }

  // libs - computed: false, optional: true, required: false
  private _libs?: string[]; 
  public get libs() {
    return this.getListAttribute('libs');
  }
  public set libs(value: string[]) {
    this._libs = value;
  }
  public resetLibs() {
    this._libs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get libsInput() {
    return this._libs;
  }

  // ext_var - computed: false, optional: true, required: false
  private _extVar = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVarList(this, "ext_var", false);
  public get extVar() {
    return this._extVar;
  }
  public putExtVar(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetExtVar[] | cdktf.IResolvable) {
    this._extVar.internalValue = value;
  }
  public resetExtVar() {
    this._extVar.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extVarInput() {
    return this._extVar.internalValue;
  }

  // tlas - computed: false, optional: true, required: false
  private _tlas = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlasList(this, "tlas", false);
  public get tlas() {
    return this._tlas;
  }
  public putTlas(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetTlas[] | cdktf.IResolvable) {
    this._tlas.internalValue = value;
  }
  public resetTlas() {
    this._tlas.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlasInput() {
    return this._tlas.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectory {
  /**
  * Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation. This takes precedence over the `include` field. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{config.yaml,env-use2/*}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#exclude PlatformGitopsApplicationset#exclude}
  */
  readonly exclude?: string;
  /**
  * Glob pattern to match paths against that should be explicitly included during manifest generation. If this field is set, only matching manifests will be included. To match multiple patterns, wrap the patterns in {} and separate them with commas. For example: '{*.yml,*.yaml}'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#include PlatformGitopsApplicationset#include}
  */
  readonly include?: string;
  /**
  * Whether to scan a directory recursively for manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#recurse PlatformGitopsApplicationset#recurse}
  */
  readonly recurse?: boolean | cdktf.IResolvable;
  /**
  * jsonnet block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#jsonnet PlatformGitopsApplicationset#jsonnet}
  */
  readonly jsonnet?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnet;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exclude: cdktf.stringToTerraform(struct!.exclude),
    include: cdktf.stringToTerraform(struct!.include),
    recurse: cdktf.booleanToTerraform(struct!.recurse),
    jsonnet: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetToTerraform(struct!.jsonnet),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectory): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exclude: {
      value: cdktf.stringToHclTerraform(struct!.exclude),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include: {
      value: cdktf.stringToHclTerraform(struct!.include),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    recurse: {
      value: cdktf.booleanToHclTerraform(struct!.recurse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    jsonnet: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetToHclTerraform(struct!.jsonnet),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectory | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exclude !== undefined) {
      hasAnyValues = true;
      internalValueResult.exclude = this._exclude;
    }
    if (this._include !== undefined) {
      hasAnyValues = true;
      internalValueResult.include = this._include;
    }
    if (this._recurse !== undefined) {
      hasAnyValues = true;
      internalValueResult.recurse = this._recurse;
    }
    if (this._jsonnet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonnet = this._jsonnet?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectory | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._exclude = undefined;
      this._include = undefined;
      this._recurse = undefined;
      this._jsonnet.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._exclude = value.exclude;
      this._include = value.include;
      this._recurse = value.recurse;
      this._jsonnet.internalValue = value.jsonnet;
    }
  }

  // exclude - computed: false, optional: true, required: false
  private _exclude?: string; 
  public get exclude() {
    return this.getStringAttribute('exclude');
  }
  public set exclude(value: string) {
    this._exclude = value;
  }
  public resetExclude() {
    this._exclude = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeInput() {
    return this._exclude;
  }

  // include - computed: false, optional: true, required: false
  private _include?: string; 
  public get include() {
    return this.getStringAttribute('include');
  }
  public set include(value: string) {
    this._include = value;
  }
  public resetInclude() {
    this._include = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeInput() {
    return this._include;
  }

  // recurse - computed: false, optional: true, required: false
  private _recurse?: boolean | cdktf.IResolvable; 
  public get recurse() {
    return this.getBooleanAttribute('recurse');
  }
  public set recurse(value: boolean | cdktf.IResolvable) {
    this._recurse = value;
  }
  public resetRecurse() {
    this._recurse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recurseInput() {
    return this._recurse;
  }

  // jsonnet - computed: false, optional: true, required: false
  private _jsonnet = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnetOutputReference(this, "jsonnet");
  public get jsonnet() {
    return this._jsonnet;
  }
  public putJsonnet(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryJsonnet) {
    this._jsonnet.internalValue = value;
  }
  public resetJsonnet() {
    this._jsonnet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonnetInput() {
    return this._jsonnet.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParameters {
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name: string;
  /**
  * Path to the file containing the values for the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParameters {
  /**
  * Determines whether to tell Helm to interpret booleans and numbers as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_string PlatformGitopsApplicationset#force_string}
  */
  readonly forceString?: boolean | cdktf.IResolvable;
  /**
  * Name of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the Helm parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    force_string: cdktf.booleanToTerraform(struct!.forceString),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    force_string: {
      value: cdktf.booleanToHclTerraform(struct!.forceString),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._forceString !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceString = this._forceString;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._forceString = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._forceString = value.forceString;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // force_string - computed: false, optional: true, required: false
  private _forceString?: boolean | cdktf.IResolvable; 
  public get forceString() {
    return this.getBooleanAttribute('force_string');
  }
  public set forceString(value: boolean | cdktf.IResolvable) {
    this._forceString = value;
  }
  public resetForceString() {
    this._forceString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceStringInput() {
    return this._forceString;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelm {
  /**
  * Prevents 'helm template' from failing when `value_files` do not exist locally by not appending them to 'helm template --values'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_missing_value_files PlatformGitopsApplicationset#ignore_missing_value_files}
  */
  readonly ignoreMissingValueFiles?: boolean | cdktf.IResolvable;
  /**
  * If true then adds '--pass-credentials' to Helm commands to pass credentials to all domains.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#pass_credentials PlatformGitopsApplicationset#pass_credentials}
  */
  readonly passCredentials?: boolean | cdktf.IResolvable;
  /**
  * Helm release name. If omitted it will use the application name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#release_name PlatformGitopsApplicationset#release_name}
  */
  readonly releaseName?: string;
  /**
  * Whether to skip custom resource definition installation step (Helm's [--skip-crds](https://helm.sh/docs/chart_best_practices/custom_resource_definitions/)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_crds PlatformGitopsApplicationset#skip_crds}
  */
  readonly skipCrds?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip schema validation during helm template. Corresponds to helm --skip-schema-validation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_schema_validation PlatformGitopsApplicationset#skip_schema_validation}
  */
  readonly skipSchemaValidation?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to skip tests during helm template. Corresponds to helm --skip-tests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#skip_tests PlatformGitopsApplicationset#skip_tests}
  */
  readonly skipTests?: boolean | cdktf.IResolvable;
  /**
  * List of Helm value files to use when generating a template.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value_files PlatformGitopsApplicationset#value_files}
  */
  readonly valueFiles?: string[];
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values PlatformGitopsApplicationset#values}
  */
  readonly values?: string;
  /**
  * Helm values to be passed to 'helm template', typically defined as a block.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#values_object PlatformGitopsApplicationset#values_object}
  */
  readonly valuesObject?: { [key: string]: string };
  /**
  * Helm version to use for templating (either "2" or "3").
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
  /**
  * file_parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#file_parameters PlatformGitopsApplicationset#file_parameters}
  */
  readonly fileParameters?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable;
  /**
  * parameters block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#parameters PlatformGitopsApplicationset#parameters}
  */
  readonly parameters?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ignore_missing_value_files: cdktf.booleanToTerraform(struct!.ignoreMissingValueFiles),
    pass_credentials: cdktf.booleanToTerraform(struct!.passCredentials),
    release_name: cdktf.stringToTerraform(struct!.releaseName),
    skip_crds: cdktf.booleanToTerraform(struct!.skipCrds),
    skip_schema_validation: cdktf.booleanToTerraform(struct!.skipSchemaValidation),
    skip_tests: cdktf.booleanToTerraform(struct!.skipTests),
    value_files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.valueFiles),
    values: cdktf.stringToTerraform(struct!.values),
    values_object: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.valuesObject),
    version: cdktf.stringToTerraform(struct!.version),
    file_parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersToTerraform, true)(struct!.fileParameters),
    parameters: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersToTerraform, true)(struct!.parameters),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelm): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ignore_missing_value_files: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreMissingValueFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pass_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.passCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    release_name: {
      value: cdktf.stringToHclTerraform(struct!.releaseName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    skip_crds: {
      value: cdktf.booleanToHclTerraform(struct!.skipCrds),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_schema_validation: {
      value: cdktf.booleanToHclTerraform(struct!.skipSchemaValidation),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    skip_tests: {
      value: cdktf.booleanToHclTerraform(struct!.skipTests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value_files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.valueFiles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    values: {
      value: cdktf.stringToHclTerraform(struct!.values),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values_object: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.valuesObject),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersToHclTerraform, true)(struct!.fileParameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersList",
    },
    parameters: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersToHclTerraform, true)(struct!.parameters),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelm | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ignoreMissingValueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreMissingValueFiles = this._ignoreMissingValueFiles;
    }
    if (this._passCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.passCredentials = this._passCredentials;
    }
    if (this._releaseName !== undefined) {
      hasAnyValues = true;
      internalValueResult.releaseName = this._releaseName;
    }
    if (this._skipCrds !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipCrds = this._skipCrds;
    }
    if (this._skipSchemaValidation !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipSchemaValidation = this._skipSchemaValidation;
    }
    if (this._skipTests !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipTests = this._skipTests;
    }
    if (this._valueFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFiles = this._valueFiles;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    if (this._valuesObject !== undefined) {
      hasAnyValues = true;
      internalValueResult.valuesObject = this._valuesObject;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    if (this._fileParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileParameters = this._fileParameters?.internalValue;
    }
    if (this._parameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parameters = this._parameters?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelm | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._ignoreMissingValueFiles = undefined;
      this._passCredentials = undefined;
      this._releaseName = undefined;
      this._skipCrds = undefined;
      this._skipSchemaValidation = undefined;
      this._skipTests = undefined;
      this._valueFiles = undefined;
      this._values = undefined;
      this._valuesObject = undefined;
      this._version = undefined;
      this._fileParameters.internalValue = undefined;
      this._parameters.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._ignoreMissingValueFiles = value.ignoreMissingValueFiles;
      this._passCredentials = value.passCredentials;
      this._releaseName = value.releaseName;
      this._skipCrds = value.skipCrds;
      this._skipSchemaValidation = value.skipSchemaValidation;
      this._skipTests = value.skipTests;
      this._valueFiles = value.valueFiles;
      this._values = value.values;
      this._valuesObject = value.valuesObject;
      this._version = value.version;
      this._fileParameters.internalValue = value.fileParameters;
      this._parameters.internalValue = value.parameters;
    }
  }

  // ignore_missing_value_files - computed: false, optional: true, required: false
  private _ignoreMissingValueFiles?: boolean | cdktf.IResolvable; 
  public get ignoreMissingValueFiles() {
    return this.getBooleanAttribute('ignore_missing_value_files');
  }
  public set ignoreMissingValueFiles(value: boolean | cdktf.IResolvable) {
    this._ignoreMissingValueFiles = value;
  }
  public resetIgnoreMissingValueFiles() {
    this._ignoreMissingValueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreMissingValueFilesInput() {
    return this._ignoreMissingValueFiles;
  }

  // pass_credentials - computed: false, optional: true, required: false
  private _passCredentials?: boolean | cdktf.IResolvable; 
  public get passCredentials() {
    return this.getBooleanAttribute('pass_credentials');
  }
  public set passCredentials(value: boolean | cdktf.IResolvable) {
    this._passCredentials = value;
  }
  public resetPassCredentials() {
    this._passCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passCredentialsInput() {
    return this._passCredentials;
  }

  // release_name - computed: false, optional: true, required: false
  private _releaseName?: string; 
  public get releaseName() {
    return this.getStringAttribute('release_name');
  }
  public set releaseName(value: string) {
    this._releaseName = value;
  }
  public resetReleaseName() {
    this._releaseName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get releaseNameInput() {
    return this._releaseName;
  }

  // skip_crds - computed: false, optional: true, required: false
  private _skipCrds?: boolean | cdktf.IResolvable; 
  public get skipCrds() {
    return this.getBooleanAttribute('skip_crds');
  }
  public set skipCrds(value: boolean | cdktf.IResolvable) {
    this._skipCrds = value;
  }
  public resetSkipCrds() {
    this._skipCrds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipCrdsInput() {
    return this._skipCrds;
  }

  // skip_schema_validation - computed: false, optional: true, required: false
  private _skipSchemaValidation?: boolean | cdktf.IResolvable; 
  public get skipSchemaValidation() {
    return this.getBooleanAttribute('skip_schema_validation');
  }
  public set skipSchemaValidation(value: boolean | cdktf.IResolvable) {
    this._skipSchemaValidation = value;
  }
  public resetSkipSchemaValidation() {
    this._skipSchemaValidation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipSchemaValidationInput() {
    return this._skipSchemaValidation;
  }

  // skip_tests - computed: false, optional: true, required: false
  private _skipTests?: boolean | cdktf.IResolvable; 
  public get skipTests() {
    return this.getBooleanAttribute('skip_tests');
  }
  public set skipTests(value: boolean | cdktf.IResolvable) {
    this._skipTests = value;
  }
  public resetSkipTests() {
    this._skipTests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipTestsInput() {
    return this._skipTests;
  }

  // value_files - computed: false, optional: true, required: false
  private _valueFiles?: string[]; 
  public get valueFiles() {
    return this.getListAttribute('value_files');
  }
  public set valueFiles(value: string[]) {
    this._valueFiles = value;
  }
  public resetValueFiles() {
    this._valueFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFilesInput() {
    return this._valueFiles;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string; 
  public get values() {
    return this.getStringAttribute('values');
  }
  public set values(value: string) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }

  // values_object - computed: false, optional: true, required: false
  private _valuesObject?: { [key: string]: string }; 
  public get valuesObject() {
    return this.getStringMapAttribute('values_object');
  }
  public set valuesObject(value: { [key: string]: string }) {
    this._valuesObject = value;
  }
  public resetValuesObject() {
    this._valuesObject = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesObjectInput() {
    return this._valuesObject;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // file_parameters - computed: false, optional: true, required: false
  private _fileParameters = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParametersList(this, "file_parameters", false);
  public get fileParameters() {
    return this._fileParameters;
  }
  public putFileParameters(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmFileParameters[] | cdktf.IResolvable) {
    this._fileParameters.internalValue = value;
  }
  public resetFileParameters() {
    this._fileParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileParametersInput() {
    return this._fileParameters.internalValue;
  }

  // parameters - computed: false, optional: true, required: false
  private _parameters = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParametersList(this, "parameters", false);
  public get parameters() {
    return this._parameters;
  }
  public putParameters(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmParameters[] | cdktf.IResolvable) {
    this._parameters.internalValue = value;
  }
  public resetParameters() {
    this._parameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parametersInput() {
    return this._parameters.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomize {
  /**
  * List of additional annotations to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_annotations PlatformGitopsApplicationset#common_annotations}
  */
  readonly commonAnnotations?: { [key: string]: string };
  /**
  * List of additional labels to add to rendered manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#common_labels PlatformGitopsApplicationset#common_labels}
  */
  readonly commonLabels?: { [key: string]: string };
  /**
  * Indicates if to force applying common annotations to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_annotations PlatformGitopsApplicationset#force_common_annotations}
  */
  readonly forceCommonAnnotations?: boolean | cdktf.IResolvable;
  /**
  * Indicates if to force apply common labels to resources for kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#force_common_labels PlatformGitopsApplicationset#force_common_labels}
  */
  readonly forceCommonLabels?: boolean | cdktf.IResolvable;
  /**
  * List of Kustomize image override specifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#images PlatformGitopsApplicationset#images}
  */
  readonly images?: string[];
  /**
  * Prefix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_prefix PlatformGitopsApplicationset#name_prefix}
  */
  readonly namePrefix?: string;
  /**
  * Suffix appended to resources for Kustomize apps.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name_suffix PlatformGitopsApplicationset#name_suffix}
  */
  readonly nameSuffix?: string;
  /**
  * Version of Kustomize to use for rendering manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#version PlatformGitopsApplicationset#version}
  */
  readonly version?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    common_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonAnnotations),
    common_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.commonLabels),
    force_common_annotations: cdktf.booleanToTerraform(struct!.forceCommonAnnotations),
    force_common_labels: cdktf.booleanToTerraform(struct!.forceCommonLabels),
    images: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.images),
    name_prefix: cdktf.stringToTerraform(struct!.namePrefix),
    name_suffix: cdktf.stringToTerraform(struct!.nameSuffix),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomize): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    common_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    common_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.commonLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    force_common_annotations: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    force_common_labels: {
      value: cdktf.booleanToHclTerraform(struct!.forceCommonLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    images: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.images),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name_prefix: {
      value: cdktf.stringToHclTerraform(struct!.namePrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.nameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomize | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonAnnotations = this._commonAnnotations;
    }
    if (this._commonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonLabels = this._commonLabels;
    }
    if (this._forceCommonAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonAnnotations = this._forceCommonAnnotations;
    }
    if (this._forceCommonLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceCommonLabels = this._forceCommonLabels;
    }
    if (this._images !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images;
    }
    if (this._namePrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.namePrefix = this._namePrefix;
    }
    if (this._nameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameSuffix = this._nameSuffix;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomize | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._commonAnnotations = undefined;
      this._commonLabels = undefined;
      this._forceCommonAnnotations = undefined;
      this._forceCommonLabels = undefined;
      this._images = undefined;
      this._namePrefix = undefined;
      this._nameSuffix = undefined;
      this._version = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._commonAnnotations = value.commonAnnotations;
      this._commonLabels = value.commonLabels;
      this._forceCommonAnnotations = value.forceCommonAnnotations;
      this._forceCommonLabels = value.forceCommonLabels;
      this._images = value.images;
      this._namePrefix = value.namePrefix;
      this._nameSuffix = value.nameSuffix;
      this._version = value.version;
    }
  }

  // common_annotations - computed: false, optional: true, required: false
  private _commonAnnotations?: { [key: string]: string }; 
  public get commonAnnotations() {
    return this.getStringMapAttribute('common_annotations');
  }
  public set commonAnnotations(value: { [key: string]: string }) {
    this._commonAnnotations = value;
  }
  public resetCommonAnnotations() {
    this._commonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonAnnotationsInput() {
    return this._commonAnnotations;
  }

  // common_labels - computed: false, optional: true, required: false
  private _commonLabels?: { [key: string]: string }; 
  public get commonLabels() {
    return this.getStringMapAttribute('common_labels');
  }
  public set commonLabels(value: { [key: string]: string }) {
    this._commonLabels = value;
  }
  public resetCommonLabels() {
    this._commonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonLabelsInput() {
    return this._commonLabels;
  }

  // force_common_annotations - computed: false, optional: true, required: false
  private _forceCommonAnnotations?: boolean | cdktf.IResolvable; 
  public get forceCommonAnnotations() {
    return this.getBooleanAttribute('force_common_annotations');
  }
  public set forceCommonAnnotations(value: boolean | cdktf.IResolvable) {
    this._forceCommonAnnotations = value;
  }
  public resetForceCommonAnnotations() {
    this._forceCommonAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonAnnotationsInput() {
    return this._forceCommonAnnotations;
  }

  // force_common_labels - computed: false, optional: true, required: false
  private _forceCommonLabels?: boolean | cdktf.IResolvable; 
  public get forceCommonLabels() {
    return this.getBooleanAttribute('force_common_labels');
  }
  public set forceCommonLabels(value: boolean | cdktf.IResolvable) {
    this._forceCommonLabels = value;
  }
  public resetForceCommonLabels() {
    this._forceCommonLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceCommonLabelsInput() {
    return this._forceCommonLabels;
  }

  // images - computed: false, optional: true, required: false
  private _images?: string[]; 
  public get images() {
    return this.getListAttribute('images');
  }
  public set images(value: string[]) {
    this._images = value;
  }
  public resetImages() {
    this._images = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images;
  }

  // name_prefix - computed: false, optional: true, required: false
  private _namePrefix?: string; 
  public get namePrefix() {
    return this.getStringAttribute('name_prefix');
  }
  public set namePrefix(value: string) {
    this._namePrefix = value;
  }
  public resetNamePrefix() {
    this._namePrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namePrefixInput() {
    return this._namePrefix;
  }

  // name_suffix - computed: false, optional: true, required: false
  private _nameSuffix?: string; 
  public get nameSuffix() {
    return this.getStringAttribute('name_suffix');
  }
  public set nameSuffix(value: string) {
    this._nameSuffix = value;
  }
  public resetNameSuffix() {
    this._nameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameSuffixInput() {
    return this._nameSuffix;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnv {
  /**
  * Name of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * Value of the environment variable.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#value PlatformGitopsApplicationset#value}
  */
  readonly value?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPlugin {
  /**
  * Name of the plugin. Only set the plugin name if the plugin is defined in `argocd-cm`. If the plugin is defined as a sidecar, omit the name. The plugin will be automatically matched with the Application according to the plugin's discovery rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#name PlatformGitopsApplicationset#name}
  */
  readonly name?: string;
  /**
  * env block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#env PlatformGitopsApplicationset#env}
  */
  readonly env?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    env: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvToTerraform, true)(struct!.env),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPlugin): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvToHclTerraform, true)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPlugin | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPlugin | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._env.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._env.internalValue = value.env;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // env - computed: false, optional: true, required: false
  private _env = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSources {
  /**
  * Helm chart name. Must be specified for applications sourced from a Helm repo.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#chart PlatformGitopsApplicationset#chart}
  */
  readonly chart?: string;
  /**
  * Directory path within the repository. Only valid for applications sourced from Git.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#path PlatformGitopsApplicationset#path}
  */
  readonly path?: string;
  /**
  * Reference to another `source` within defined sources. See associated documentation on [Helm value files from external Git repository](https://argo-cd.readthedocs.io/en/stable/user-guide/multiple_sources/#helm-value-files-from-external-git-repository) regarding combining `ref` with `path` and/or `chart`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ref PlatformGitopsApplicationset#ref}
  */
  readonly ref?: string;
  /**
  * URL to the repository (Git or Helm) that contains the application manifests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#repo_url PlatformGitopsApplicationset#repo_url}
  */
  readonly repoUrl: string;
  /**
  * Revision of the source to sync the application to. In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag for the Chart's version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#target_revision PlatformGitopsApplicationset#target_revision}
  */
  readonly targetRevision?: string;
  /**
  * directory block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#directory PlatformGitopsApplicationset#directory}
  */
  readonly directory?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectory;
  /**
  * helm block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#helm PlatformGitopsApplicationset#helm}
  */
  readonly helm?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelm;
  /**
  * kustomize block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#kustomize PlatformGitopsApplicationset#kustomize}
  */
  readonly kustomize?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomize;
  /**
  * plugin block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#plugin PlatformGitopsApplicationset#plugin}
  */
  readonly plugin?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPlugin;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    chart: cdktf.stringToTerraform(struct!.chart),
    path: cdktf.stringToTerraform(struct!.path),
    ref: cdktf.stringToTerraform(struct!.ref),
    repo_url: cdktf.stringToTerraform(struct!.repoUrl),
    target_revision: cdktf.stringToTerraform(struct!.targetRevision),
    directory: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryToTerraform(struct!.directory),
    helm: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmToTerraform(struct!.helm),
    kustomize: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeToTerraform(struct!.kustomize),
    plugin: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginToTerraform(struct!.plugin),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    chart: {
      value: cdktf.stringToHclTerraform(struct!.chart),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: cdktf.stringToHclTerraform(struct!.ref),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    repo_url: {
      value: cdktf.stringToHclTerraform(struct!.repoUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    target_revision: {
      value: cdktf.stringToHclTerraform(struct!.targetRevision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    directory: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryToHclTerraform(struct!.directory),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryList",
    },
    helm: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmToHclTerraform(struct!.helm),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmList",
    },
    kustomize: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeToHclTerraform(struct!.kustomize),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeList",
    },
    plugin: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginToHclTerraform(struct!.plugin),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chart !== undefined) {
      hasAnyValues = true;
      internalValueResult.chart = this._chart;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ref !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref;
    }
    if (this._repoUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.repoUrl = this._repoUrl;
    }
    if (this._targetRevision !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetRevision = this._targetRevision;
    }
    if (this._directory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.directory = this._directory?.internalValue;
    }
    if (this._helm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.helm = this._helm?.internalValue;
    }
    if (this._kustomize?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kustomize = this._kustomize?.internalValue;
    }
    if (this._plugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chart = undefined;
      this._path = undefined;
      this._ref = undefined;
      this._repoUrl = undefined;
      this._targetRevision = undefined;
      this._directory.internalValue = undefined;
      this._helm.internalValue = undefined;
      this._kustomize.internalValue = undefined;
      this._plugin.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chart = value.chart;
      this._path = value.path;
      this._ref = value.ref;
      this._repoUrl = value.repoUrl;
      this._targetRevision = value.targetRevision;
      this._directory.internalValue = value.directory;
      this._helm.internalValue = value.helm;
      this._kustomize.internalValue = value.kustomize;
      this._plugin.internalValue = value.plugin;
    }
  }

  // chart - computed: false, optional: true, required: false
  private _chart?: string; 
  public get chart() {
    return this.getStringAttribute('chart');
  }
  public set chart(value: string) {
    this._chart = value;
  }
  public resetChart() {
    this._chart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chartInput() {
    return this._chart;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ref - computed: false, optional: true, required: false
  private _ref?: string; 
  public get ref() {
    return this.getStringAttribute('ref');
  }
  public set ref(value: string) {
    this._ref = value;
  }
  public resetRef() {
    this._ref = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref;
  }

  // repo_url - computed: false, optional: false, required: true
  private _repoUrl?: string; 
  public get repoUrl() {
    return this.getStringAttribute('repo_url');
  }
  public set repoUrl(value: string) {
    this._repoUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get repoUrlInput() {
    return this._repoUrl;
  }

  // target_revision - computed: false, optional: true, required: false
  private _targetRevision?: string; 
  public get targetRevision() {
    return this.getStringAttribute('target_revision');
  }
  public set targetRevision(value: string) {
    this._targetRevision = value;
  }
  public resetTargetRevision() {
    this._targetRevision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetRevisionInput() {
    return this._targetRevision;
  }

  // directory - computed: false, optional: true, required: false
  private _directory = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectoryOutputReference(this, "directory");
  public get directory() {
    return this._directory;
  }
  public putDirectory(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesDirectory) {
    this._directory.internalValue = value;
  }
  public resetDirectory() {
    this._directory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get directoryInput() {
    return this._directory.internalValue;
  }

  // helm - computed: false, optional: true, required: false
  private _helm = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelmOutputReference(this, "helm");
  public get helm() {
    return this._helm;
  }
  public putHelm(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesHelm) {
    this._helm.internalValue = value;
  }
  public resetHelm() {
    this._helm.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get helmInput() {
    return this._helm.internalValue;
  }

  // kustomize - computed: false, optional: true, required: false
  private _kustomize = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomizeOutputReference(this, "kustomize");
  public get kustomize() {
    return this._kustomize;
  }
  public putKustomize(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesKustomize) {
    this._kustomize.internalValue = value;
  }
  public resetKustomize() {
    this._kustomize.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kustomizeInput() {
    return this._kustomize.internalValue;
  }

  // plugin - computed: false, optional: true, required: false
  private _plugin = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPluginOutputReference(this, "plugin");
  public get plugin() {
    return this._plugin;
  }
  public putPlugin(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesPlugin) {
    this._plugin.internalValue = value;
  }
  public resetPlugin() {
    this._plugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin.internalValue;
  }
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesList extends cdktf.ComplexList {
  public internalValue? : PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSources[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesOutputReference {
    return new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomated {
  /**
  * Allows apps have zero live resources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#allow_empty PlatformGitopsApplicationset#allow_empty}
  */
  readonly allowEmpty?: boolean | cdktf.IResolvable;
  /**
  * Whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#prune PlatformGitopsApplicationset#prune}
  */
  readonly prune?: boolean | cdktf.IResolvable;
  /**
  * Whether to revert resources back to their desired state upon modification in the cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#self_heal PlatformGitopsApplicationset#self_heal}
  */
  readonly selfHeal?: boolean | cdktf.IResolvable;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomated): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_empty: cdktf.booleanToTerraform(struct!.allowEmpty),
    prune: cdktf.booleanToTerraform(struct!.prune),
    self_heal: cdktf.booleanToTerraform(struct!.selfHeal),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomated): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_empty: {
      value: cdktf.booleanToHclTerraform(struct!.allowEmpty),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prune: {
      value: cdktf.booleanToHclTerraform(struct!.prune),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    self_heal: {
      value: cdktf.booleanToHclTerraform(struct!.selfHeal),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomated | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowEmpty !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowEmpty = this._allowEmpty;
    }
    if (this._prune !== undefined) {
      hasAnyValues = true;
      internalValueResult.prune = this._prune;
    }
    if (this._selfHeal !== undefined) {
      hasAnyValues = true;
      internalValueResult.selfHeal = this._selfHeal;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomated | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowEmpty = undefined;
      this._prune = undefined;
      this._selfHeal = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowEmpty = value.allowEmpty;
      this._prune = value.prune;
      this._selfHeal = value.selfHeal;
    }
  }

  // allow_empty - computed: false, optional: true, required: false
  private _allowEmpty?: boolean | cdktf.IResolvable; 
  public get allowEmpty() {
    return this.getBooleanAttribute('allow_empty');
  }
  public set allowEmpty(value: boolean | cdktf.IResolvable) {
    this._allowEmpty = value;
  }
  public resetAllowEmpty() {
    this._allowEmpty = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowEmptyInput() {
    return this._allowEmpty;
  }

  // prune - computed: false, optional: true, required: false
  private _prune?: boolean | cdktf.IResolvable; 
  public get prune() {
    return this.getBooleanAttribute('prune');
  }
  public set prune(value: boolean | cdktf.IResolvable) {
    this._prune = value;
  }
  public resetPrune() {
    this._prune = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pruneInput() {
    return this._prune;
  }

  // self_heal - computed: false, optional: true, required: false
  private _selfHeal?: boolean | cdktf.IResolvable; 
  public get selfHeal() {
    return this.getBooleanAttribute('self_heal');
  }
  public set selfHeal(value: boolean | cdktf.IResolvable) {
    this._selfHeal = value;
  }
  public resetSelfHeal() {
    this._selfHeal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selfHealInput() {
    return this._selfHeal;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadata {
  /**
  * Annotations to apply to the namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#annotations PlatformGitopsApplicationset#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Labels to apply to the namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#labels PlatformGitopsApplicationset#labels}
  */
  readonly labels?: { [key: string]: string };
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadata | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadata | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoff {
  /**
  * Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. `2m`, `1h`), as a string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#duration PlatformGitopsApplicationset#duration}
  */
  readonly duration?: string;
  /**
  * Factor to multiply the base duration after each failed retry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#factor PlatformGitopsApplicationset#factor}
  */
  readonly factor?: string;
  /**
  * Maximum amount of time allowed for the backoff strategy. Default unit is seconds, but could also be a duration (e.g. `2m`, `1h`), as a string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#max_duration PlatformGitopsApplicationset#max_duration}
  */
  readonly maxDuration?: string;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoff): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
    factor: cdktf.stringToTerraform(struct!.factor),
    max_duration: cdktf.stringToTerraform(struct!.maxDuration),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoff): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    factor: {
      value: cdktf.stringToHclTerraform(struct!.factor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoff | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    if (this._factor !== undefined) {
      hasAnyValues = true;
      internalValueResult.factor = this._factor;
    }
    if (this._maxDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDuration = this._maxDuration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoff | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._duration = undefined;
      this._factor = undefined;
      this._maxDuration = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._duration = value.duration;
      this._factor = value.factor;
      this._maxDuration = value.maxDuration;
    }
  }

  // duration - computed: false, optional: true, required: false
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  public resetDuration() {
    this._duration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }

  // factor - computed: false, optional: true, required: false
  private _factor?: string; 
  public get factor() {
    return this.getStringAttribute('factor');
  }
  public set factor(value: string) {
    this._factor = value;
  }
  public resetFactor() {
    this._factor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get factorInput() {
    return this._factor;
  }

  // max_duration - computed: false, optional: true, required: false
  private _maxDuration?: string; 
  public get maxDuration() {
    return this.getStringAttribute('max_duration');
  }
  public set maxDuration(value: string) {
    this._maxDuration = value;
  }
  public resetMaxDuration() {
    this._maxDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDurationInput() {
    return this._maxDuration;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetry {
  /**
  * Maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#limit PlatformGitopsApplicationset#limit}
  */
  readonly limit?: string;
  /**
  * backoff block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#backoff PlatformGitopsApplicationset#backoff}
  */
  readonly backoff?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoff;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetry): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limit: cdktf.stringToTerraform(struct!.limit),
    backoff: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffToTerraform(struct!.backoff),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetry): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limit: {
      value: cdktf.stringToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    backoff: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffToHclTerraform(struct!.backoff),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetry | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._backoff?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoff = this._backoff?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetry | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._limit = undefined;
      this._backoff.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._limit = value.limit;
      this._backoff.internalValue = value.backoff;
    }
  }

  // limit - computed: false, optional: true, required: false
  private _limit?: string; 
  public get limit() {
    return this.getStringAttribute('limit');
  }
  public set limit(value: string) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // backoff - computed: false, optional: true, required: false
  private _backoff = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoffOutputReference(this, "backoff");
  public get backoff() {
    return this._backoff;
  }
  public putBackoff(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryBackoff) {
    this._backoff.internalValue = value;
  }
  public resetBackoff() {
    this._backoff.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffInput() {
    return this._backoff.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicy {
  /**
  * List of sync options. More info: https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sync_options PlatformGitopsApplicationset#sync_options}
  */
  readonly syncOptions?: string[];
  /**
  * automated block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#automated PlatformGitopsApplicationset#automated}
  */
  readonly automated?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomated;
  /**
  * managed_namespace_metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#managed_namespace_metadata PlatformGitopsApplicationset#managed_namespace_metadata}
  */
  readonly managedNamespaceMetadata?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadata;
  /**
  * retry block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#retry PlatformGitopsApplicationset#retry}
  */
  readonly retry?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetry;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sync_options: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.syncOptions),
    automated: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedToTerraform(struct!.automated),
    managed_namespace_metadata: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataToTerraform(struct!.managedNamespaceMetadata),
    retry: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryToTerraform(struct!.retry),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicy): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sync_options: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.syncOptions),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    automated: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedToHclTerraform(struct!.automated),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedList",
    },
    managed_namespace_metadata: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataToHclTerraform(struct!.managedNamespaceMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataList",
    },
    retry: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryToHclTerraform(struct!.retry),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicy | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._syncOptions !== undefined) {
      hasAnyValues = true;
      internalValueResult.syncOptions = this._syncOptions;
    }
    if (this._automated?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.automated = this._automated?.internalValue;
    }
    if (this._managedNamespaceMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.managedNamespaceMetadata = this._managedNamespaceMetadata?.internalValue;
    }
    if (this._retry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retry = this._retry?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicy | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._syncOptions = undefined;
      this._automated.internalValue = undefined;
      this._managedNamespaceMetadata.internalValue = undefined;
      this._retry.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._syncOptions = value.syncOptions;
      this._automated.internalValue = value.automated;
      this._managedNamespaceMetadata.internalValue = value.managedNamespaceMetadata;
      this._retry.internalValue = value.retry;
    }
  }

  // sync_options - computed: false, optional: true, required: false
  private _syncOptions?: string[]; 
  public get syncOptions() {
    return this.getListAttribute('sync_options');
  }
  public set syncOptions(value: string[]) {
    this._syncOptions = value;
  }
  public resetSyncOptions() {
    this._syncOptions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syncOptionsInput() {
    return this._syncOptions;
  }

  // automated - computed: false, optional: true, required: false
  private _automated = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomatedOutputReference(this, "automated");
  public get automated() {
    return this._automated;
  }
  public putAutomated(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyAutomated) {
    this._automated.internalValue = value;
  }
  public resetAutomated() {
    this._automated.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automatedInput() {
    return this._automated.internalValue;
  }

  // managed_namespace_metadata - computed: false, optional: true, required: false
  private _managedNamespaceMetadata = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadataOutputReference(this, "managed_namespace_metadata");
  public get managedNamespaceMetadata() {
    return this._managedNamespaceMetadata;
  }
  public putManagedNamespaceMetadata(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyManagedNamespaceMetadata) {
    this._managedNamespaceMetadata.internalValue = value;
  }
  public resetManagedNamespaceMetadata() {
    this._managedNamespaceMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managedNamespaceMetadataInput() {
    return this._managedNamespaceMetadata.internalValue;
  }

  // retry - computed: false, optional: true, required: false
  private _retry = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetryOutputReference(this, "retry");
  public get retry() {
    return this._retry;
  }
  public putRetry(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyRetry) {
    this._retry.internalValue = value;
  }
  public resetRetry() {
    this._retry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryInput() {
    return this._retry.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplateSpec {
  /**
  * The project the application belongs to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#project PlatformGitopsApplicationset#project}
  */
  readonly project?: string;
  /**
  * Limits the number of items kept in the application's revision history, which is used for informational purposes as well as for rollbacks to previous versions. This should only be changed in exceptional circumstances. Setting to zero will store no history. This will reduce storage used. Increasing will increase the space used to store the history, so we do not recommend increasing it. Default is 10.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#revision_history_limit PlatformGitopsApplicationset#revision_history_limit}
  */
  readonly revisionHistoryLimit?: string;
  /**
  * destination block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#destination PlatformGitopsApplicationset#destination}
  */
  readonly destination: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestination;
  /**
  * ignore_difference block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_difference PlatformGitopsApplicationset#ignore_difference}
  */
  readonly ignoreDifference?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifference[] | cdktf.IResolvable;
  /**
  * info block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#info PlatformGitopsApplicationset#info}
  */
  readonly info?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfo[] | cdktf.IResolvable;
  /**
  * source block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#source PlatformGitopsApplicationset#source}
  */
  readonly source: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSource[] | cdktf.IResolvable;
  /**
  * sources block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sources PlatformGitopsApplicationset#sources}
  */
  readonly sources?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSources[] | cdktf.IResolvable;
  /**
  * sync_policy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sync_policy PlatformGitopsApplicationset#sync_policy}
  */
  readonly syncPolicy?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicy;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpec): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    project: cdktf.stringToTerraform(struct!.project),
    revision_history_limit: cdktf.stringToTerraform(struct!.revisionHistoryLimit),
    destination: platformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationToTerraform(struct!.destination),
    ignore_difference: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceToTerraform, true)(struct!.ignoreDifference),
    info: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoToTerraform, true)(struct!.info),
    source: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceToTerraform, true)(struct!.source),
    sources: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesToTerraform, true)(struct!.sources),
    sync_policy: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyToTerraform(struct!.syncPolicy),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateSpecToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplateSpec): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    revision_history_limit: {
      value: cdktf.stringToHclTerraform(struct!.revisionHistoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    destination: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationToHclTerraform(struct!.destination),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationList",
    },
    ignore_difference: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceToHclTerraform, true)(struct!.ignoreDifference),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceList",
    },
    info: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoToHclTerraform, true)(struct!.info),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoList",
    },
    source: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceToHclTerraform, true)(struct!.source),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceList",
    },
    sources: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesToHclTerraform, true)(struct!.sources),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesList",
    },
    sync_policy: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyToHclTerraform(struct!.syncPolicy),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplateSpec | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    if (this._revisionHistoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.revisionHistoryLimit = this._revisionHistoryLimit;
    }
    if (this._destination?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.destination = this._destination?.internalValue;
    }
    if (this._ignoreDifference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreDifference = this._ignoreDifference?.internalValue;
    }
    if (this._info?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.info = this._info?.internalValue;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._sources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sources = this._sources?.internalValue;
    }
    if (this._syncPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.syncPolicy = this._syncPolicy?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpec | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._project = undefined;
      this._revisionHistoryLimit = undefined;
      this._destination.internalValue = undefined;
      this._ignoreDifference.internalValue = undefined;
      this._info.internalValue = undefined;
      this._source.internalValue = undefined;
      this._sources.internalValue = undefined;
      this._syncPolicy.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._project = value.project;
      this._revisionHistoryLimit = value.revisionHistoryLimit;
      this._destination.internalValue = value.destination;
      this._ignoreDifference.internalValue = value.ignoreDifference;
      this._info.internalValue = value.info;
      this._source.internalValue = value.source;
      this._sources.internalValue = value.sources;
      this._syncPolicy.internalValue = value.syncPolicy;
    }
  }

  // project - computed: false, optional: true, required: false
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  public resetProject() {
    this._project = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }

  // revision_history_limit - computed: true, optional: true, required: false
  private _revisionHistoryLimit?: string; 
  public get revisionHistoryLimit() {
    return this.getStringAttribute('revision_history_limit');
  }
  public set revisionHistoryLimit(value: string) {
    this._revisionHistoryLimit = value;
  }
  public resetRevisionHistoryLimit() {
    this._revisionHistoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get revisionHistoryLimitInput() {
    return this._revisionHistoryLimit;
  }

  // destination - computed: false, optional: false, required: true
  private _destination = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestinationOutputReference(this, "destination");
  public get destination() {
    return this._destination;
  }
  public putDestination(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecDestination) {
    this._destination.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationInput() {
    return this._destination.internalValue;
  }

  // ignore_difference - computed: false, optional: true, required: false
  private _ignoreDifference = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifferenceList(this, "ignore_difference", false);
  public get ignoreDifference() {
    return this._ignoreDifference;
  }
  public putIgnoreDifference(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecIgnoreDifference[] | cdktf.IResolvable) {
    this._ignoreDifference.internalValue = value;
  }
  public resetIgnoreDifference() {
    this._ignoreDifference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreDifferenceInput() {
    return this._ignoreDifference.internalValue;
  }

  // info - computed: false, optional: true, required: false
  private _info = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfoList(this, "info", false);
  public get info() {
    return this._info;
  }
  public putInfo(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecInfo[] | cdktf.IResolvable) {
    this._info.internalValue = value;
  }
  public resetInfo() {
    this._info.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get infoInput() {
    return this._info.internalValue;
  }

  // source - computed: false, optional: false, required: true
  private _source = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourceList(this, "source", false);
  public get source() {
    return this._source;
  }
  public putSource(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSource[] | cdktf.IResolvable) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // sources - computed: false, optional: true, required: false
  private _sources = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSourcesList(this, "sources", false);
  public get sources() {
    return this._sources;
  }
  public putSources(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSources[] | cdktf.IResolvable) {
    this._sources.internalValue = value;
  }
  public resetSources() {
    this._sources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourcesInput() {
    return this._sources.internalValue;
  }

  // sync_policy - computed: false, optional: true, required: false
  private _syncPolicy = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicyOutputReference(this, "sync_policy");
  public get syncPolicy() {
    return this._syncPolicy;
  }
  public putSyncPolicy(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecSyncPolicy) {
    this._syncPolicy.internalValue = value;
  }
  public resetSyncPolicy() {
    this._syncPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syncPolicyInput() {
    return this._syncPolicy.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpecTemplate {
  /**
  * metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#metadata PlatformGitopsApplicationset#metadata}
  */
  readonly metadata: PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadata;
  /**
  * spec block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#spec PlatformGitopsApplicationset#spec}
  */
  readonly spec: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpec;
}

export function platformGitopsApplicationsetApplicationsetSpecTemplateToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: platformGitopsApplicationsetApplicationsetSpecTemplateMetadataToTerraform(struct!.metadata),
    spec: platformGitopsApplicationsetApplicationsetSpecTemplateSpecToTerraform(struct!.spec),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecTemplateToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecTemplateOutputReference | PlatformGitopsApplicationsetApplicationsetSpecTemplate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadataList",
    },
    spec: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpecTemplate | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpecTemplate | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: false, required: true
  private _metadata = new PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: false, required: true
  private _spec = new PlatformGitopsApplicationsetApplicationsetSpecTemplateSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: PlatformGitopsApplicationsetApplicationsetSpecTemplateSpec) {
    this._spec.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationsetSpec {
  /**
  * Enable Go templating for the template field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#go_template PlatformGitopsApplicationset#go_template}
  */
  readonly goTemplate?: boolean | cdktf.IResolvable;
  /**
  * Optional list of go templating options, see https://pkg.go.dev/text/template#Template.Optional. This is only relevant if `goTemplate` is true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#go_template_options PlatformGitopsApplicationset#go_template_options}
  */
  readonly goTemplateOptions?: string[];
  /**
  * generator block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#generator PlatformGitopsApplicationset#generator}
  */
  readonly generator: PlatformGitopsApplicationsetApplicationsetSpecGenerator[] | cdktf.IResolvable;
  /**
  * ignore_application_differences block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#ignore_application_differences PlatformGitopsApplicationset#ignore_application_differences}
  */
  readonly ignoreApplicationDifferences?: PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferences[] | cdktf.IResolvable;
  /**
  * strategy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#strategy PlatformGitopsApplicationset#strategy}
  */
  readonly strategy?: PlatformGitopsApplicationsetApplicationsetSpecStrategy;
  /**
  * sync_policy block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#sync_policy PlatformGitopsApplicationset#sync_policy}
  */
  readonly syncPolicy?: PlatformGitopsApplicationsetApplicationsetSpecSyncPolicy;
  /**
  * template block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#template PlatformGitopsApplicationset#template}
  */
  readonly template: PlatformGitopsApplicationsetApplicationsetSpecTemplate;
}

export function platformGitopsApplicationsetApplicationsetSpecToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecOutputReference | PlatformGitopsApplicationsetApplicationsetSpec): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    go_template: cdktf.booleanToTerraform(struct!.goTemplate),
    go_template_options: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.goTemplateOptions),
    generator: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecGeneratorToTerraform, true)(struct!.generator),
    ignore_application_differences: cdktf.listMapper(platformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesToTerraform, true)(struct!.ignoreApplicationDifferences),
    strategy: platformGitopsApplicationsetApplicationsetSpecStrategyToTerraform(struct!.strategy),
    sync_policy: platformGitopsApplicationsetApplicationsetSpecSyncPolicyToTerraform(struct!.syncPolicy),
    template: platformGitopsApplicationsetApplicationsetSpecTemplateToTerraform(struct!.template),
  }
}


export function platformGitopsApplicationsetApplicationsetSpecToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetSpecOutputReference | PlatformGitopsApplicationsetApplicationsetSpec): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    go_template: {
      value: cdktf.booleanToHclTerraform(struct!.goTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    go_template_options: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.goTemplateOptions),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    generator: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecGeneratorToHclTerraform, true)(struct!.generator),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecGeneratorList",
    },
    ignore_application_differences: {
      value: cdktf.listMapperHcl(platformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesToHclTerraform, true)(struct!.ignoreApplicationDifferences),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesList",
    },
    strategy: {
      value: platformGitopsApplicationsetApplicationsetSpecStrategyToHclTerraform(struct!.strategy),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecStrategyList",
    },
    sync_policy: {
      value: platformGitopsApplicationsetApplicationsetSpecSyncPolicyToHclTerraform(struct!.syncPolicy),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecSyncPolicyList",
    },
    template: {
      value: platformGitopsApplicationsetApplicationsetSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecTemplateList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationsetSpec | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._goTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.goTemplate = this._goTemplate;
    }
    if (this._goTemplateOptions !== undefined) {
      hasAnyValues = true;
      internalValueResult.goTemplateOptions = this._goTemplateOptions;
    }
    if (this._generator?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.generator = this._generator?.internalValue;
    }
    if (this._ignoreApplicationDifferences?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreApplicationDifferences = this._ignoreApplicationDifferences?.internalValue;
    }
    if (this._strategy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy?.internalValue;
    }
    if (this._syncPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.syncPolicy = this._syncPolicy?.internalValue;
    }
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationsetSpec | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._goTemplate = undefined;
      this._goTemplateOptions = undefined;
      this._generator.internalValue = undefined;
      this._ignoreApplicationDifferences.internalValue = undefined;
      this._strategy.internalValue = undefined;
      this._syncPolicy.internalValue = undefined;
      this._template.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._goTemplate = value.goTemplate;
      this._goTemplateOptions = value.goTemplateOptions;
      this._generator.internalValue = value.generator;
      this._ignoreApplicationDifferences.internalValue = value.ignoreApplicationDifferences;
      this._strategy.internalValue = value.strategy;
      this._syncPolicy.internalValue = value.syncPolicy;
      this._template.internalValue = value.template;
    }
  }

  // go_template - computed: false, optional: true, required: false
  private _goTemplate?: boolean | cdktf.IResolvable; 
  public get goTemplate() {
    return this.getBooleanAttribute('go_template');
  }
  public set goTemplate(value: boolean | cdktf.IResolvable) {
    this._goTemplate = value;
  }
  public resetGoTemplate() {
    this._goTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get goTemplateInput() {
    return this._goTemplate;
  }

  // go_template_options - computed: false, optional: true, required: false
  private _goTemplateOptions?: string[]; 
  public get goTemplateOptions() {
    return this.getListAttribute('go_template_options');
  }
  public set goTemplateOptions(value: string[]) {
    this._goTemplateOptions = value;
  }
  public resetGoTemplateOptions() {
    this._goTemplateOptions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get goTemplateOptionsInput() {
    return this._goTemplateOptions;
  }

  // generator - computed: false, optional: false, required: true
  private _generator = new PlatformGitopsApplicationsetApplicationsetSpecGeneratorList(this, "generator", false);
  public get generator() {
    return this._generator;
  }
  public putGenerator(value: PlatformGitopsApplicationsetApplicationsetSpecGenerator[] | cdktf.IResolvable) {
    this._generator.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get generatorInput() {
    return this._generator.internalValue;
  }

  // ignore_application_differences - computed: false, optional: true, required: false
  private _ignoreApplicationDifferences = new PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferencesList(this, "ignore_application_differences", false);
  public get ignoreApplicationDifferences() {
    return this._ignoreApplicationDifferences;
  }
  public putIgnoreApplicationDifferences(value: PlatformGitopsApplicationsetApplicationsetSpecIgnoreApplicationDifferences[] | cdktf.IResolvable) {
    this._ignoreApplicationDifferences.internalValue = value;
  }
  public resetIgnoreApplicationDifferences() {
    this._ignoreApplicationDifferences.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreApplicationDifferencesInput() {
    return this._ignoreApplicationDifferences.internalValue;
  }

  // strategy - computed: false, optional: true, required: false
  private _strategy = new PlatformGitopsApplicationsetApplicationsetSpecStrategyOutputReference(this, "strategy");
  public get strategy() {
    return this._strategy;
  }
  public putStrategy(value: PlatformGitopsApplicationsetApplicationsetSpecStrategy) {
    this._strategy.internalValue = value;
  }
  public resetStrategy() {
    this._strategy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy.internalValue;
  }

  // sync_policy - computed: false, optional: true, required: false
  private _syncPolicy = new PlatformGitopsApplicationsetApplicationsetSpecSyncPolicyOutputReference(this, "sync_policy");
  public get syncPolicy() {
    return this._syncPolicy;
  }
  public putSyncPolicy(value: PlatformGitopsApplicationsetApplicationsetSpecSyncPolicy) {
    this._syncPolicy.internalValue = value;
  }
  public resetSyncPolicy() {
    this._syncPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get syncPolicyInput() {
    return this._syncPolicy.internalValue;
  }

  // template - computed: false, optional: false, required: true
  private _template = new PlatformGitopsApplicationsetApplicationsetSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: PlatformGitopsApplicationsetApplicationsetSpecTemplate) {
    this._template.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface PlatformGitopsApplicationsetApplicationset {
  /**
  * metadata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#metadata PlatformGitopsApplicationset#metadata}
  */
  readonly metadata: PlatformGitopsApplicationsetApplicationsetMetadata;
  /**
  * spec block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/harness/harness/0.39.0/docs/resources/platform_gitops_applicationset#spec PlatformGitopsApplicationset#spec}
  */
  readonly spec: PlatformGitopsApplicationsetApplicationsetSpec;
}

export function platformGitopsApplicationsetApplicationsetToTerraform(struct?: PlatformGitopsApplicationsetApplicationsetOutputReference | PlatformGitopsApplicationsetApplicationset): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: platformGitopsApplicationsetApplicationsetMetadataToTerraform(struct!.metadata),
    spec: platformGitopsApplicationsetApplicationsetSpecToTerraform(struct!.spec),
  }
}


export function platformGitopsApplicationsetApplicationsetToHclTerraform(struct?: PlatformGitopsApplicationsetApplicationsetOutputReference | PlatformGitopsApplicationsetApplicationset): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: platformGitopsApplicationsetApplicationsetMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetMetadataList",
    },
    spec: {
      value: platformGitopsApplicationsetApplicationsetSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "list",
      storageClassType: "PlatformGitopsApplicationsetApplicationsetSpecList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PlatformGitopsApplicationsetApplicationsetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): PlatformGitopsApplicationsetApplicationset | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PlatformGitopsApplicationsetApplicationset | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._metadata.internalValue = undefined;
      this._spec.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._metadata.internalValue = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: false, required: true
  private _metadata = new PlatformGitopsApplicationsetApplicationsetMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PlatformGitopsApplicationsetApplicationsetMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: false, required: true
  private _spec = new PlatformGitopsApplicationsetApplicationsetSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: PlatformGitopsApplicationsetApplicationsetSpec) {
    this._spec.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
