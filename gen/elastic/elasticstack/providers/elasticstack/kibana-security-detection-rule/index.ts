// https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface KibanaSecurityDetectionRuleConfig extends cdktf.TerraformMetaArguments {
  /**
  * Array of automated actions taken when alerts are generated by the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#actions KibanaSecurityDetectionRule#actions}
  */
  readonly actions?: KibanaSecurityDetectionRuleActions[] | cdktf.IResolvable;
  /**
  * Defines alert suppression configuration to reduce duplicate alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#alert_suppression KibanaSecurityDetectionRule#alert_suppression}
  */
  readonly alertSuppression?: KibanaSecurityDetectionRuleAlertSuppression;
  /**
  * Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100. Required for machine_learning rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#anomaly_threshold KibanaSecurityDetectionRule#anomaly_threshold}
  */
  readonly anomalyThreshold?: number;
  /**
  * The rule's author.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#author KibanaSecurityDetectionRule#author}
  */
  readonly author?: string[];
  /**
  * Determines if the rule acts as a building block. If set, value must be `default`. Building-block alerts are not displayed in the UI by default and are used as a foundation for other rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#building_block_type KibanaSecurityDetectionRule#building_block_type}
  */
  readonly buildingBlockType?: string;
  /**
  * Number of concurrent searches for threat intelligence. Optional for threat_match rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#concurrent_searches KibanaSecurityDetectionRule#concurrent_searches}
  */
  readonly concurrentSearches?: number;
  /**
  * Data view ID for the rule. Not supported for esql and machine_learning rule types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#data_view_id KibanaSecurityDetectionRule#data_view_id}
  */
  readonly dataViewId?: string;
  /**
  * The rule's description.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#description KibanaSecurityDetectionRule#description}
  */
  readonly description: string;
  /**
  * Determines whether the rule is enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#enabled KibanaSecurityDetectionRule#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Array of exception containers to prevent the rule from generating alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#exceptions_list KibanaSecurityDetectionRule#exceptions_list}
  */
  readonly exceptionsList?: KibanaSecurityDetectionRuleExceptionsListStruct[] | cdktf.IResolvable;
  /**
  * String array used to describe common reasons why the rule may issue false-positive alerts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#false_positives KibanaSecurityDetectionRule#false_positives}
  */
  readonly falsePositives?: string[];
  /**
  * Query and filter context array to define alert conditions as JSON. Supports complex filter structures including bool queries, term filters, range filters, etc. Available for all rule types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#filters KibanaSecurityDetectionRule#filters}
  */
  readonly filters?: string;
  /**
  * Time from which data is analyzed each time the rule runs, using a date math range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#from KibanaSecurityDetectionRule#from}
  */
  readonly from?: string;
  /**
  * Start date to use when checking if a term has been seen before. Supports relative dates like 'now-30d'. Required for new_terms rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#history_window_start KibanaSecurityDetectionRule#history_window_start}
  */
  readonly historyWindowStart?: string;
  /**
  * Indices on which the rule functions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#index KibanaSecurityDetectionRule#index}
  */
  readonly index?: string[];
  /**
  * Frequency of rule execution, using a date math range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#interval KibanaSecurityDetectionRule#interval}
  */
  readonly interval?: string;
  /**
  * Array of field names to include in alert investigation. Available for all rule types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#investigation_fields KibanaSecurityDetectionRule#investigation_fields}
  */
  readonly investigationFields?: string[];
  /**
  * Number of items to search for in each concurrent search. Optional for threat_match rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#items_per_search KibanaSecurityDetectionRule#items_per_search}
  */
  readonly itemsPerSearch?: number;
  /**
  * The query language (KQL or Lucene).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#language KibanaSecurityDetectionRule#language}
  */
  readonly language?: string;
  /**
  * The rule's license.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#license KibanaSecurityDetectionRule#license}
  */
  readonly license?: string;
  /**
  * Machine learning job ID(s) the rule monitors for anomaly scores. Required for machine_learning rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#machine_learning_job_id KibanaSecurityDetectionRule#machine_learning_job_id}
  */
  readonly machineLearningJobId?: string[];
  /**
  * Maximum number of alerts the rule can create during a single run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#max_signals KibanaSecurityDetectionRule#max_signals}
  */
  readonly maxSignals?: number;
  /**
  * A human-readable name for the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#name KibanaSecurityDetectionRule#name}
  */
  readonly name: string;
  /**
  * Alerts index namespace. Available for all rule types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#namespace KibanaSecurityDetectionRule#namespace}
  */
  readonly namespace?: string;
  /**
  * Field names containing the new terms. Required for new_terms rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#new_terms_fields KibanaSecurityDetectionRule#new_terms_fields}
  */
  readonly newTermsFields?: string[];
  /**
  * Notes to help investigate alerts produced by the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#note KibanaSecurityDetectionRule#note}
  */
  readonly note?: string;
  /**
  * The query language definition.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#query KibanaSecurityDetectionRule#query}
  */
  readonly query?: string;
  /**
  * String array containing references and URLs to sources of additional information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#references KibanaSecurityDetectionRule#references}
  */
  readonly references?: string[];
  /**
  * Array of related integrations that provide additional context for the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#related_integrations KibanaSecurityDetectionRule#related_integrations}
  */
  readonly relatedIntegrations?: KibanaSecurityDetectionRuleRelatedIntegrations[] | cdktf.IResolvable;
  /**
  * Array of Elasticsearch fields and types that must be present in source indices for the rule to function properly.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#required_fields KibanaSecurityDetectionRule#required_fields}
  */
  readonly requiredFields?: KibanaSecurityDetectionRuleRequiredFields[] | cdktf.IResolvable;
  /**
  * Array of response actions to take when alerts are generated by the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#response_actions KibanaSecurityDetectionRule#response_actions}
  */
  readonly responseActions?: KibanaSecurityDetectionRuleResponseActions[] | cdktf.IResolvable;
  /**
  * A numerical representation of the alert's severity from 0 to 100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#risk_score KibanaSecurityDetectionRule#risk_score}
  */
  readonly riskScore?: number;
  /**
  * Array of risk score mappings to override the default risk score based on source event field values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#risk_score_mapping KibanaSecurityDetectionRule#risk_score_mapping}
  */
  readonly riskScoreMapping?: KibanaSecurityDetectionRuleRiskScoreMapping[] | cdktf.IResolvable;
  /**
  * A stable unique identifier for the rule object. If omitted, a UUID is generated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#rule_id KibanaSecurityDetectionRule#rule_id}
  */
  readonly ruleId?: string;
  /**
  * Override the rule name in Kibana. Available for all rule types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#rule_name_override KibanaSecurityDetectionRule#rule_name_override}
  */
  readonly ruleNameOverride?: string;
  /**
  * Identifier of the saved query used for the rule. Required for saved_query rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#saved_id KibanaSecurityDetectionRule#saved_id}
  */
  readonly savedId?: string;
  /**
  * Setup guide with instructions on rule prerequisites.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#setup KibanaSecurityDetectionRule#setup}
  */
  readonly setup?: string;
  /**
  * Severity level of alerts produced by the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#severity KibanaSecurityDetectionRule#severity}
  */
  readonly severity?: string;
  /**
  * Array of severity mappings to override the default severity based on source event field values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#severity_mapping KibanaSecurityDetectionRule#severity_mapping}
  */
  readonly severityMapping?: KibanaSecurityDetectionRuleSeverityMapping[] | cdktf.IResolvable;
  /**
  * An identifier for the space. If space_id is not provided, the default space is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#space_id KibanaSecurityDetectionRule#space_id}
  */
  readonly spaceId?: string;
  /**
  * String array containing words and phrases to help categorize, filter, and search rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#tags KibanaSecurityDetectionRule#tags}
  */
  readonly tags?: string[];
  /**
  * MITRE ATT&CK framework threat information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#threat KibanaSecurityDetectionRule#threat}
  */
  readonly threat?: KibanaSecurityDetectionRuleThreat[] | cdktf.IResolvable;
  /**
  * Additional filters for threat intelligence data. Optional for threat_match rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#threat_filters KibanaSecurityDetectionRule#threat_filters}
  */
  readonly threatFilters?: string[];
  /**
  * Array of index patterns for the threat intelligence indices. Required for threat_match rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#threat_index KibanaSecurityDetectionRule#threat_index}
  */
  readonly threatIndex?: string[];
  /**
  * Path to the threat indicator in the indicator documents. Optional for threat_match rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#threat_indicator_path KibanaSecurityDetectionRule#threat_indicator_path}
  */
  readonly threatIndicatorPath?: string;
  /**
  * Array of threat mappings that specify how to match events with threat intelligence. Required for threat_match rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#threat_mapping KibanaSecurityDetectionRule#threat_mapping}
  */
  readonly threatMapping?: KibanaSecurityDetectionRuleThreatMapping[] | cdktf.IResolvable;
  /**
  * Query used to filter threat intelligence data. Optional for threat_match rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#threat_query KibanaSecurityDetectionRule#threat_query}
  */
  readonly threatQuery?: string;
  /**
  * Threshold settings for the rule. Required for threshold rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#threshold KibanaSecurityDetectionRule#threshold}
  */
  readonly threshold?: KibanaSecurityDetectionRuleThreshold;
  /**
  * Sets the tiebreaker field. Required for EQL rules when event.dataset is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#tiebreaker_field KibanaSecurityDetectionRule#tiebreaker_field}
  */
  readonly tiebreakerField?: string;
  /**
  * Timeline template ID for the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#timeline_id KibanaSecurityDetectionRule#timeline_id}
  */
  readonly timelineId?: string;
  /**
  * Timeline template title for the rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#timeline_title KibanaSecurityDetectionRule#timeline_title}
  */
  readonly timelineTitle?: string;
  /**
  * Field name to use for timestamp override. Available for all rule types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#timestamp_override KibanaSecurityDetectionRule#timestamp_override}
  */
  readonly timestampOverride?: string;
  /**
  * Disables timestamp override fallback. Available for all rule types.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#timestamp_override_fallback_disabled KibanaSecurityDetectionRule#timestamp_override_fallback_disabled}
  */
  readonly timestampOverrideFallbackDisabled?: boolean | cdktf.IResolvable;
  /**
  * Time to which data is analyzed each time the rule runs, using a date math range.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#to KibanaSecurityDetectionRule#to}
  */
  readonly to?: string;
  /**
  * Rule type. Supported types: query, eql, esql, machine_learning, new_terms, saved_query, threat_match, threshold.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#type KibanaSecurityDetectionRule#type}
  */
  readonly type: string;
  /**
  * The rule's version number.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#version KibanaSecurityDetectionRule#version}
  */
  readonly version?: number;
}
export interface KibanaSecurityDetectionRuleActionsFrequency {
  /**
  * Defines how often rules run actions. Valid values: onActionGroupChange, onActiveAlert, onThrottleInterval.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#notify_when KibanaSecurityDetectionRule#notify_when}
  */
  readonly notifyWhen: string;
  /**
  * Action summary indicates whether we will send a summary notification about all the generated alerts or notification per individual alert.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#summary KibanaSecurityDetectionRule#summary}
  */
  readonly summary: boolean | cdktf.IResolvable;
  /**
  * Time interval for throttling actions (e.g., '1h', '30m', 'no_actions', 'rule').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#throttle KibanaSecurityDetectionRule#throttle}
  */
  readonly throttle: string;
}

export function kibanaSecurityDetectionRuleActionsFrequencyToTerraform(struct?: KibanaSecurityDetectionRuleActionsFrequency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    notify_when: cdktf.stringToTerraform(struct!.notifyWhen),
    summary: cdktf.booleanToTerraform(struct!.summary),
    throttle: cdktf.stringToTerraform(struct!.throttle),
  }
}


export function kibanaSecurityDetectionRuleActionsFrequencyToHclTerraform(struct?: KibanaSecurityDetectionRuleActionsFrequency | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    notify_when: {
      value: cdktf.stringToHclTerraform(struct!.notifyWhen),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    summary: {
      value: cdktf.booleanToHclTerraform(struct!.summary),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    throttle: {
      value: cdktf.stringToHclTerraform(struct!.throttle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleActionsFrequencyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): KibanaSecurityDetectionRuleActionsFrequency | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._notifyWhen !== undefined) {
      hasAnyValues = true;
      internalValueResult.notifyWhen = this._notifyWhen;
    }
    if (this._summary !== undefined) {
      hasAnyValues = true;
      internalValueResult.summary = this._summary;
    }
    if (this._throttle !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttle = this._throttle;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleActionsFrequency | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._notifyWhen = undefined;
      this._summary = undefined;
      this._throttle = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._notifyWhen = value.notifyWhen;
      this._summary = value.summary;
      this._throttle = value.throttle;
    }
  }

  // notify_when - computed: true, optional: false, required: true
  private _notifyWhen?: string; 
  public get notifyWhen() {
    return this.getStringAttribute('notify_when');
  }
  public set notifyWhen(value: string) {
    this._notifyWhen = value;
  }
  // Temporarily expose input value. Use with caution.
  public get notifyWhenInput() {
    return this._notifyWhen;
  }

  // summary - computed: true, optional: false, required: true
  private _summary?: boolean | cdktf.IResolvable; 
  public get summary() {
    return this.getBooleanAttribute('summary');
  }
  public set summary(value: boolean | cdktf.IResolvable) {
    this._summary = value;
  }
  // Temporarily expose input value. Use with caution.
  public get summaryInput() {
    return this._summary;
  }

  // throttle - computed: true, optional: false, required: true
  private _throttle?: string; 
  public get throttle() {
    return this.getStringAttribute('throttle');
  }
  public set throttle(value: string) {
    this._throttle = value;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleInput() {
    return this._throttle;
  }
}
export interface KibanaSecurityDetectionRuleActions {
  /**
  * The action type used for sending notifications (e.g., .slack, .email, .webhook, .pagerduty, etc.).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#action_type_id KibanaSecurityDetectionRule#action_type_id}
  */
  readonly actionTypeId: string;
  /**
  * Object containing an action's conditional filters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#alerts_filter KibanaSecurityDetectionRule#alerts_filter}
  */
  readonly alertsFilter?: { [key: string]: string };
  /**
  * The action frequency defines when the action runs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#frequency KibanaSecurityDetectionRule#frequency}
  */
  readonly frequency?: KibanaSecurityDetectionRuleActionsFrequency;
  /**
  * Optionally groups actions by use cases. Use 'default' for alert notifications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#group KibanaSecurityDetectionRule#group}
  */
  readonly group?: string;
  /**
  * The connector ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#id KibanaSecurityDetectionRule#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Object containing the allowed connector fields, which varies according to the connector type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#params KibanaSecurityDetectionRule#params}
  */
  readonly params: { [key: string]: string };
  /**
  * A unique identifier for the action.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#uuid KibanaSecurityDetectionRule#uuid}
  */
  readonly uuid?: string;
}

export function kibanaSecurityDetectionRuleActionsToTerraform(struct?: KibanaSecurityDetectionRuleActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action_type_id: cdktf.stringToTerraform(struct!.actionTypeId),
    alerts_filter: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.alertsFilter),
    frequency: kibanaSecurityDetectionRuleActionsFrequencyToTerraform(struct!.frequency),
    group: cdktf.stringToTerraform(struct!.group),
    id: cdktf.stringToTerraform(struct!.id),
    params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.params),
    uuid: cdktf.stringToTerraform(struct!.uuid),
  }
}


export function kibanaSecurityDetectionRuleActionsToHclTerraform(struct?: KibanaSecurityDetectionRuleActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action_type_id: {
      value: cdktf.stringToHclTerraform(struct!.actionTypeId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    alerts_filter: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.alertsFilter),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    frequency: {
      value: kibanaSecurityDetectionRuleActionsFrequencyToHclTerraform(struct!.frequency),
      isBlock: true,
      type: "struct",
      storageClassType: "KibanaSecurityDetectionRuleActionsFrequency",
    },
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.params),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    uuid: {
      value: cdktf.stringToHclTerraform(struct!.uuid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actionTypeId !== undefined) {
      hasAnyValues = true;
      internalValueResult.actionTypeId = this._actionTypeId;
    }
    if (this._alertsFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.alertsFilter = this._alertsFilter;
    }
    if (this._frequency?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.frequency = this._frequency?.internalValue;
    }
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._params !== undefined) {
      hasAnyValues = true;
      internalValueResult.params = this._params;
    }
    if (this._uuid !== undefined) {
      hasAnyValues = true;
      internalValueResult.uuid = this._uuid;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actionTypeId = undefined;
      this._alertsFilter = undefined;
      this._frequency.internalValue = undefined;
      this._group = undefined;
      this._id = undefined;
      this._params = undefined;
      this._uuid = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actionTypeId = value.actionTypeId;
      this._alertsFilter = value.alertsFilter;
      this._frequency.internalValue = value.frequency;
      this._group = value.group;
      this._id = value.id;
      this._params = value.params;
      this._uuid = value.uuid;
    }
  }

  // action_type_id - computed: false, optional: false, required: true
  private _actionTypeId?: string; 
  public get actionTypeId() {
    return this.getStringAttribute('action_type_id');
  }
  public set actionTypeId(value: string) {
    this._actionTypeId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get actionTypeIdInput() {
    return this._actionTypeId;
  }

  // alerts_filter - computed: false, optional: true, required: false
  private _alertsFilter?: { [key: string]: string }; 
  public get alertsFilter() {
    return this.getStringMapAttribute('alerts_filter');
  }
  public set alertsFilter(value: { [key: string]: string }) {
    this._alertsFilter = value;
  }
  public resetAlertsFilter() {
    this._alertsFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alertsFilterInput() {
    return this._alertsFilter;
  }

  // frequency - computed: true, optional: true, required: false
  private _frequency = new KibanaSecurityDetectionRuleActionsFrequencyOutputReference(this, "frequency");
  public get frequency() {
    return this._frequency;
  }
  public putFrequency(value: KibanaSecurityDetectionRuleActionsFrequency) {
    this._frequency.internalValue = value;
  }
  public resetFrequency() {
    this._frequency.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get frequencyInput() {
    return this._frequency.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // params - computed: false, optional: false, required: true
  private _params?: { [key: string]: string }; 
  public get params() {
    return this.getStringMapAttribute('params');
  }
  public set params(value: { [key: string]: string }) {
    this._params = value;
  }
  // Temporarily expose input value. Use with caution.
  public get paramsInput() {
    return this._params;
  }

  // uuid - computed: true, optional: true, required: false
  private _uuid?: string; 
  public get uuid() {
    return this.getStringAttribute('uuid');
  }
  public set uuid(value: string) {
    this._uuid = value;
  }
  public resetUuid() {
    this._uuid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uuidInput() {
    return this._uuid;
  }
}

export class KibanaSecurityDetectionRuleActionsList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleActionsOutputReference {
    return new KibanaSecurityDetectionRuleActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleAlertSuppression {
  /**
  * Duration for which alerts are suppressed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#duration KibanaSecurityDetectionRule#duration}
  */
  readonly duration?: string;
  /**
  * Array of field names to group alerts by for suppression.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#group_by KibanaSecurityDetectionRule#group_by}
  */
  readonly groupBy?: string[];
  /**
  * Strategy for handling missing fields in suppression grouping: 'suppress' - only one alert will be created per suppress by bucket, 'doNotSuppress' - per each document a separate alert will be created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#missing_fields_strategy KibanaSecurityDetectionRule#missing_fields_strategy}
  */
  readonly missingFieldsStrategy?: string;
}

export function kibanaSecurityDetectionRuleAlertSuppressionToTerraform(struct?: KibanaSecurityDetectionRuleAlertSuppression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
    group_by: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupBy),
    missing_fields_strategy: cdktf.stringToTerraform(struct!.missingFieldsStrategy),
  }
}


export function kibanaSecurityDetectionRuleAlertSuppressionToHclTerraform(struct?: KibanaSecurityDetectionRuleAlertSuppression | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_by: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupBy),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    missing_fields_strategy: {
      value: cdktf.stringToHclTerraform(struct!.missingFieldsStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleAlertSuppressionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): KibanaSecurityDetectionRuleAlertSuppression | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    if (this._groupBy !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupBy = this._groupBy;
    }
    if (this._missingFieldsStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.missingFieldsStrategy = this._missingFieldsStrategy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleAlertSuppression | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
      this._groupBy = undefined;
      this._missingFieldsStrategy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
      this._groupBy = value.groupBy;
      this._missingFieldsStrategy = value.missingFieldsStrategy;
    }
  }

  // duration - computed: false, optional: true, required: false
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  public resetDuration() {
    this._duration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }

  // group_by - computed: false, optional: true, required: false
  private _groupBy?: string[]; 
  public get groupBy() {
    return this.getListAttribute('group_by');
  }
  public set groupBy(value: string[]) {
    this._groupBy = value;
  }
  public resetGroupBy() {
    this._groupBy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupByInput() {
    return this._groupBy;
  }

  // missing_fields_strategy - computed: false, optional: true, required: false
  private _missingFieldsStrategy?: string; 
  public get missingFieldsStrategy() {
    return this.getStringAttribute('missing_fields_strategy');
  }
  public set missingFieldsStrategy(value: string) {
    this._missingFieldsStrategy = value;
  }
  public resetMissingFieldsStrategy() {
    this._missingFieldsStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get missingFieldsStrategyInput() {
    return this._missingFieldsStrategy;
  }
}
export interface KibanaSecurityDetectionRuleExceptionsListStruct {
  /**
  * The exception container ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#id KibanaSecurityDetectionRule#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * The exception container's list ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#list_id KibanaSecurityDetectionRule#list_id}
  */
  readonly listId: string;
  /**
  * The namespace type for the exception container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#namespace_type KibanaSecurityDetectionRule#namespace_type}
  */
  readonly namespaceType: string;
  /**
  * The type of exception container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#type KibanaSecurityDetectionRule#type}
  */
  readonly type: string;
}

export function kibanaSecurityDetectionRuleExceptionsListStructToTerraform(struct?: KibanaSecurityDetectionRuleExceptionsListStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    list_id: cdktf.stringToTerraform(struct!.listId),
    namespace_type: cdktf.stringToTerraform(struct!.namespaceType),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function kibanaSecurityDetectionRuleExceptionsListStructToHclTerraform(struct?: KibanaSecurityDetectionRuleExceptionsListStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    list_id: {
      value: cdktf.stringToHclTerraform(struct!.listId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace_type: {
      value: cdktf.stringToHclTerraform(struct!.namespaceType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleExceptionsListStructOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleExceptionsListStruct | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._listId !== undefined) {
      hasAnyValues = true;
      internalValueResult.listId = this._listId;
    }
    if (this._namespaceType !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceType = this._namespaceType;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleExceptionsListStruct | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._listId = undefined;
      this._namespaceType = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._listId = value.listId;
      this._namespaceType = value.namespaceType;
      this._type = value.type;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // list_id - computed: false, optional: false, required: true
  private _listId?: string; 
  public get listId() {
    return this.getStringAttribute('list_id');
  }
  public set listId(value: string) {
    this._listId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get listIdInput() {
    return this._listId;
  }

  // namespace_type - computed: false, optional: false, required: true
  private _namespaceType?: string; 
  public get namespaceType() {
    return this.getStringAttribute('namespace_type');
  }
  public set namespaceType(value: string) {
    this._namespaceType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceTypeInput() {
    return this._namespaceType;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class KibanaSecurityDetectionRuleExceptionsListStructList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleExceptionsListStruct[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleExceptionsListStructOutputReference {
    return new KibanaSecurityDetectionRuleExceptionsListStructOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleRelatedIntegrations {
  /**
  * Name of the specific integration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#integration KibanaSecurityDetectionRule#integration}
  */
  readonly integration?: string;
  /**
  * Name of the integration package.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#package KibanaSecurityDetectionRule#package}
  */
  readonly package: string;
  /**
  * Version of the integration package.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#version KibanaSecurityDetectionRule#version}
  */
  readonly version: string;
}

export function kibanaSecurityDetectionRuleRelatedIntegrationsToTerraform(struct?: KibanaSecurityDetectionRuleRelatedIntegrations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    integration: cdktf.stringToTerraform(struct!.integration),
    package: cdktf.stringToTerraform(struct!.package),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function kibanaSecurityDetectionRuleRelatedIntegrationsToHclTerraform(struct?: KibanaSecurityDetectionRuleRelatedIntegrations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    integration: {
      value: cdktf.stringToHclTerraform(struct!.integration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    package: {
      value: cdktf.stringToHclTerraform(struct!.package),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleRelatedIntegrationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleRelatedIntegrations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._integration !== undefined) {
      hasAnyValues = true;
      internalValueResult.integration = this._integration;
    }
    if (this._package !== undefined) {
      hasAnyValues = true;
      internalValueResult.package = this._package;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleRelatedIntegrations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._integration = undefined;
      this._package = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._integration = value.integration;
      this._package = value.package;
      this._version = value.version;
    }
  }

  // integration - computed: false, optional: true, required: false
  private _integration?: string; 
  public get integration() {
    return this.getStringAttribute('integration');
  }
  public set integration(value: string) {
    this._integration = value;
  }
  public resetIntegration() {
    this._integration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get integrationInput() {
    return this._integration;
  }

  // package - computed: false, optional: false, required: true
  private _package?: string; 
  public get package() {
    return this.getStringAttribute('package');
  }
  public set package(value: string) {
    this._package = value;
  }
  // Temporarily expose input value. Use with caution.
  public get packageInput() {
    return this._package;
  }

  // version - computed: false, optional: false, required: true
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class KibanaSecurityDetectionRuleRelatedIntegrationsList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleRelatedIntegrations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleRelatedIntegrationsOutputReference {
    return new KibanaSecurityDetectionRuleRelatedIntegrationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleRequiredFields {
  /**
  * Name of the Elasticsearch field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#name KibanaSecurityDetectionRule#name}
  */
  readonly name: string;
  /**
  * Type of the Elasticsearch field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#type KibanaSecurityDetectionRule#type}
  */
  readonly type: string;
}

export function kibanaSecurityDetectionRuleRequiredFieldsToTerraform(struct?: KibanaSecurityDetectionRuleRequiredFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function kibanaSecurityDetectionRuleRequiredFieldsToHclTerraform(struct?: KibanaSecurityDetectionRuleRequiredFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleRequiredFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleRequiredFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleRequiredFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
    }
  }

  // ecs - computed: true, optional: false, required: false
  public get ecs() {
    return this.getBooleanAttribute('ecs');
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class KibanaSecurityDetectionRuleRequiredFieldsList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleRequiredFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleRequiredFieldsOutputReference {
    return new KibanaSecurityDetectionRuleRequiredFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleResponseActionsParamsConfig {
  /**
  * Field to use instead of process.pid.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#field KibanaSecurityDetectionRule#field}
  */
  readonly field: string;
  /**
  * Whether to overwrite field with process.pid.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#overwrite KibanaSecurityDetectionRule#overwrite}
  */
  readonly overwrite?: boolean | cdktf.IResolvable;
}

export function kibanaSecurityDetectionRuleResponseActionsParamsConfigToTerraform(struct?: KibanaSecurityDetectionRuleResponseActionsParamsConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    overwrite: cdktf.booleanToTerraform(struct!.overwrite),
  }
}


export function kibanaSecurityDetectionRuleResponseActionsParamsConfigToHclTerraform(struct?: KibanaSecurityDetectionRuleResponseActionsParamsConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    overwrite: {
      value: cdktf.booleanToHclTerraform(struct!.overwrite),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleResponseActionsParamsConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): KibanaSecurityDetectionRuleResponseActionsParamsConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._overwrite !== undefined) {
      hasAnyValues = true;
      internalValueResult.overwrite = this._overwrite;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleResponseActionsParamsConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._overwrite = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._overwrite = value.overwrite;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // overwrite - computed: true, optional: true, required: false
  private _overwrite?: boolean | cdktf.IResolvable; 
  public get overwrite() {
    return this.getBooleanAttribute('overwrite');
  }
  public set overwrite(value: boolean | cdktf.IResolvable) {
    this._overwrite = value;
  }
  public resetOverwrite() {
    this._overwrite = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overwriteInput() {
    return this._overwrite;
  }
}
export interface KibanaSecurityDetectionRuleResponseActionsParamsQueries {
  /**
  * ECS field mappings for this query.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#ecs_mapping KibanaSecurityDetectionRule#ecs_mapping}
  */
  readonly ecsMapping?: { [key: string]: string };
  /**
  * Query ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#id KibanaSecurityDetectionRule#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Platform to run the query on.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#platform KibanaSecurityDetectionRule#platform}
  */
  readonly platform?: string;
  /**
  * Query to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#query KibanaSecurityDetectionRule#query}
  */
  readonly query: string;
  /**
  * Whether the query is removed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#removed KibanaSecurityDetectionRule#removed}
  */
  readonly removed?: boolean | cdktf.IResolvable;
  /**
  * Whether this is a snapshot query.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#snapshot KibanaSecurityDetectionRule#snapshot}
  */
  readonly snapshot?: boolean | cdktf.IResolvable;
  /**
  * Query version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#version KibanaSecurityDetectionRule#version}
  */
  readonly version?: string;
}

export function kibanaSecurityDetectionRuleResponseActionsParamsQueriesToTerraform(struct?: KibanaSecurityDetectionRuleResponseActionsParamsQueries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ecs_mapping: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.ecsMapping),
    id: cdktf.stringToTerraform(struct!.id),
    platform: cdktf.stringToTerraform(struct!.platform),
    query: cdktf.stringToTerraform(struct!.query),
    removed: cdktf.booleanToTerraform(struct!.removed),
    snapshot: cdktf.booleanToTerraform(struct!.snapshot),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function kibanaSecurityDetectionRuleResponseActionsParamsQueriesToHclTerraform(struct?: KibanaSecurityDetectionRuleResponseActionsParamsQueries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ecs_mapping: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.ecsMapping),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    platform: {
      value: cdktf.stringToHclTerraform(struct!.platform),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    removed: {
      value: cdktf.booleanToHclTerraform(struct!.removed),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    snapshot: {
      value: cdktf.booleanToHclTerraform(struct!.snapshot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleResponseActionsParamsQueriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleResponseActionsParamsQueries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ecsMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecsMapping = this._ecsMapping;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._platform !== undefined) {
      hasAnyValues = true;
      internalValueResult.platform = this._platform;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._removed !== undefined) {
      hasAnyValues = true;
      internalValueResult.removed = this._removed;
    }
    if (this._snapshot !== undefined) {
      hasAnyValues = true;
      internalValueResult.snapshot = this._snapshot;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleResponseActionsParamsQueries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ecsMapping = undefined;
      this._id = undefined;
      this._platform = undefined;
      this._query = undefined;
      this._removed = undefined;
      this._snapshot = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ecsMapping = value.ecsMapping;
      this._id = value.id;
      this._platform = value.platform;
      this._query = value.query;
      this._removed = value.removed;
      this._snapshot = value.snapshot;
      this._version = value.version;
    }
  }

  // ecs_mapping - computed: false, optional: true, required: false
  private _ecsMapping?: { [key: string]: string }; 
  public get ecsMapping() {
    return this.getStringMapAttribute('ecs_mapping');
  }
  public set ecsMapping(value: { [key: string]: string }) {
    this._ecsMapping = value;
  }
  public resetEcsMapping() {
    this._ecsMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecsMappingInput() {
    return this._ecsMapping;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // platform - computed: false, optional: true, required: false
  private _platform?: string; 
  public get platform() {
    return this.getStringAttribute('platform');
  }
  public set platform(value: string) {
    this._platform = value;
  }
  public resetPlatform() {
    this._platform = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get platformInput() {
    return this._platform;
  }

  // query - computed: false, optional: false, required: true
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // removed - computed: false, optional: true, required: false
  private _removed?: boolean | cdktf.IResolvable; 
  public get removed() {
    return this.getBooleanAttribute('removed');
  }
  public set removed(value: boolean | cdktf.IResolvable) {
    this._removed = value;
  }
  public resetRemoved() {
    this._removed = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removedInput() {
    return this._removed;
  }

  // snapshot - computed: false, optional: true, required: false
  private _snapshot?: boolean | cdktf.IResolvable; 
  public get snapshot() {
    return this.getBooleanAttribute('snapshot');
  }
  public set snapshot(value: boolean | cdktf.IResolvable) {
    this._snapshot = value;
  }
  public resetSnapshot() {
    this._snapshot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snapshotInput() {
    return this._snapshot;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class KibanaSecurityDetectionRuleResponseActionsParamsQueriesList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleResponseActionsParamsQueries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleResponseActionsParamsQueriesOutputReference {
    return new KibanaSecurityDetectionRuleResponseActionsParamsQueriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleResponseActionsParams {
  /**
  * Command to run (endpoint only). Valid values: isolate, kill-process, suspend-process.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#command KibanaSecurityDetectionRule#command}
  */
  readonly command?: string;
  /**
  * Comment describing the action (endpoint only).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#comment KibanaSecurityDetectionRule#comment}
  */
  readonly comment?: string;
  /**
  * Configuration for process commands (endpoint only).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#config KibanaSecurityDetectionRule#config}
  */
  readonly config?: KibanaSecurityDetectionRuleResponseActionsParamsConfig;
  /**
  * Map Osquery results columns to ECS fields (osquery only).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#ecs_mapping KibanaSecurityDetectionRule#ecs_mapping}
  */
  readonly ecsMapping?: { [key: string]: string };
  /**
  * Query pack identifier (osquery only).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#pack_id KibanaSecurityDetectionRule#pack_id}
  */
  readonly packId?: string;
  /**
  * Array of queries to run (osquery only).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#queries KibanaSecurityDetectionRule#queries}
  */
  readonly queries?: KibanaSecurityDetectionRuleResponseActionsParamsQueries[] | cdktf.IResolvable;
  /**
  * SQL query to run (osquery only). Example: 'SELECT * FROM processes;'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#query KibanaSecurityDetectionRule#query}
  */
  readonly query?: string;
  /**
  * Saved query identifier (osquery only).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#saved_query_id KibanaSecurityDetectionRule#saved_query_id}
  */
  readonly savedQueryId?: string;
  /**
  * Timeout period in seconds (osquery only). Min: 60, Max: 900.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#timeout KibanaSecurityDetectionRule#timeout}
  */
  readonly timeout?: number;
}

export function kibanaSecurityDetectionRuleResponseActionsParamsToTerraform(struct?: KibanaSecurityDetectionRuleResponseActionsParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: cdktf.stringToTerraform(struct!.command),
    comment: cdktf.stringToTerraform(struct!.comment),
    config: kibanaSecurityDetectionRuleResponseActionsParamsConfigToTerraform(struct!.config),
    ecs_mapping: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.ecsMapping),
    pack_id: cdktf.stringToTerraform(struct!.packId),
    queries: cdktf.listMapper(kibanaSecurityDetectionRuleResponseActionsParamsQueriesToTerraform, false)(struct!.queries),
    query: cdktf.stringToTerraform(struct!.query),
    saved_query_id: cdktf.stringToTerraform(struct!.savedQueryId),
    timeout: cdktf.numberToTerraform(struct!.timeout),
  }
}


export function kibanaSecurityDetectionRuleResponseActionsParamsToHclTerraform(struct?: KibanaSecurityDetectionRuleResponseActionsParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    comment: {
      value: cdktf.stringToHclTerraform(struct!.comment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    config: {
      value: kibanaSecurityDetectionRuleResponseActionsParamsConfigToHclTerraform(struct!.config),
      isBlock: true,
      type: "struct",
      storageClassType: "KibanaSecurityDetectionRuleResponseActionsParamsConfig",
    },
    ecs_mapping: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.ecsMapping),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    pack_id: {
      value: cdktf.stringToHclTerraform(struct!.packId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queries: {
      value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleResponseActionsParamsQueriesToHclTerraform, false)(struct!.queries),
      isBlock: true,
      type: "list",
      storageClassType: "KibanaSecurityDetectionRuleResponseActionsParamsQueriesList",
    },
    query: {
      value: cdktf.stringToHclTerraform(struct!.query),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saved_query_id: {
      value: cdktf.stringToHclTerraform(struct!.savedQueryId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.numberToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleResponseActionsParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): KibanaSecurityDetectionRuleResponseActionsParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._comment !== undefined) {
      hasAnyValues = true;
      internalValueResult.comment = this._comment;
    }
    if (this._config?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config?.internalValue;
    }
    if (this._ecsMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.ecsMapping = this._ecsMapping;
    }
    if (this._packId !== undefined) {
      hasAnyValues = true;
      internalValueResult.packId = this._packId;
    }
    if (this._queries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queries = this._queries?.internalValue;
    }
    if (this._query !== undefined) {
      hasAnyValues = true;
      internalValueResult.query = this._query;
    }
    if (this._savedQueryId !== undefined) {
      hasAnyValues = true;
      internalValueResult.savedQueryId = this._savedQueryId;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleResponseActionsParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._command = undefined;
      this._comment = undefined;
      this._config.internalValue = undefined;
      this._ecsMapping = undefined;
      this._packId = undefined;
      this._queries.internalValue = undefined;
      this._query = undefined;
      this._savedQueryId = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._command = value.command;
      this._comment = value.comment;
      this._config.internalValue = value.config;
      this._ecsMapping = value.ecsMapping;
      this._packId = value.packId;
      this._queries.internalValue = value.queries;
      this._query = value.query;
      this._savedQueryId = value.savedQueryId;
      this._timeout = value.timeout;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // comment - computed: false, optional: true, required: false
  private _comment?: string; 
  public get comment() {
    return this.getStringAttribute('comment');
  }
  public set comment(value: string) {
    this._comment = value;
  }
  public resetComment() {
    this._comment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commentInput() {
    return this._comment;
  }

  // config - computed: false, optional: true, required: false
  private _config = new KibanaSecurityDetectionRuleResponseActionsParamsConfigOutputReference(this, "config");
  public get config() {
    return this._config;
  }
  public putConfig(value: KibanaSecurityDetectionRuleResponseActionsParamsConfig) {
    this._config.internalValue = value;
  }
  public resetConfig() {
    this._config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config.internalValue;
  }

  // ecs_mapping - computed: false, optional: true, required: false
  private _ecsMapping?: { [key: string]: string }; 
  public get ecsMapping() {
    return this.getStringMapAttribute('ecs_mapping');
  }
  public set ecsMapping(value: { [key: string]: string }) {
    this._ecsMapping = value;
  }
  public resetEcsMapping() {
    this._ecsMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ecsMappingInput() {
    return this._ecsMapping;
  }

  // pack_id - computed: false, optional: true, required: false
  private _packId?: string; 
  public get packId() {
    return this.getStringAttribute('pack_id');
  }
  public set packId(value: string) {
    this._packId = value;
  }
  public resetPackId() {
    this._packId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get packIdInput() {
    return this._packId;
  }

  // queries - computed: false, optional: true, required: false
  private _queries = new KibanaSecurityDetectionRuleResponseActionsParamsQueriesList(this, "queries", false);
  public get queries() {
    return this._queries;
  }
  public putQueries(value: KibanaSecurityDetectionRuleResponseActionsParamsQueries[] | cdktf.IResolvable) {
    this._queries.internalValue = value;
  }
  public resetQueries() {
    this._queries.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queriesInput() {
    return this._queries.internalValue;
  }

  // query - computed: false, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // saved_query_id - computed: false, optional: true, required: false
  private _savedQueryId?: string; 
  public get savedQueryId() {
    return this.getStringAttribute('saved_query_id');
  }
  public set savedQueryId(value: string) {
    this._savedQueryId = value;
  }
  public resetSavedQueryId() {
    this._savedQueryId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get savedQueryIdInput() {
    return this._savedQueryId;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: number; 
  public get timeout() {
    return this.getNumberAttribute('timeout');
  }
  public set timeout(value: number) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface KibanaSecurityDetectionRuleResponseActions {
  /**
  * The action type used for response actions (.osquery, .endpoint).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#action_type_id KibanaSecurityDetectionRule#action_type_id}
  */
  readonly actionTypeId: string;
  /**
  * Parameters for the response action. Structure varies based on action_type_id.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#params KibanaSecurityDetectionRule#params}
  */
  readonly params: KibanaSecurityDetectionRuleResponseActionsParams;
}

export function kibanaSecurityDetectionRuleResponseActionsToTerraform(struct?: KibanaSecurityDetectionRuleResponseActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action_type_id: cdktf.stringToTerraform(struct!.actionTypeId),
    params: kibanaSecurityDetectionRuleResponseActionsParamsToTerraform(struct!.params),
  }
}


export function kibanaSecurityDetectionRuleResponseActionsToHclTerraform(struct?: KibanaSecurityDetectionRuleResponseActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action_type_id: {
      value: cdktf.stringToHclTerraform(struct!.actionTypeId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    params: {
      value: kibanaSecurityDetectionRuleResponseActionsParamsToHclTerraform(struct!.params),
      isBlock: true,
      type: "struct",
      storageClassType: "KibanaSecurityDetectionRuleResponseActionsParams",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleResponseActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleResponseActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actionTypeId !== undefined) {
      hasAnyValues = true;
      internalValueResult.actionTypeId = this._actionTypeId;
    }
    if (this._params?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.params = this._params?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleResponseActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actionTypeId = undefined;
      this._params.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actionTypeId = value.actionTypeId;
      this._params.internalValue = value.params;
    }
  }

  // action_type_id - computed: false, optional: false, required: true
  private _actionTypeId?: string; 
  public get actionTypeId() {
    return this.getStringAttribute('action_type_id');
  }
  public set actionTypeId(value: string) {
    this._actionTypeId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get actionTypeIdInput() {
    return this._actionTypeId;
  }

  // params - computed: false, optional: false, required: true
  private _params = new KibanaSecurityDetectionRuleResponseActionsParamsOutputReference(this, "params");
  public get params() {
    return this._params;
  }
  public putParams(value: KibanaSecurityDetectionRuleResponseActionsParams) {
    this._params.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get paramsInput() {
    return this._params.internalValue;
  }
}

export class KibanaSecurityDetectionRuleResponseActionsList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleResponseActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleResponseActionsOutputReference {
    return new KibanaSecurityDetectionRuleResponseActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleRiskScoreMapping {
  /**
  * Source event field used to override the default risk_score.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#field KibanaSecurityDetectionRule#field}
  */
  readonly field: string;
  /**
  * Operator to use for field value matching. Currently only 'equals' is supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#operator KibanaSecurityDetectionRule#operator}
  */
  readonly operator: string;
  /**
  * Risk score to use when the field matches the value (0-100). If omitted, uses the rule's default risk_score.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#risk_score KibanaSecurityDetectionRule#risk_score}
  */
  readonly riskScore?: number;
  /**
  * Value to match against the field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#value KibanaSecurityDetectionRule#value}
  */
  readonly value: string;
}

export function kibanaSecurityDetectionRuleRiskScoreMappingToTerraform(struct?: KibanaSecurityDetectionRuleRiskScoreMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    operator: cdktf.stringToTerraform(struct!.operator),
    risk_score: cdktf.numberToTerraform(struct!.riskScore),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function kibanaSecurityDetectionRuleRiskScoreMappingToHclTerraform(struct?: KibanaSecurityDetectionRuleRiskScoreMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    risk_score: {
      value: cdktf.numberToHclTerraform(struct!.riskScore),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleRiskScoreMappingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleRiskScoreMapping | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._riskScore !== undefined) {
      hasAnyValues = true;
      internalValueResult.riskScore = this._riskScore;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleRiskScoreMapping | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._operator = undefined;
      this._riskScore = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._operator = value.operator;
      this._riskScore = value.riskScore;
      this._value = value.value;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // risk_score - computed: false, optional: true, required: false
  private _riskScore?: number; 
  public get riskScore() {
    return this.getNumberAttribute('risk_score');
  }
  public set riskScore(value: number) {
    this._riskScore = value;
  }
  public resetRiskScore() {
    this._riskScore = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get riskScoreInput() {
    return this._riskScore;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class KibanaSecurityDetectionRuleRiskScoreMappingList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleRiskScoreMapping[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleRiskScoreMappingOutputReference {
    return new KibanaSecurityDetectionRuleRiskScoreMappingOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleSeverityMapping {
  /**
  * Source event field used to override the default severity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#field KibanaSecurityDetectionRule#field}
  */
  readonly field: string;
  /**
  * Operator to use for field value matching. Currently only 'equals' is supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#operator KibanaSecurityDetectionRule#operator}
  */
  readonly operator: string;
  /**
  * Severity level to use when the field matches the value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#severity KibanaSecurityDetectionRule#severity}
  */
  readonly severity: string;
  /**
  * Value to match against the field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#value KibanaSecurityDetectionRule#value}
  */
  readonly value: string;
}

export function kibanaSecurityDetectionRuleSeverityMappingToTerraform(struct?: KibanaSecurityDetectionRuleSeverityMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    operator: cdktf.stringToTerraform(struct!.operator),
    severity: cdktf.stringToTerraform(struct!.severity),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function kibanaSecurityDetectionRuleSeverityMappingToHclTerraform(struct?: KibanaSecurityDetectionRuleSeverityMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity: {
      value: cdktf.stringToHclTerraform(struct!.severity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleSeverityMappingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleSeverityMapping | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._severity !== undefined) {
      hasAnyValues = true;
      internalValueResult.severity = this._severity;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleSeverityMapping | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._operator = undefined;
      this._severity = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._operator = value.operator;
      this._severity = value.severity;
      this._value = value.value;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // severity - computed: false, optional: false, required: true
  private _severity?: string; 
  public get severity() {
    return this.getStringAttribute('severity');
  }
  public set severity(value: string) {
    this._severity = value;
  }
  // Temporarily expose input value. Use with caution.
  public get severityInput() {
    return this._severity;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class KibanaSecurityDetectionRuleSeverityMappingList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleSeverityMapping[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleSeverityMappingOutputReference {
    return new KibanaSecurityDetectionRuleSeverityMappingOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleThreatTactic {
  /**
  * MITRE ATT&CK tactic ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#id KibanaSecurityDetectionRule#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * MITRE ATT&CK tactic name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#name KibanaSecurityDetectionRule#name}
  */
  readonly name: string;
  /**
  * MITRE ATT&CK tactic reference URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#reference KibanaSecurityDetectionRule#reference}
  */
  readonly reference: string;
}

export function kibanaSecurityDetectionRuleThreatTacticToTerraform(struct?: KibanaSecurityDetectionRuleThreatTactic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    name: cdktf.stringToTerraform(struct!.name),
    reference: cdktf.stringToTerraform(struct!.reference),
  }
}


export function kibanaSecurityDetectionRuleThreatTacticToHclTerraform(struct?: KibanaSecurityDetectionRuleThreatTactic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reference: {
      value: cdktf.stringToHclTerraform(struct!.reference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleThreatTacticOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): KibanaSecurityDetectionRuleThreatTactic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._reference !== undefined) {
      hasAnyValues = true;
      internalValueResult.reference = this._reference;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleThreatTactic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._name = undefined;
      this._reference = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._name = value.name;
      this._reference = value.reference;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // reference - computed: false, optional: false, required: true
  private _reference?: string; 
  public get reference() {
    return this.getStringAttribute('reference');
  }
  public set reference(value: string) {
    this._reference = value;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }
}
export interface KibanaSecurityDetectionRuleThreatTechniqueSubtechnique {
  /**
  * MITRE ATT&CK sub-technique ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#id KibanaSecurityDetectionRule#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * MITRE ATT&CK sub-technique name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#name KibanaSecurityDetectionRule#name}
  */
  readonly name: string;
  /**
  * MITRE ATT&CK sub-technique reference URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#reference KibanaSecurityDetectionRule#reference}
  */
  readonly reference: string;
}

export function kibanaSecurityDetectionRuleThreatTechniqueSubtechniqueToTerraform(struct?: KibanaSecurityDetectionRuleThreatTechniqueSubtechnique | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    name: cdktf.stringToTerraform(struct!.name),
    reference: cdktf.stringToTerraform(struct!.reference),
  }
}


export function kibanaSecurityDetectionRuleThreatTechniqueSubtechniqueToHclTerraform(struct?: KibanaSecurityDetectionRuleThreatTechniqueSubtechnique | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reference: {
      value: cdktf.stringToHclTerraform(struct!.reference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleThreatTechniqueSubtechniqueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleThreatTechniqueSubtechnique | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._reference !== undefined) {
      hasAnyValues = true;
      internalValueResult.reference = this._reference;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleThreatTechniqueSubtechnique | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._name = undefined;
      this._reference = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._name = value.name;
      this._reference = value.reference;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // reference - computed: false, optional: false, required: true
  private _reference?: string; 
  public get reference() {
    return this.getStringAttribute('reference');
  }
  public set reference(value: string) {
    this._reference = value;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }
}

export class KibanaSecurityDetectionRuleThreatTechniqueSubtechniqueList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleThreatTechniqueSubtechnique[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleThreatTechniqueSubtechniqueOutputReference {
    return new KibanaSecurityDetectionRuleThreatTechniqueSubtechniqueOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleThreatTechnique {
  /**
  * MITRE ATT&CK technique ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#id KibanaSecurityDetectionRule#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * MITRE ATT&CK technique name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#name KibanaSecurityDetectionRule#name}
  */
  readonly name: string;
  /**
  * MITRE ATT&CK technique reference URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#reference KibanaSecurityDetectionRule#reference}
  */
  readonly reference: string;
  /**
  * MITRE ATT&CK sub-technique information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#subtechnique KibanaSecurityDetectionRule#subtechnique}
  */
  readonly subtechnique?: KibanaSecurityDetectionRuleThreatTechniqueSubtechnique[] | cdktf.IResolvable;
}

export function kibanaSecurityDetectionRuleThreatTechniqueToTerraform(struct?: KibanaSecurityDetectionRuleThreatTechnique | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    name: cdktf.stringToTerraform(struct!.name),
    reference: cdktf.stringToTerraform(struct!.reference),
    subtechnique: cdktf.listMapper(kibanaSecurityDetectionRuleThreatTechniqueSubtechniqueToTerraform, false)(struct!.subtechnique),
  }
}


export function kibanaSecurityDetectionRuleThreatTechniqueToHclTerraform(struct?: KibanaSecurityDetectionRuleThreatTechnique | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reference: {
      value: cdktf.stringToHclTerraform(struct!.reference),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subtechnique: {
      value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleThreatTechniqueSubtechniqueToHclTerraform, false)(struct!.subtechnique),
      isBlock: true,
      type: "list",
      storageClassType: "KibanaSecurityDetectionRuleThreatTechniqueSubtechniqueList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleThreatTechniqueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleThreatTechnique | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._reference !== undefined) {
      hasAnyValues = true;
      internalValueResult.reference = this._reference;
    }
    if (this._subtechnique?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subtechnique = this._subtechnique?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleThreatTechnique | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._name = undefined;
      this._reference = undefined;
      this._subtechnique.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._name = value.name;
      this._reference = value.reference;
      this._subtechnique.internalValue = value.subtechnique;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // reference - computed: false, optional: false, required: true
  private _reference?: string; 
  public get reference() {
    return this.getStringAttribute('reference');
  }
  public set reference(value: string) {
    this._reference = value;
  }
  // Temporarily expose input value. Use with caution.
  public get referenceInput() {
    return this._reference;
  }

  // subtechnique - computed: false, optional: true, required: false
  private _subtechnique = new KibanaSecurityDetectionRuleThreatTechniqueSubtechniqueList(this, "subtechnique", false);
  public get subtechnique() {
    return this._subtechnique;
  }
  public putSubtechnique(value: KibanaSecurityDetectionRuleThreatTechniqueSubtechnique[] | cdktf.IResolvable) {
    this._subtechnique.internalValue = value;
  }
  public resetSubtechnique() {
    this._subtechnique.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subtechniqueInput() {
    return this._subtechnique.internalValue;
  }
}

export class KibanaSecurityDetectionRuleThreatTechniqueList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleThreatTechnique[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleThreatTechniqueOutputReference {
    return new KibanaSecurityDetectionRuleThreatTechniqueOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleThreat {
  /**
  * Threat framework (typically 'MITRE ATT&CK').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#framework KibanaSecurityDetectionRule#framework}
  */
  readonly framework: string;
  /**
  * MITRE ATT&CK tactic information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#tactic KibanaSecurityDetectionRule#tactic}
  */
  readonly tactic: KibanaSecurityDetectionRuleThreatTactic;
  /**
  * MITRE ATT&CK technique information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#technique KibanaSecurityDetectionRule#technique}
  */
  readonly technique?: KibanaSecurityDetectionRuleThreatTechnique[] | cdktf.IResolvable;
}

export function kibanaSecurityDetectionRuleThreatToTerraform(struct?: KibanaSecurityDetectionRuleThreat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    framework: cdktf.stringToTerraform(struct!.framework),
    tactic: kibanaSecurityDetectionRuleThreatTacticToTerraform(struct!.tactic),
    technique: cdktf.listMapper(kibanaSecurityDetectionRuleThreatTechniqueToTerraform, false)(struct!.technique),
  }
}


export function kibanaSecurityDetectionRuleThreatToHclTerraform(struct?: KibanaSecurityDetectionRuleThreat | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    framework: {
      value: cdktf.stringToHclTerraform(struct!.framework),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tactic: {
      value: kibanaSecurityDetectionRuleThreatTacticToHclTerraform(struct!.tactic),
      isBlock: true,
      type: "struct",
      storageClassType: "KibanaSecurityDetectionRuleThreatTactic",
    },
    technique: {
      value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleThreatTechniqueToHclTerraform, false)(struct!.technique),
      isBlock: true,
      type: "list",
      storageClassType: "KibanaSecurityDetectionRuleThreatTechniqueList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleThreatOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleThreat | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._framework !== undefined) {
      hasAnyValues = true;
      internalValueResult.framework = this._framework;
    }
    if (this._tactic?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tactic = this._tactic?.internalValue;
    }
    if (this._technique?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.technique = this._technique?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleThreat | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._framework = undefined;
      this._tactic.internalValue = undefined;
      this._technique.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._framework = value.framework;
      this._tactic.internalValue = value.tactic;
      this._technique.internalValue = value.technique;
    }
  }

  // framework - computed: false, optional: false, required: true
  private _framework?: string; 
  public get framework() {
    return this.getStringAttribute('framework');
  }
  public set framework(value: string) {
    this._framework = value;
  }
  // Temporarily expose input value. Use with caution.
  public get frameworkInput() {
    return this._framework;
  }

  // tactic - computed: false, optional: false, required: true
  private _tactic = new KibanaSecurityDetectionRuleThreatTacticOutputReference(this, "tactic");
  public get tactic() {
    return this._tactic;
  }
  public putTactic(value: KibanaSecurityDetectionRuleThreatTactic) {
    this._tactic.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tacticInput() {
    return this._tactic.internalValue;
  }

  // technique - computed: false, optional: true, required: false
  private _technique = new KibanaSecurityDetectionRuleThreatTechniqueList(this, "technique", false);
  public get technique() {
    return this._technique;
  }
  public putTechnique(value: KibanaSecurityDetectionRuleThreatTechnique[] | cdktf.IResolvable) {
    this._technique.internalValue = value;
  }
  public resetTechnique() {
    this._technique.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get techniqueInput() {
    return this._technique.internalValue;
  }
}

export class KibanaSecurityDetectionRuleThreatList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleThreat[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleThreatOutputReference {
    return new KibanaSecurityDetectionRuleThreatOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleThreatMappingEntries {
  /**
  * Event field to match.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#field KibanaSecurityDetectionRule#field}
  */
  readonly field: string;
  /**
  * Type of match (mapping).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#type KibanaSecurityDetectionRule#type}
  */
  readonly type: string;
  /**
  * Threat intelligence field to match against.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#value KibanaSecurityDetectionRule#value}
  */
  readonly value: string;
}

export function kibanaSecurityDetectionRuleThreatMappingEntriesToTerraform(struct?: KibanaSecurityDetectionRuleThreatMappingEntries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function kibanaSecurityDetectionRuleThreatMappingEntriesToHclTerraform(struct?: KibanaSecurityDetectionRuleThreatMappingEntries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleThreatMappingEntriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleThreatMappingEntries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleThreatMappingEntries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class KibanaSecurityDetectionRuleThreatMappingEntriesList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleThreatMappingEntries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleThreatMappingEntriesOutputReference {
    return new KibanaSecurityDetectionRuleThreatMappingEntriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleThreatMapping {
  /**
  * Array of mapping entries.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#entries KibanaSecurityDetectionRule#entries}
  */
  readonly entries: KibanaSecurityDetectionRuleThreatMappingEntries[] | cdktf.IResolvable;
}

export function kibanaSecurityDetectionRuleThreatMappingToTerraform(struct?: KibanaSecurityDetectionRuleThreatMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entries: cdktf.listMapper(kibanaSecurityDetectionRuleThreatMappingEntriesToTerraform, false)(struct!.entries),
  }
}


export function kibanaSecurityDetectionRuleThreatMappingToHclTerraform(struct?: KibanaSecurityDetectionRuleThreatMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entries: {
      value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleThreatMappingEntriesToHclTerraform, false)(struct!.entries),
      isBlock: true,
      type: "list",
      storageClassType: "KibanaSecurityDetectionRuleThreatMappingEntriesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleThreatMappingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleThreatMapping | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.entries = this._entries?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleThreatMapping | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entries.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entries.internalValue = value.entries;
    }
  }

  // entries - computed: false, optional: false, required: true
  private _entries = new KibanaSecurityDetectionRuleThreatMappingEntriesList(this, "entries", false);
  public get entries() {
    return this._entries;
  }
  public putEntries(value: KibanaSecurityDetectionRuleThreatMappingEntries[] | cdktf.IResolvable) {
    this._entries.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get entriesInput() {
    return this._entries.internalValue;
  }
}

export class KibanaSecurityDetectionRuleThreatMappingList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleThreatMapping[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleThreatMappingOutputReference {
    return new KibanaSecurityDetectionRuleThreatMappingOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleThresholdCardinality {
  /**
  * The field on which to calculate and compare the cardinality.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#field KibanaSecurityDetectionRule#field}
  */
  readonly field: string;
  /**
  * The threshold cardinality value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#value KibanaSecurityDetectionRule#value}
  */
  readonly value: number;
}

export function kibanaSecurityDetectionRuleThresholdCardinalityToTerraform(struct?: KibanaSecurityDetectionRuleThresholdCardinality | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function kibanaSecurityDetectionRuleThresholdCardinalityToHclTerraform(struct?: KibanaSecurityDetectionRuleThresholdCardinality | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleThresholdCardinalityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): KibanaSecurityDetectionRuleThresholdCardinality | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleThresholdCardinality | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._value = value.value;
    }
  }

  // field - computed: false, optional: false, required: true
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class KibanaSecurityDetectionRuleThresholdCardinalityList extends cdktf.ComplexList {
  public internalValue? : KibanaSecurityDetectionRuleThresholdCardinality[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): KibanaSecurityDetectionRuleThresholdCardinalityOutputReference {
    return new KibanaSecurityDetectionRuleThresholdCardinalityOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface KibanaSecurityDetectionRuleThreshold {
  /**
  * Cardinality settings for threshold rule.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#cardinality KibanaSecurityDetectionRule#cardinality}
  */
  readonly cardinality?: KibanaSecurityDetectionRuleThresholdCardinality[] | cdktf.IResolvable;
  /**
  * Field(s) to use for threshold aggregation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#field KibanaSecurityDetectionRule#field}
  */
  readonly field?: string[];
  /**
  * The threshold value from which an alert is generated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#value KibanaSecurityDetectionRule#value}
  */
  readonly value: number;
}

export function kibanaSecurityDetectionRuleThresholdToTerraform(struct?: KibanaSecurityDetectionRuleThreshold | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cardinality: cdktf.listMapper(kibanaSecurityDetectionRuleThresholdCardinalityToTerraform, false)(struct!.cardinality),
    field: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.field),
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function kibanaSecurityDetectionRuleThresholdToHclTerraform(struct?: KibanaSecurityDetectionRuleThreshold | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cardinality: {
      value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleThresholdCardinalityToHclTerraform, false)(struct!.cardinality),
      isBlock: true,
      type: "list",
      storageClassType: "KibanaSecurityDetectionRuleThresholdCardinalityList",
    },
    field: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.field),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class KibanaSecurityDetectionRuleThresholdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): KibanaSecurityDetectionRuleThreshold | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cardinality?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cardinality = this._cardinality?.internalValue;
    }
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: KibanaSecurityDetectionRuleThreshold | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cardinality.internalValue = undefined;
      this._field = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cardinality.internalValue = value.cardinality;
      this._field = value.field;
      this._value = value.value;
    }
  }

  // cardinality - computed: false, optional: true, required: false
  private _cardinality = new KibanaSecurityDetectionRuleThresholdCardinalityList(this, "cardinality", false);
  public get cardinality() {
    return this._cardinality;
  }
  public putCardinality(value: KibanaSecurityDetectionRuleThresholdCardinality[] | cdktf.IResolvable) {
    this._cardinality.internalValue = value;
  }
  public resetCardinality() {
    this._cardinality.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cardinalityInput() {
    return this._cardinality.internalValue;
  }

  // field - computed: false, optional: true, required: false
  private _field?: string[]; 
  public get field() {
    return this.getListAttribute('field');
  }
  public set field(value: string[]) {
    this._field = value;
  }
  public resetField() {
    this._field = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // value - computed: false, optional: false, required: true
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule elasticstack_kibana_security_detection_rule}
*/
export class KibanaSecurityDetectionRule extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "elasticstack_kibana_security_detection_rule";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a KibanaSecurityDetectionRule resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the KibanaSecurityDetectionRule to import
  * @param importFromId The id of the existing KibanaSecurityDetectionRule that should be imported. Refer to the {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the KibanaSecurityDetectionRule to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "elasticstack_kibana_security_detection_rule", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/elastic/elasticstack/0.12.1/docs/resources/kibana_security_detection_rule elasticstack_kibana_security_detection_rule} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options KibanaSecurityDetectionRuleConfig
  */
  public constructor(scope: Construct, id: string, config: KibanaSecurityDetectionRuleConfig) {
    super(scope, id, {
      terraformResourceType: 'elasticstack_kibana_security_detection_rule',
      terraformGeneratorMetadata: {
        providerName: 'elasticstack',
        providerVersion: '0.12.1'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._actions.internalValue = config.actions;
    this._alertSuppression.internalValue = config.alertSuppression;
    this._anomalyThreshold = config.anomalyThreshold;
    this._author = config.author;
    this._buildingBlockType = config.buildingBlockType;
    this._concurrentSearches = config.concurrentSearches;
    this._dataViewId = config.dataViewId;
    this._description = config.description;
    this._enabled = config.enabled;
    this._exceptionsList.internalValue = config.exceptionsList;
    this._falsePositives = config.falsePositives;
    this._filters = config.filters;
    this._from = config.from;
    this._historyWindowStart = config.historyWindowStart;
    this._index = config.index;
    this._interval = config.interval;
    this._investigationFields = config.investigationFields;
    this._itemsPerSearch = config.itemsPerSearch;
    this._language = config.language;
    this._license = config.license;
    this._machineLearningJobId = config.machineLearningJobId;
    this._maxSignals = config.maxSignals;
    this._name = config.name;
    this._namespace = config.namespace;
    this._newTermsFields = config.newTermsFields;
    this._note = config.note;
    this._query = config.query;
    this._references = config.references;
    this._relatedIntegrations.internalValue = config.relatedIntegrations;
    this._requiredFields.internalValue = config.requiredFields;
    this._responseActions.internalValue = config.responseActions;
    this._riskScore = config.riskScore;
    this._riskScoreMapping.internalValue = config.riskScoreMapping;
    this._ruleId = config.ruleId;
    this._ruleNameOverride = config.ruleNameOverride;
    this._savedId = config.savedId;
    this._setup = config.setup;
    this._severity = config.severity;
    this._severityMapping.internalValue = config.severityMapping;
    this._spaceId = config.spaceId;
    this._tags = config.tags;
    this._threat.internalValue = config.threat;
    this._threatFilters = config.threatFilters;
    this._threatIndex = config.threatIndex;
    this._threatIndicatorPath = config.threatIndicatorPath;
    this._threatMapping.internalValue = config.threatMapping;
    this._threatQuery = config.threatQuery;
    this._threshold.internalValue = config.threshold;
    this._tiebreakerField = config.tiebreakerField;
    this._timelineId = config.timelineId;
    this._timelineTitle = config.timelineTitle;
    this._timestampOverride = config.timestampOverride;
    this._timestampOverrideFallbackDisabled = config.timestampOverrideFallbackDisabled;
    this._to = config.to;
    this._type = config.type;
    this._version = config.version;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // actions - computed: false, optional: true, required: false
  private _actions = new KibanaSecurityDetectionRuleActionsList(this, "actions", false);
  public get actions() {
    return this._actions;
  }
  public putActions(value: KibanaSecurityDetectionRuleActions[] | cdktf.IResolvable) {
    this._actions.internalValue = value;
  }
  public resetActions() {
    this._actions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions.internalValue;
  }

  // alert_suppression - computed: false, optional: true, required: false
  private _alertSuppression = new KibanaSecurityDetectionRuleAlertSuppressionOutputReference(this, "alert_suppression");
  public get alertSuppression() {
    return this._alertSuppression;
  }
  public putAlertSuppression(value: KibanaSecurityDetectionRuleAlertSuppression) {
    this._alertSuppression.internalValue = value;
  }
  public resetAlertSuppression() {
    this._alertSuppression.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alertSuppressionInput() {
    return this._alertSuppression.internalValue;
  }

  // anomaly_threshold - computed: false, optional: true, required: false
  private _anomalyThreshold?: number; 
  public get anomalyThreshold() {
    return this.getNumberAttribute('anomaly_threshold');
  }
  public set anomalyThreshold(value: number) {
    this._anomalyThreshold = value;
  }
  public resetAnomalyThreshold() {
    this._anomalyThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anomalyThresholdInput() {
    return this._anomalyThreshold;
  }

  // author - computed: true, optional: true, required: false
  private _author?: string[]; 
  public get author() {
    return this.getListAttribute('author');
  }
  public set author(value: string[]) {
    this._author = value;
  }
  public resetAuthor() {
    this._author = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorInput() {
    return this._author;
  }

  // building_block_type - computed: false, optional: true, required: false
  private _buildingBlockType?: string; 
  public get buildingBlockType() {
    return this.getStringAttribute('building_block_type');
  }
  public set buildingBlockType(value: string) {
    this._buildingBlockType = value;
  }
  public resetBuildingBlockType() {
    this._buildingBlockType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get buildingBlockTypeInput() {
    return this._buildingBlockType;
  }

  // concurrent_searches - computed: false, optional: true, required: false
  private _concurrentSearches?: number; 
  public get concurrentSearches() {
    return this.getNumberAttribute('concurrent_searches');
  }
  public set concurrentSearches(value: number) {
    this._concurrentSearches = value;
  }
  public resetConcurrentSearches() {
    this._concurrentSearches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentSearchesInput() {
    return this._concurrentSearches;
  }

  // created_at - computed: true, optional: false, required: false
  public get createdAt() {
    return this.getStringAttribute('created_at');
  }

  // created_by - computed: true, optional: false, required: false
  public get createdBy() {
    return this.getStringAttribute('created_by');
  }

  // data_view_id - computed: false, optional: true, required: false
  private _dataViewId?: string; 
  public get dataViewId() {
    return this.getStringAttribute('data_view_id');
  }
  public set dataViewId(value: string) {
    this._dataViewId = value;
  }
  public resetDataViewId() {
    this._dataViewId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataViewIdInput() {
    return this._dataViewId;
  }

  // description - computed: false, optional: false, required: true
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // exceptions_list - computed: false, optional: true, required: false
  private _exceptionsList = new KibanaSecurityDetectionRuleExceptionsListStructList(this, "exceptions_list", false);
  public get exceptionsList() {
    return this._exceptionsList;
  }
  public putExceptionsList(value: KibanaSecurityDetectionRuleExceptionsListStruct[] | cdktf.IResolvable) {
    this._exceptionsList.internalValue = value;
  }
  public resetExceptionsList() {
    this._exceptionsList.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptionsListInput() {
    return this._exceptionsList.internalValue;
  }

  // false_positives - computed: true, optional: true, required: false
  private _falsePositives?: string[]; 
  public get falsePositives() {
    return this.getListAttribute('false_positives');
  }
  public set falsePositives(value: string[]) {
    this._falsePositives = value;
  }
  public resetFalsePositives() {
    this._falsePositives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get falsePositivesInput() {
    return this._falsePositives;
  }

  // filters - computed: false, optional: true, required: false
  private _filters?: string; 
  public get filters() {
    return this.getStringAttribute('filters');
  }
  public set filters(value: string) {
    this._filters = value;
  }
  public resetFilters() {
    this._filters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters;
  }

  // from - computed: true, optional: true, required: false
  private _from?: string; 
  public get from() {
    return this.getStringAttribute('from');
  }
  public set from(value: string) {
    this._from = value;
  }
  public resetFrom() {
    this._from = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fromInput() {
    return this._from;
  }

  // history_window_start - computed: false, optional: true, required: false
  private _historyWindowStart?: string; 
  public get historyWindowStart() {
    return this.getStringAttribute('history_window_start');
  }
  public set historyWindowStart(value: string) {
    this._historyWindowStart = value;
  }
  public resetHistoryWindowStart() {
    this._historyWindowStart = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get historyWindowStartInput() {
    return this._historyWindowStart;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // index - computed: true, optional: true, required: false
  private _index?: string[]; 
  public get index() {
    return this.getListAttribute('index');
  }
  public set index(value: string[]) {
    this._index = value;
  }
  public resetIndex() {
    this._index = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: string; 
  public get interval() {
    return this.getStringAttribute('interval');
  }
  public set interval(value: string) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // investigation_fields - computed: false, optional: true, required: false
  private _investigationFields?: string[]; 
  public get investigationFields() {
    return this.getListAttribute('investigation_fields');
  }
  public set investigationFields(value: string[]) {
    this._investigationFields = value;
  }
  public resetInvestigationFields() {
    this._investigationFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get investigationFieldsInput() {
    return this._investigationFields;
  }

  // items_per_search - computed: false, optional: true, required: false
  private _itemsPerSearch?: number; 
  public get itemsPerSearch() {
    return this.getNumberAttribute('items_per_search');
  }
  public set itemsPerSearch(value: number) {
    this._itemsPerSearch = value;
  }
  public resetItemsPerSearch() {
    this._itemsPerSearch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get itemsPerSearchInput() {
    return this._itemsPerSearch;
  }

  // language - computed: true, optional: true, required: false
  private _language?: string; 
  public get language() {
    return this.getStringAttribute('language');
  }
  public set language(value: string) {
    this._language = value;
  }
  public resetLanguage() {
    this._language = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get languageInput() {
    return this._language;
  }

  // license - computed: false, optional: true, required: false
  private _license?: string; 
  public get license() {
    return this.getStringAttribute('license');
  }
  public set license(value: string) {
    this._license = value;
  }
  public resetLicense() {
    this._license = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get licenseInput() {
    return this._license;
  }

  // machine_learning_job_id - computed: false, optional: true, required: false
  private _machineLearningJobId?: string[]; 
  public get machineLearningJobId() {
    return this.getListAttribute('machine_learning_job_id');
  }
  public set machineLearningJobId(value: string[]) {
    this._machineLearningJobId = value;
  }
  public resetMachineLearningJobId() {
    this._machineLearningJobId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get machineLearningJobIdInput() {
    return this._machineLearningJobId;
  }

  // max_signals - computed: true, optional: true, required: false
  private _maxSignals?: number; 
  public get maxSignals() {
    return this.getNumberAttribute('max_signals');
  }
  public set maxSignals(value: number) {
    this._maxSignals = value;
  }
  public resetMaxSignals() {
    this._maxSignals = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSignalsInput() {
    return this._maxSignals;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // new_terms_fields - computed: false, optional: true, required: false
  private _newTermsFields?: string[]; 
  public get newTermsFields() {
    return this.getListAttribute('new_terms_fields');
  }
  public set newTermsFields(value: string[]) {
    this._newTermsFields = value;
  }
  public resetNewTermsFields() {
    this._newTermsFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get newTermsFieldsInput() {
    return this._newTermsFields;
  }

  // note - computed: false, optional: true, required: false
  private _note?: string; 
  public get note() {
    return this.getStringAttribute('note');
  }
  public set note(value: string) {
    this._note = value;
  }
  public resetNote() {
    this._note = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noteInput() {
    return this._note;
  }

  // query - computed: true, optional: true, required: false
  private _query?: string; 
  public get query() {
    return this.getStringAttribute('query');
  }
  public set query(value: string) {
    this._query = value;
  }
  public resetQuery() {
    this._query = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryInput() {
    return this._query;
  }

  // references - computed: true, optional: true, required: false
  private _references?: string[]; 
  public get references() {
    return this.getListAttribute('references');
  }
  public set references(value: string[]) {
    this._references = value;
  }
  public resetReferences() {
    this._references = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get referencesInput() {
    return this._references;
  }

  // related_integrations - computed: false, optional: true, required: false
  private _relatedIntegrations = new KibanaSecurityDetectionRuleRelatedIntegrationsList(this, "related_integrations", false);
  public get relatedIntegrations() {
    return this._relatedIntegrations;
  }
  public putRelatedIntegrations(value: KibanaSecurityDetectionRuleRelatedIntegrations[] | cdktf.IResolvable) {
    this._relatedIntegrations.internalValue = value;
  }
  public resetRelatedIntegrations() {
    this._relatedIntegrations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get relatedIntegrationsInput() {
    return this._relatedIntegrations.internalValue;
  }

  // required_fields - computed: false, optional: true, required: false
  private _requiredFields = new KibanaSecurityDetectionRuleRequiredFieldsList(this, "required_fields", false);
  public get requiredFields() {
    return this._requiredFields;
  }
  public putRequiredFields(value: KibanaSecurityDetectionRuleRequiredFields[] | cdktf.IResolvable) {
    this._requiredFields.internalValue = value;
  }
  public resetRequiredFields() {
    this._requiredFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredFieldsInput() {
    return this._requiredFields.internalValue;
  }

  // response_actions - computed: false, optional: true, required: false
  private _responseActions = new KibanaSecurityDetectionRuleResponseActionsList(this, "response_actions", false);
  public get responseActions() {
    return this._responseActions;
  }
  public putResponseActions(value: KibanaSecurityDetectionRuleResponseActions[] | cdktf.IResolvable) {
    this._responseActions.internalValue = value;
  }
  public resetResponseActions() {
    this._responseActions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseActionsInput() {
    return this._responseActions.internalValue;
  }

  // revision - computed: true, optional: false, required: false
  public get revision() {
    return this.getNumberAttribute('revision');
  }

  // risk_score - computed: true, optional: true, required: false
  private _riskScore?: number; 
  public get riskScore() {
    return this.getNumberAttribute('risk_score');
  }
  public set riskScore(value: number) {
    this._riskScore = value;
  }
  public resetRiskScore() {
    this._riskScore = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get riskScoreInput() {
    return this._riskScore;
  }

  // risk_score_mapping - computed: false, optional: true, required: false
  private _riskScoreMapping = new KibanaSecurityDetectionRuleRiskScoreMappingList(this, "risk_score_mapping", false);
  public get riskScoreMapping() {
    return this._riskScoreMapping;
  }
  public putRiskScoreMapping(value: KibanaSecurityDetectionRuleRiskScoreMapping[] | cdktf.IResolvable) {
    this._riskScoreMapping.internalValue = value;
  }
  public resetRiskScoreMapping() {
    this._riskScoreMapping.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get riskScoreMappingInput() {
    return this._riskScoreMapping.internalValue;
  }

  // rule_id - computed: true, optional: true, required: false
  private _ruleId?: string; 
  public get ruleId() {
    return this.getStringAttribute('rule_id');
  }
  public set ruleId(value: string) {
    this._ruleId = value;
  }
  public resetRuleId() {
    this._ruleId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ruleIdInput() {
    return this._ruleId;
  }

  // rule_name_override - computed: false, optional: true, required: false
  private _ruleNameOverride?: string; 
  public get ruleNameOverride() {
    return this.getStringAttribute('rule_name_override');
  }
  public set ruleNameOverride(value: string) {
    this._ruleNameOverride = value;
  }
  public resetRuleNameOverride() {
    this._ruleNameOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ruleNameOverrideInput() {
    return this._ruleNameOverride;
  }

  // saved_id - computed: false, optional: true, required: false
  private _savedId?: string; 
  public get savedId() {
    return this.getStringAttribute('saved_id');
  }
  public set savedId(value: string) {
    this._savedId = value;
  }
  public resetSavedId() {
    this._savedId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get savedIdInput() {
    return this._savedId;
  }

  // setup - computed: false, optional: true, required: false
  private _setup?: string; 
  public get setup() {
    return this.getStringAttribute('setup');
  }
  public set setup(value: string) {
    this._setup = value;
  }
  public resetSetup() {
    this._setup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setupInput() {
    return this._setup;
  }

  // severity - computed: true, optional: true, required: false
  private _severity?: string; 
  public get severity() {
    return this.getStringAttribute('severity');
  }
  public set severity(value: string) {
    this._severity = value;
  }
  public resetSeverity() {
    this._severity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityInput() {
    return this._severity;
  }

  // severity_mapping - computed: false, optional: true, required: false
  private _severityMapping = new KibanaSecurityDetectionRuleSeverityMappingList(this, "severity_mapping", false);
  public get severityMapping() {
    return this._severityMapping;
  }
  public putSeverityMapping(value: KibanaSecurityDetectionRuleSeverityMapping[] | cdktf.IResolvable) {
    this._severityMapping.internalValue = value;
  }
  public resetSeverityMapping() {
    this._severityMapping.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityMappingInput() {
    return this._severityMapping.internalValue;
  }

  // space_id - computed: true, optional: true, required: false
  private _spaceId?: string; 
  public get spaceId() {
    return this.getStringAttribute('space_id');
  }
  public set spaceId(value: string) {
    this._spaceId = value;
  }
  public resetSpaceId() {
    this._spaceId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spaceIdInput() {
    return this._spaceId;
  }

  // tags - computed: true, optional: true, required: false
  private _tags?: string[]; 
  public get tags() {
    return this.getListAttribute('tags');
  }
  public set tags(value: string[]) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // threat - computed: false, optional: true, required: false
  private _threat = new KibanaSecurityDetectionRuleThreatList(this, "threat", false);
  public get threat() {
    return this._threat;
  }
  public putThreat(value: KibanaSecurityDetectionRuleThreat[] | cdktf.IResolvable) {
    this._threat.internalValue = value;
  }
  public resetThreat() {
    this._threat.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threatInput() {
    return this._threat.internalValue;
  }

  // threat_filters - computed: false, optional: true, required: false
  private _threatFilters?: string[]; 
  public get threatFilters() {
    return this.getListAttribute('threat_filters');
  }
  public set threatFilters(value: string[]) {
    this._threatFilters = value;
  }
  public resetThreatFilters() {
    this._threatFilters = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threatFiltersInput() {
    return this._threatFilters;
  }

  // threat_index - computed: false, optional: true, required: false
  private _threatIndex?: string[]; 
  public get threatIndex() {
    return this.getListAttribute('threat_index');
  }
  public set threatIndex(value: string[]) {
    this._threatIndex = value;
  }
  public resetThreatIndex() {
    this._threatIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threatIndexInput() {
    return this._threatIndex;
  }

  // threat_indicator_path - computed: true, optional: true, required: false
  private _threatIndicatorPath?: string; 
  public get threatIndicatorPath() {
    return this.getStringAttribute('threat_indicator_path');
  }
  public set threatIndicatorPath(value: string) {
    this._threatIndicatorPath = value;
  }
  public resetThreatIndicatorPath() {
    this._threatIndicatorPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threatIndicatorPathInput() {
    return this._threatIndicatorPath;
  }

  // threat_mapping - computed: false, optional: true, required: false
  private _threatMapping = new KibanaSecurityDetectionRuleThreatMappingList(this, "threat_mapping", false);
  public get threatMapping() {
    return this._threatMapping;
  }
  public putThreatMapping(value: KibanaSecurityDetectionRuleThreatMapping[] | cdktf.IResolvable) {
    this._threatMapping.internalValue = value;
  }
  public resetThreatMapping() {
    this._threatMapping.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threatMappingInput() {
    return this._threatMapping.internalValue;
  }

  // threat_query - computed: true, optional: true, required: false
  private _threatQuery?: string; 
  public get threatQuery() {
    return this.getStringAttribute('threat_query');
  }
  public set threatQuery(value: string) {
    this._threatQuery = value;
  }
  public resetThreatQuery() {
    this._threatQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get threatQueryInput() {
    return this._threatQuery;
  }

  // threshold - computed: false, optional: true, required: false
  private _threshold = new KibanaSecurityDetectionRuleThresholdOutputReference(this, "threshold");
  public get threshold() {
    return this._threshold;
  }
  public putThreshold(value: KibanaSecurityDetectionRuleThreshold) {
    this._threshold.internalValue = value;
  }
  public resetThreshold() {
    this._threshold.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get thresholdInput() {
    return this._threshold.internalValue;
  }

  // tiebreaker_field - computed: false, optional: true, required: false
  private _tiebreakerField?: string; 
  public get tiebreakerField() {
    return this.getStringAttribute('tiebreaker_field');
  }
  public set tiebreakerField(value: string) {
    this._tiebreakerField = value;
  }
  public resetTiebreakerField() {
    this._tiebreakerField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tiebreakerFieldInput() {
    return this._tiebreakerField;
  }

  // timeline_id - computed: false, optional: true, required: false
  private _timelineId?: string; 
  public get timelineId() {
    return this.getStringAttribute('timeline_id');
  }
  public set timelineId(value: string) {
    this._timelineId = value;
  }
  public resetTimelineId() {
    this._timelineId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timelineIdInput() {
    return this._timelineId;
  }

  // timeline_title - computed: false, optional: true, required: false
  private _timelineTitle?: string; 
  public get timelineTitle() {
    return this.getStringAttribute('timeline_title');
  }
  public set timelineTitle(value: string) {
    this._timelineTitle = value;
  }
  public resetTimelineTitle() {
    this._timelineTitle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timelineTitleInput() {
    return this._timelineTitle;
  }

  // timestamp_override - computed: false, optional: true, required: false
  private _timestampOverride?: string; 
  public get timestampOverride() {
    return this.getStringAttribute('timestamp_override');
  }
  public set timestampOverride(value: string) {
    this._timestampOverride = value;
  }
  public resetTimestampOverride() {
    this._timestampOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampOverrideInput() {
    return this._timestampOverride;
  }

  // timestamp_override_fallback_disabled - computed: false, optional: true, required: false
  private _timestampOverrideFallbackDisabled?: boolean | cdktf.IResolvable; 
  public get timestampOverrideFallbackDisabled() {
    return this.getBooleanAttribute('timestamp_override_fallback_disabled');
  }
  public set timestampOverrideFallbackDisabled(value: boolean | cdktf.IResolvable) {
    this._timestampOverrideFallbackDisabled = value;
  }
  public resetTimestampOverrideFallbackDisabled() {
    this._timestampOverrideFallbackDisabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampOverrideFallbackDisabledInput() {
    return this._timestampOverrideFallbackDisabled;
  }

  // to - computed: true, optional: true, required: false
  private _to?: string; 
  public get to() {
    return this.getStringAttribute('to');
  }
  public set to(value: string) {
    this._to = value;
  }
  public resetTo() {
    this._to = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get toInput() {
    return this._to;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // updated_at - computed: true, optional: false, required: false
  public get updatedAt() {
    return this.getStringAttribute('updated_at');
  }

  // updated_by - computed: true, optional: false, required: false
  public get updatedBy() {
    return this.getStringAttribute('updated_by');
  }

  // version - computed: true, optional: true, required: false
  private _version?: number; 
  public get version() {
    return this.getNumberAttribute('version');
  }
  public set version(value: number) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      actions: cdktf.listMapper(kibanaSecurityDetectionRuleActionsToTerraform, false)(this._actions.internalValue),
      alert_suppression: kibanaSecurityDetectionRuleAlertSuppressionToTerraform(this._alertSuppression.internalValue),
      anomaly_threshold: cdktf.numberToTerraform(this._anomalyThreshold),
      author: cdktf.listMapper(cdktf.stringToTerraform, false)(this._author),
      building_block_type: cdktf.stringToTerraform(this._buildingBlockType),
      concurrent_searches: cdktf.numberToTerraform(this._concurrentSearches),
      data_view_id: cdktf.stringToTerraform(this._dataViewId),
      description: cdktf.stringToTerraform(this._description),
      enabled: cdktf.booleanToTerraform(this._enabled),
      exceptions_list: cdktf.listMapper(kibanaSecurityDetectionRuleExceptionsListStructToTerraform, false)(this._exceptionsList.internalValue),
      false_positives: cdktf.listMapper(cdktf.stringToTerraform, false)(this._falsePositives),
      filters: cdktf.stringToTerraform(this._filters),
      from: cdktf.stringToTerraform(this._from),
      history_window_start: cdktf.stringToTerraform(this._historyWindowStart),
      index: cdktf.listMapper(cdktf.stringToTerraform, false)(this._index),
      interval: cdktf.stringToTerraform(this._interval),
      investigation_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(this._investigationFields),
      items_per_search: cdktf.numberToTerraform(this._itemsPerSearch),
      language: cdktf.stringToTerraform(this._language),
      license: cdktf.stringToTerraform(this._license),
      machine_learning_job_id: cdktf.listMapper(cdktf.stringToTerraform, false)(this._machineLearningJobId),
      max_signals: cdktf.numberToTerraform(this._maxSignals),
      name: cdktf.stringToTerraform(this._name),
      namespace: cdktf.stringToTerraform(this._namespace),
      new_terms_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(this._newTermsFields),
      note: cdktf.stringToTerraform(this._note),
      query: cdktf.stringToTerraform(this._query),
      references: cdktf.listMapper(cdktf.stringToTerraform, false)(this._references),
      related_integrations: cdktf.listMapper(kibanaSecurityDetectionRuleRelatedIntegrationsToTerraform, false)(this._relatedIntegrations.internalValue),
      required_fields: cdktf.listMapper(kibanaSecurityDetectionRuleRequiredFieldsToTerraform, false)(this._requiredFields.internalValue),
      response_actions: cdktf.listMapper(kibanaSecurityDetectionRuleResponseActionsToTerraform, false)(this._responseActions.internalValue),
      risk_score: cdktf.numberToTerraform(this._riskScore),
      risk_score_mapping: cdktf.listMapper(kibanaSecurityDetectionRuleRiskScoreMappingToTerraform, false)(this._riskScoreMapping.internalValue),
      rule_id: cdktf.stringToTerraform(this._ruleId),
      rule_name_override: cdktf.stringToTerraform(this._ruleNameOverride),
      saved_id: cdktf.stringToTerraform(this._savedId),
      setup: cdktf.stringToTerraform(this._setup),
      severity: cdktf.stringToTerraform(this._severity),
      severity_mapping: cdktf.listMapper(kibanaSecurityDetectionRuleSeverityMappingToTerraform, false)(this._severityMapping.internalValue),
      space_id: cdktf.stringToTerraform(this._spaceId),
      tags: cdktf.listMapper(cdktf.stringToTerraform, false)(this._tags),
      threat: cdktf.listMapper(kibanaSecurityDetectionRuleThreatToTerraform, false)(this._threat.internalValue),
      threat_filters: cdktf.listMapper(cdktf.stringToTerraform, false)(this._threatFilters),
      threat_index: cdktf.listMapper(cdktf.stringToTerraform, false)(this._threatIndex),
      threat_indicator_path: cdktf.stringToTerraform(this._threatIndicatorPath),
      threat_mapping: cdktf.listMapper(kibanaSecurityDetectionRuleThreatMappingToTerraform, false)(this._threatMapping.internalValue),
      threat_query: cdktf.stringToTerraform(this._threatQuery),
      threshold: kibanaSecurityDetectionRuleThresholdToTerraform(this._threshold.internalValue),
      tiebreaker_field: cdktf.stringToTerraform(this._tiebreakerField),
      timeline_id: cdktf.stringToTerraform(this._timelineId),
      timeline_title: cdktf.stringToTerraform(this._timelineTitle),
      timestamp_override: cdktf.stringToTerraform(this._timestampOverride),
      timestamp_override_fallback_disabled: cdktf.booleanToTerraform(this._timestampOverrideFallbackDisabled),
      to: cdktf.stringToTerraform(this._to),
      type: cdktf.stringToTerraform(this._type),
      version: cdktf.numberToTerraform(this._version),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      actions: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleActionsToHclTerraform, false)(this._actions.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleActionsList",
      },
      alert_suppression: {
        value: kibanaSecurityDetectionRuleAlertSuppressionToHclTerraform(this._alertSuppression.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "KibanaSecurityDetectionRuleAlertSuppression",
      },
      anomaly_threshold: {
        value: cdktf.numberToHclTerraform(this._anomalyThreshold),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      author: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._author),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      building_block_type: {
        value: cdktf.stringToHclTerraform(this._buildingBlockType),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      concurrent_searches: {
        value: cdktf.numberToHclTerraform(this._concurrentSearches),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      data_view_id: {
        value: cdktf.stringToHclTerraform(this._dataViewId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      description: {
        value: cdktf.stringToHclTerraform(this._description),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      enabled: {
        value: cdktf.booleanToHclTerraform(this._enabled),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      exceptions_list: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleExceptionsListStructToHclTerraform, false)(this._exceptionsList.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleExceptionsListStructList",
      },
      false_positives: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._falsePositives),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      filters: {
        value: cdktf.stringToHclTerraform(this._filters),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      from: {
        value: cdktf.stringToHclTerraform(this._from),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      history_window_start: {
        value: cdktf.stringToHclTerraform(this._historyWindowStart),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      index: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._index),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      interval: {
        value: cdktf.stringToHclTerraform(this._interval),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      investigation_fields: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._investigationFields),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      items_per_search: {
        value: cdktf.numberToHclTerraform(this._itemsPerSearch),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      language: {
        value: cdktf.stringToHclTerraform(this._language),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      license: {
        value: cdktf.stringToHclTerraform(this._license),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      machine_learning_job_id: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._machineLearningJobId),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      max_signals: {
        value: cdktf.numberToHclTerraform(this._maxSignals),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      namespace: {
        value: cdktf.stringToHclTerraform(this._namespace),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      new_terms_fields: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._newTermsFields),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      note: {
        value: cdktf.stringToHclTerraform(this._note),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      query: {
        value: cdktf.stringToHclTerraform(this._query),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      references: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._references),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      related_integrations: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleRelatedIntegrationsToHclTerraform, false)(this._relatedIntegrations.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleRelatedIntegrationsList",
      },
      required_fields: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleRequiredFieldsToHclTerraform, false)(this._requiredFields.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleRequiredFieldsList",
      },
      response_actions: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleResponseActionsToHclTerraform, false)(this._responseActions.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleResponseActionsList",
      },
      risk_score: {
        value: cdktf.numberToHclTerraform(this._riskScore),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      risk_score_mapping: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleRiskScoreMappingToHclTerraform, false)(this._riskScoreMapping.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleRiskScoreMappingList",
      },
      rule_id: {
        value: cdktf.stringToHclTerraform(this._ruleId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      rule_name_override: {
        value: cdktf.stringToHclTerraform(this._ruleNameOverride),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      saved_id: {
        value: cdktf.stringToHclTerraform(this._savedId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      setup: {
        value: cdktf.stringToHclTerraform(this._setup),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      severity: {
        value: cdktf.stringToHclTerraform(this._severity),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      severity_mapping: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleSeverityMappingToHclTerraform, false)(this._severityMapping.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleSeverityMappingList",
      },
      space_id: {
        value: cdktf.stringToHclTerraform(this._spaceId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      tags: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._tags),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      threat: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleThreatToHclTerraform, false)(this._threat.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleThreatList",
      },
      threat_filters: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._threatFilters),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      threat_index: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._threatIndex),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      threat_indicator_path: {
        value: cdktf.stringToHclTerraform(this._threatIndicatorPath),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      threat_mapping: {
        value: cdktf.listMapperHcl(kibanaSecurityDetectionRuleThreatMappingToHclTerraform, false)(this._threatMapping.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "KibanaSecurityDetectionRuleThreatMappingList",
      },
      threat_query: {
        value: cdktf.stringToHclTerraform(this._threatQuery),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      threshold: {
        value: kibanaSecurityDetectionRuleThresholdToHclTerraform(this._threshold.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "KibanaSecurityDetectionRuleThreshold",
      },
      tiebreaker_field: {
        value: cdktf.stringToHclTerraform(this._tiebreakerField),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      timeline_id: {
        value: cdktf.stringToHclTerraform(this._timelineId),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      timeline_title: {
        value: cdktf.stringToHclTerraform(this._timelineTitle),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      timestamp_override: {
        value: cdktf.stringToHclTerraform(this._timestampOverride),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      timestamp_override_fallback_disabled: {
        value: cdktf.booleanToHclTerraform(this._timestampOverrideFallbackDisabled),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      to: {
        value: cdktf.stringToHclTerraform(this._to),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      type: {
        value: cdktf.stringToHclTerraform(this._type),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      version: {
        value: cdktf.numberToHclTerraform(this._version),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
