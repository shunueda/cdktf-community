// https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ResourceConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#id Resource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * aerospike block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aerospike Resource#aerospike}
  */
  readonly aerospike?: ResourceAerospike;
  /**
  * aks block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aks Resource#aks}
  */
  readonly aks?: ResourceAks;
  /**
  * aks_basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aks_basic_auth Resource#aks_basic_auth}
  */
  readonly aksBasicAuth?: ResourceAksBasicAuth;
  /**
  * aks_service_account block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aks_service_account Resource#aks_service_account}
  */
  readonly aksServiceAccount?: ResourceAksServiceAccount;
  /**
  * aks_service_account_user_impersonation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aks_service_account_user_impersonation Resource#aks_service_account_user_impersonation}
  */
  readonly aksServiceAccountUserImpersonation?: ResourceAksServiceAccountUserImpersonation;
  /**
  * aks_user_impersonation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aks_user_impersonation Resource#aks_user_impersonation}
  */
  readonly aksUserImpersonation?: ResourceAksUserImpersonation;
  /**
  * amazon_eks block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#amazon_eks Resource#amazon_eks}
  */
  readonly amazonEks?: ResourceAmazonEks;
  /**
  * amazon_eks_instance_profile block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#amazon_eks_instance_profile Resource#amazon_eks_instance_profile}
  */
  readonly amazonEksInstanceProfile?: ResourceAmazonEksInstanceProfile;
  /**
  * amazon_eks_instance_profile_user_impersonation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#amazon_eks_instance_profile_user_impersonation Resource#amazon_eks_instance_profile_user_impersonation}
  */
  readonly amazonEksInstanceProfileUserImpersonation?: ResourceAmazonEksInstanceProfileUserImpersonation;
  /**
  * amazon_eks_user_impersonation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#amazon_eks_user_impersonation Resource#amazon_eks_user_impersonation}
  */
  readonly amazonEksUserImpersonation?: ResourceAmazonEksUserImpersonation;
  /**
  * amazon_es block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#amazon_es Resource#amazon_es}
  */
  readonly amazonEs?: ResourceAmazonEs;
  /**
  * amazon_esiam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#amazon_esiam Resource#amazon_esiam}
  */
  readonly amazonEsiam?: ResourceAmazonEsiam;
  /**
  * amazonmq_amqp block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#amazonmq_amqp Resource#amazonmq_amqp}
  */
  readonly amazonmqAmqp?: ResourceAmazonmqAmqp;
  /**
  * amazonmq_amqp_091 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#amazonmq_amqp_091 Resource#amazonmq_amqp_091}
  */
  readonly amazonmqAmqp091?: ResourceAmazonmqAmqp091;
  /**
  * athena block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#athena Resource#athena}
  */
  readonly athena?: ResourceAthena;
  /**
  * athena_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#athena_iam Resource#athena_iam}
  */
  readonly athenaIam?: ResourceAthenaIam;
  /**
  * aurora_mysql block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aurora_mysql Resource#aurora_mysql}
  */
  readonly auroraMysql?: ResourceAuroraMysql;
  /**
  * aurora_mysql_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aurora_mysql_iam Resource#aurora_mysql_iam}
  */
  readonly auroraMysqlIam?: ResourceAuroraMysqlIam;
  /**
  * aurora_postgres block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aurora_postgres Resource#aurora_postgres}
  */
  readonly auroraPostgres?: ResourceAuroraPostgres;
  /**
  * aurora_postgres_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aurora_postgres_iam Resource#aurora_postgres_iam}
  */
  readonly auroraPostgresIam?: ResourceAuroraPostgresIam;
  /**
  * aws block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aws Resource#aws}
  */
  readonly aws?: ResourceAws;
  /**
  * aws_console block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aws_console Resource#aws_console}
  */
  readonly awsConsole?: ResourceAwsConsole;
  /**
  * aws_console_static_key_pair block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aws_console_static_key_pair Resource#aws_console_static_key_pair}
  */
  readonly awsConsoleStaticKeyPair?: ResourceAwsConsoleStaticKeyPair;
  /**
  * aws_instance_profile block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#aws_instance_profile Resource#aws_instance_profile}
  */
  readonly awsInstanceProfile?: ResourceAwsInstanceProfile;
  /**
  * azure block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#azure Resource#azure}
  */
  readonly azure?: ResourceAzure;
  /**
  * azure_certificate block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#azure_certificate Resource#azure_certificate}
  */
  readonly azureCertificate?: ResourceAzureCertificate;
  /**
  * azure_mysql block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#azure_mysql Resource#azure_mysql}
  */
  readonly azureMysql?: ResourceAzureMysql;
  /**
  * azure_mysql_managed_identity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#azure_mysql_managed_identity Resource#azure_mysql_managed_identity}
  */
  readonly azureMysqlManagedIdentity?: ResourceAzureMysqlManagedIdentity;
  /**
  * azure_postgres block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#azure_postgres Resource#azure_postgres}
  */
  readonly azurePostgres?: ResourceAzurePostgres;
  /**
  * azure_postgres_managed_identity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#azure_postgres_managed_identity Resource#azure_postgres_managed_identity}
  */
  readonly azurePostgresManagedIdentity?: ResourceAzurePostgresManagedIdentity;
  /**
  * big_query block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#big_query Resource#big_query}
  */
  readonly bigQuery?: ResourceBigQuery;
  /**
  * cassandra block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#cassandra Resource#cassandra}
  */
  readonly cassandra?: ResourceCassandra;
  /**
  * citus block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#citus Resource#citus}
  */
  readonly citus?: ResourceCitus;
  /**
  * click_house_http block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#click_house_http Resource#click_house_http}
  */
  readonly clickHouseHttp?: ResourceClickHouseHttp;
  /**
  * click_house_my_sql block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#click_house_my_sql Resource#click_house_my_sql}
  */
  readonly clickHouseMySql?: ResourceClickHouseMySql;
  /**
  * click_house_tcp block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#click_house_tcp Resource#click_house_tcp}
  */
  readonly clickHouseTcp?: ResourceClickHouseTcp;
  /**
  * clustrix block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#clustrix Resource#clustrix}
  */
  readonly clustrix?: ResourceClustrix;
  /**
  * cockroach block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#cockroach Resource#cockroach}
  */
  readonly cockroach?: ResourceCockroach;
  /**
  * couchbase_database block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#couchbase_database Resource#couchbase_database}
  */
  readonly couchbaseDatabase?: ResourceCouchbaseDatabase;
  /**
  * couchbase_web_ui block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#couchbase_web_ui Resource#couchbase_web_ui}
  */
  readonly couchbaseWebUi?: ResourceCouchbaseWebUi;
  /**
  * db_2_i block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#db_2_i Resource#db_2_i}
  */
  readonly db2I?: ResourceDb2I;
  /**
  * db_2_luw block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#db_2_luw Resource#db_2_luw}
  */
  readonly db2Luw?: ResourceDb2Luw;
  /**
  * document_db_host block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#document_db_host Resource#document_db_host}
  */
  readonly documentDbHost?: ResourceDocumentDbHost;
  /**
  * document_db_host_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#document_db_host_iam Resource#document_db_host_iam}
  */
  readonly documentDbHostIam?: ResourceDocumentDbHostIam;
  /**
  * document_db_replica_set block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#document_db_replica_set Resource#document_db_replica_set}
  */
  readonly documentDbReplicaSet?: ResourceDocumentDbReplicaSet;
  /**
  * document_db_replica_set_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#document_db_replica_set_iam Resource#document_db_replica_set_iam}
  */
  readonly documentDbReplicaSetIam?: ResourceDocumentDbReplicaSetIam;
  /**
  * druid block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#druid Resource#druid}
  */
  readonly druid?: ResourceDruid;
  /**
  * dynamo_db block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#dynamo_db Resource#dynamo_db}
  */
  readonly dynamoDb?: ResourceDynamoDb;
  /**
  * dynamo_dbiam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#dynamo_dbiam Resource#dynamo_dbiam}
  */
  readonly dynamoDbiam?: ResourceDynamoDbiam;
  /**
  * elastic block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#elastic Resource#elastic}
  */
  readonly elastic?: ResourceElastic;
  /**
  * elasticache_redis block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#elasticache_redis Resource#elasticache_redis}
  */
  readonly elasticacheRedis?: ResourceElasticacheRedis;
  /**
  * elasticache_redis_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#elasticache_redis_iam Resource#elasticache_redis_iam}
  */
  readonly elasticacheRedisIam?: ResourceElasticacheRedisIam;
  /**
  * entra_id block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#entra_id Resource#entra_id}
  */
  readonly entraId?: ResourceEntraId;
  /**
  * gcp block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#gcp Resource#gcp}
  */
  readonly gcp?: ResourceGcp;
  /**
  * gcp_console block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#gcp_console Resource#gcp_console}
  */
  readonly gcpConsole?: ResourceGcpConsole;
  /**
  * gcpwif block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#gcpwif Resource#gcpwif}
  */
  readonly gcpwif?: ResourceGcpwif;
  /**
  * google_gke block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#google_gke Resource#google_gke}
  */
  readonly googleGke?: ResourceGoogleGke;
  /**
  * google_gke_user_impersonation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#google_gke_user_impersonation Resource#google_gke_user_impersonation}
  */
  readonly googleGkeUserImpersonation?: ResourceGoogleGkeUserImpersonation;
  /**
  * greenplum block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#greenplum Resource#greenplum}
  */
  readonly greenplum?: ResourceGreenplum;
  /**
  * http_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#http_auth Resource#http_auth}
  */
  readonly httpAuth?: ResourceHttpAuth;
  /**
  * http_basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#http_basic_auth Resource#http_basic_auth}
  */
  readonly httpBasicAuth?: ResourceHttpBasicAuth;
  /**
  * http_no_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#http_no_auth Resource#http_no_auth}
  */
  readonly httpNoAuth?: ResourceHttpNoAuth;
  /**
  * kubernetes block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#kubernetes Resource#kubernetes}
  */
  readonly kubernetes?: ResourceKubernetes;
  /**
  * kubernetes_basic_auth block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#kubernetes_basic_auth Resource#kubernetes_basic_auth}
  */
  readonly kubernetesBasicAuth?: ResourceKubernetesBasicAuth;
  /**
  * kubernetes_pod_identity block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#kubernetes_pod_identity Resource#kubernetes_pod_identity}
  */
  readonly kubernetesPodIdentity?: ResourceKubernetesPodIdentity;
  /**
  * kubernetes_service_account block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#kubernetes_service_account Resource#kubernetes_service_account}
  */
  readonly kubernetesServiceAccount?: ResourceKubernetesServiceAccount;
  /**
  * kubernetes_service_account_user_impersonation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#kubernetes_service_account_user_impersonation Resource#kubernetes_service_account_user_impersonation}
  */
  readonly kubernetesServiceAccountUserImpersonation?: ResourceKubernetesServiceAccountUserImpersonation;
  /**
  * kubernetes_user_impersonation block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#kubernetes_user_impersonation Resource#kubernetes_user_impersonation}
  */
  readonly kubernetesUserImpersonation?: ResourceKubernetesUserImpersonation;
  /**
  * maria block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#maria Resource#maria}
  */
  readonly maria?: ResourceMaria;
  /**
  * mcp block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mcp Resource#mcp}
  */
  readonly mcp?: ResourceMcp;
  /**
  * memcached block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#memcached Resource#memcached}
  */
  readonly memcached?: ResourceMemcached;
  /**
  * memsql block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#memsql Resource#memsql}
  */
  readonly memsql?: ResourceMemsql;
  /**
  * mongo_host block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mongo_host Resource#mongo_host}
  */
  readonly mongoHost?: ResourceMongoHost;
  /**
  * mongo_legacy_host block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mongo_legacy_host Resource#mongo_legacy_host}
  */
  readonly mongoLegacyHost?: ResourceMongoLegacyHost;
  /**
  * mongo_legacy_replicaset block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mongo_legacy_replicaset Resource#mongo_legacy_replicaset}
  */
  readonly mongoLegacyReplicaset?: ResourceMongoLegacyReplicaset;
  /**
  * mongo_replica_set block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mongo_replica_set Resource#mongo_replica_set}
  */
  readonly mongoReplicaSet?: ResourceMongoReplicaSet;
  /**
  * mongo_sharded_cluster block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mongo_sharded_cluster Resource#mongo_sharded_cluster}
  */
  readonly mongoShardedCluster?: ResourceMongoShardedCluster;
  /**
  * mtls_mysql block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mtls_mysql Resource#mtls_mysql}
  */
  readonly mtlsMysql?: ResourceMtlsMysql;
  /**
  * mtls_postgres block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mtls_postgres Resource#mtls_postgres}
  */
  readonly mtlsPostgres?: ResourceMtlsPostgres;
  /**
  * mysql block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#mysql Resource#mysql}
  */
  readonly mysql?: ResourceMysql;
  /**
  * neptune block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#neptune Resource#neptune}
  */
  readonly neptune?: ResourceNeptune;
  /**
  * neptune_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#neptune_iam Resource#neptune_iam}
  */
  readonly neptuneIam?: ResourceNeptuneIam;
  /**
  * oracle block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#oracle Resource#oracle}
  */
  readonly oracle?: ResourceOracle;
  /**
  * oracle_nne block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#oracle_nne Resource#oracle_nne}
  */
  readonly oracleNne?: ResourceOracleNne;
  /**
  * postgres block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#postgres Resource#postgres}
  */
  readonly postgres?: ResourcePostgres;
  /**
  * presto block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#presto Resource#presto}
  */
  readonly presto?: ResourcePresto;
  /**
  * rabbitmq_amqp_091 block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#rabbitmq_amqp_091 Resource#rabbitmq_amqp_091}
  */
  readonly rabbitmqAmqp091?: ResourceRabbitmqAmqp091;
  /**
  * raw_tcp block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#raw_tcp Resource#raw_tcp}
  */
  readonly rawTcp?: ResourceRawTcp;
  /**
  * rdp block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#rdp Resource#rdp}
  */
  readonly rdp?: ResourceRdp;
  /**
  * rdp_cert block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#rdp_cert Resource#rdp_cert}
  */
  readonly rdpCert?: ResourceRdpCert;
  /**
  * rds_postgres_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#rds_postgres_iam Resource#rds_postgres_iam}
  */
  readonly rdsPostgresIam?: ResourceRdsPostgresIam;
  /**
  * redis block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#redis Resource#redis}
  */
  readonly redis?: ResourceRedis;
  /**
  * redis_cluster block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#redis_cluster Resource#redis_cluster}
  */
  readonly redisCluster?: ResourceRedisCluster;
  /**
  * redshift block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#redshift Resource#redshift}
  */
  readonly redshift?: ResourceRedshift;
  /**
  * redshift_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#redshift_iam Resource#redshift_iam}
  */
  readonly redshiftIam?: ResourceRedshiftIam;
  /**
  * redshift_serverless_iam block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#redshift_serverless_iam Resource#redshift_serverless_iam}
  */
  readonly redshiftServerlessIam?: ResourceRedshiftServerlessIam;
  /**
  * single_store block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#single_store Resource#single_store}
  */
  readonly singleStore?: ResourceSingleStore;
  /**
  * snowflake block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#snowflake Resource#snowflake}
  */
  readonly snowflake?: ResourceSnowflake;
  /**
  * snowsight block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#snowsight Resource#snowsight}
  */
  readonly snowsight?: ResourceSnowsight;
  /**
  * sql_server block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#sql_server Resource#sql_server}
  */
  readonly sqlServer?: ResourceSqlServer;
  /**
  * sql_server_azure_ad block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#sql_server_azure_ad Resource#sql_server_azure_ad}
  */
  readonly sqlServerAzureAd?: ResourceSqlServerAzureAd;
  /**
  * sql_server_kerberos_ad block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#sql_server_kerberos_ad Resource#sql_server_kerberos_ad}
  */
  readonly sqlServerKerberosAd?: ResourceSqlServerKerberosAd;
  /**
  * ssh block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#ssh Resource#ssh}
  */
  readonly ssh?: ResourceSsh;
  /**
  * ssh_cert block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#ssh_cert Resource#ssh_cert}
  */
  readonly sshCert?: ResourceSshCert;
  /**
  * ssh_customer_key block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#ssh_customer_key Resource#ssh_customer_key}
  */
  readonly sshCustomerKey?: ResourceSshCustomerKey;
  /**
  * ssh_password block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#ssh_password Resource#ssh_password}
  */
  readonly sshPassword?: ResourceSshPassword;
  /**
  * sybase block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#sybase Resource#sybase}
  */
  readonly sybase?: ResourceSybase;
  /**
  * sybase_iq block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#sybase_iq Resource#sybase_iq}
  */
  readonly sybaseIq?: ResourceSybaseIq;
  /**
  * teradata block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#teradata Resource#teradata}
  */
  readonly teradata?: ResourceTeradata;
  /**
  * timeouts block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#timeouts Resource#timeouts}
  */
  readonly timeouts?: ResourceTimeouts;
  /**
  * trino block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#trino Resource#trino}
  */
  readonly trino?: ResourceTrino;
  /**
  * vertica block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#vertica Resource#vertica}
  */
  readonly vertica?: ResourceVertica;
}
export interface ResourceAerospike {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, uses UseServicesAlternates directive for Aerospike connection
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_services_alternate Resource#use_services_alternate}
  */
  readonly useServicesAlternate?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAerospikeToTerraform(struct?: ResourceAerospikeOutputReference | ResourceAerospike): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_services_alternate: cdktf.booleanToTerraform(struct!.useServicesAlternate),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAerospikeToHclTerraform(struct?: ResourceAerospikeOutputReference | ResourceAerospike): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_services_alternate: {
      value: cdktf.booleanToHclTerraform(struct!.useServicesAlternate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAerospikeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAerospike | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useServicesAlternate !== undefined) {
      hasAnyValues = true;
      internalValueResult.useServicesAlternate = this._useServicesAlternate;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAerospike | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useServicesAlternate = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useServicesAlternate = value.useServicesAlternate;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_services_alternate - computed: false, optional: true, required: false
  private _useServicesAlternate?: boolean | cdktf.IResolvable; 
  public get useServicesAlternate() {
    return this.getBooleanAttribute('use_services_alternate');
  }
  public set useServicesAlternate(value: boolean | cdktf.IResolvable) {
    this._useServicesAlternate = value;
  }
  public resetUseServicesAlternate() {
    this._useServicesAlternate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useServicesAlternateInput() {
    return this._useServicesAlternate;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAks {
  /**
  * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_resource_role_bypass Resource#allow_resource_role_bypass}
  */
  readonly allowResourceRoleBypass?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The certificate to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_certificate Resource#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * The key to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_key Resource#client_key}
  */
  readonly clientKey?: string;
  /**
  * If true, configures discovery of a cluster to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_username Resource#discovery_username}
  */
  readonly discoveryUsername?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAksToTerraform(struct?: ResourceAksOutputReference | ResourceAks): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_resource_role_bypass: cdktf.booleanToTerraform(struct!.allowResourceRoleBypass),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    client_key: cdktf.stringToTerraform(struct!.clientKey),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    discovery_username: cdktf.stringToTerraform(struct!.discoveryUsername),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAksToHclTerraform(struct?: ResourceAksOutputReference | ResourceAks): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_resource_role_bypass: {
      value: cdktf.booleanToHclTerraform(struct!.allowResourceRoleBypass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_key: {
      value: cdktf.stringToHclTerraform(struct!.clientKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_username: {
      value: cdktf.stringToHclTerraform(struct!.discoveryUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAks | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowResourceRoleBypass !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowResourceRoleBypass = this._allowResourceRoleBypass;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._clientKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientKey = this._clientKey;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._discoveryUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryUsername = this._discoveryUsername;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAks | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowResourceRoleBypass = undefined;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clientCertificate = undefined;
      this._clientKey = undefined;
      this._discoveryEnabled = undefined;
      this._discoveryUsername = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowResourceRoleBypass = value.allowResourceRoleBypass;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clientCertificate = value.clientCertificate;
      this._clientKey = value.clientKey;
      this._discoveryEnabled = value.discoveryEnabled;
      this._discoveryUsername = value.discoveryUsername;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // allow_resource_role_bypass - computed: false, optional: true, required: false
  private _allowResourceRoleBypass?: boolean | cdktf.IResolvable; 
  public get allowResourceRoleBypass() {
    return this.getBooleanAttribute('allow_resource_role_bypass');
  }
  public set allowResourceRoleBypass(value: boolean | cdktf.IResolvable) {
    this._allowResourceRoleBypass = value;
  }
  public resetAllowResourceRoleBypass() {
    this._allowResourceRoleBypass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowResourceRoleBypassInput() {
    return this._allowResourceRoleBypass;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // client_key - computed: false, optional: true, required: false
  private _clientKey?: string; 
  public get clientKey() {
    return this.getStringAttribute('client_key');
  }
  public set clientKey(value: string) {
    this._clientKey = value;
  }
  public resetClientKey() {
    this._clientKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientKeyInput() {
    return this._clientKey;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // discovery_username - computed: false, optional: true, required: false
  private _discoveryUsername?: string; 
  public get discoveryUsername() {
    return this.getStringAttribute('discovery_username');
  }
  public set discoveryUsername(value: string) {
    this._discoveryUsername = value;
  }
  public resetDiscoveryUsername() {
    this._discoveryUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryUsernameInput() {
    return this._discoveryUsername;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAksBasicAuth {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAksBasicAuthToTerraform(struct?: ResourceAksBasicAuthOutputReference | ResourceAksBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAksBasicAuthToHclTerraform(struct?: ResourceAksBasicAuthOutputReference | ResourceAksBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAksBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAksBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAksBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAksServiceAccount {
  /**
  * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_resource_role_bypass Resource#allow_resource_role_bypass}
  */
  readonly allowResourceRoleBypass?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * If true, configures discovery of a cluster to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_username Resource#discovery_username}
  */
  readonly discoveryUsername?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The API token to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#token Resource#token}
  */
  readonly token?: string;
}

export function resourceAksServiceAccountToTerraform(struct?: ResourceAksServiceAccountOutputReference | ResourceAksServiceAccount): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_resource_role_bypass: cdktf.booleanToTerraform(struct!.allowResourceRoleBypass),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    discovery_username: cdktf.stringToTerraform(struct!.discoveryUsername),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    token: cdktf.stringToTerraform(struct!.token),
  }
}


export function resourceAksServiceAccountToHclTerraform(struct?: ResourceAksServiceAccountOutputReference | ResourceAksServiceAccount): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_resource_role_bypass: {
      value: cdktf.booleanToHclTerraform(struct!.allowResourceRoleBypass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_username: {
      value: cdktf.stringToHclTerraform(struct!.discoveryUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAksServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAksServiceAccount | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowResourceRoleBypass !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowResourceRoleBypass = this._allowResourceRoleBypass;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._discoveryUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryUsername = this._discoveryUsername;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAksServiceAccount | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowResourceRoleBypass = undefined;
      this._bindInterface = undefined;
      this._discoveryEnabled = undefined;
      this._discoveryUsername = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._token = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowResourceRoleBypass = value.allowResourceRoleBypass;
      this._bindInterface = value.bindInterface;
      this._discoveryEnabled = value.discoveryEnabled;
      this._discoveryUsername = value.discoveryUsername;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._token = value.token;
    }
  }

  // allow_resource_role_bypass - computed: false, optional: true, required: false
  private _allowResourceRoleBypass?: boolean | cdktf.IResolvable; 
  public get allowResourceRoleBypass() {
    return this.getBooleanAttribute('allow_resource_role_bypass');
  }
  public set allowResourceRoleBypass(value: boolean | cdktf.IResolvable) {
    this._allowResourceRoleBypass = value;
  }
  public resetAllowResourceRoleBypass() {
    this._allowResourceRoleBypass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowResourceRoleBypassInput() {
    return this._allowResourceRoleBypass;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // discovery_username - computed: false, optional: true, required: false
  private _discoveryUsername?: string; 
  public get discoveryUsername() {
    return this.getStringAttribute('discovery_username');
  }
  public set discoveryUsername(value: string) {
    this._discoveryUsername = value;
  }
  public resetDiscoveryUsername() {
    this._discoveryUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryUsernameInput() {
    return this._discoveryUsername;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }
}
export interface ResourceAksServiceAccountUserImpersonation {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The API token to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#token Resource#token}
  */
  readonly token?: string;
}

export function resourceAksServiceAccountUserImpersonationToTerraform(struct?: ResourceAksServiceAccountUserImpersonationOutputReference | ResourceAksServiceAccountUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    token: cdktf.stringToTerraform(struct!.token),
  }
}


export function resourceAksServiceAccountUserImpersonationToHclTerraform(struct?: ResourceAksServiceAccountUserImpersonationOutputReference | ResourceAksServiceAccountUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAksServiceAccountUserImpersonationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAksServiceAccountUserImpersonation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAksServiceAccountUserImpersonation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._token = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._token = value.token;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }
}
export interface ResourceAksUserImpersonation {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The certificate to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_certificate Resource#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * The key to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_key Resource#client_key}
  */
  readonly clientKey?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAksUserImpersonationToTerraform(struct?: ResourceAksUserImpersonationOutputReference | ResourceAksUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    client_key: cdktf.stringToTerraform(struct!.clientKey),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAksUserImpersonationToHclTerraform(struct?: ResourceAksUserImpersonationOutputReference | ResourceAksUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_key: {
      value: cdktf.stringToHclTerraform(struct!.clientKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAksUserImpersonationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAksUserImpersonation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._clientKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientKey = this._clientKey;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAksUserImpersonation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clientCertificate = undefined;
      this._clientKey = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clientCertificate = value.clientCertificate;
      this._clientKey = value.clientKey;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // client_key - computed: false, optional: true, required: false
  private _clientKey?: string; 
  public get clientKey() {
    return this.getStringAttribute('client_key');
  }
  public set clientKey(value: string) {
    this._clientKey = value;
  }
  public resetClientKey() {
    this._clientKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientKeyInput() {
    return this._clientKey;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAmazonEks {
  /**
  * The Access Key ID to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#access_key Resource#access_key}
  */
  readonly accessKey?: string;
  /**
  * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_resource_role_bypass Resource#allow_resource_role_bypass}
  */
  readonly allowResourceRoleBypass?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The name of the cluster to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#cluster_name Resource#cluster_name}
  */
  readonly clusterName: string;
  /**
  * If true, configures discovery of a cluster to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_username Resource#discovery_username}
  */
  readonly discoveryUsername?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to e.g. us-east-1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * The Secret Access Key to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_access_key Resource#secret_access_key}
  */
  readonly secretAccessKey?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAmazonEksToTerraform(struct?: ResourceAmazonEksOutputReference | ResourceAmazonEks): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    allow_resource_role_bypass: cdktf.booleanToTerraform(struct!.allowResourceRoleBypass),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    discovery_username: cdktf.stringToTerraform(struct!.discoveryUsername),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_access_key: cdktf.stringToTerraform(struct!.secretAccessKey),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAmazonEksToHclTerraform(struct?: ResourceAmazonEksOutputReference | ResourceAmazonEks): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    allow_resource_role_bypass: {
      value: cdktf.booleanToHclTerraform(struct!.allowResourceRoleBypass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_username: {
      value: cdktf.stringToHclTerraform(struct!.discoveryUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.secretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAmazonEksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAmazonEks | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._allowResourceRoleBypass !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowResourceRoleBypass = this._allowResourceRoleBypass;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._discoveryUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryUsername = this._discoveryUsername;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAmazonEks | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._allowResourceRoleBypass = undefined;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clusterName = undefined;
      this._discoveryEnabled = undefined;
      this._discoveryUsername = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._healthcheckNamespace = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretAccessKey = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._allowResourceRoleBypass = value.allowResourceRoleBypass;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clusterName = value.clusterName;
      this._discoveryEnabled = value.discoveryEnabled;
      this._discoveryUsername = value.discoveryUsername;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretAccessKey = value.secretAccessKey;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // allow_resource_role_bypass - computed: false, optional: true, required: false
  private _allowResourceRoleBypass?: boolean | cdktf.IResolvable; 
  public get allowResourceRoleBypass() {
    return this.getBooleanAttribute('allow_resource_role_bypass');
  }
  public set allowResourceRoleBypass(value: boolean | cdktf.IResolvable) {
    this._allowResourceRoleBypass = value;
  }
  public resetAllowResourceRoleBypass() {
    this._allowResourceRoleBypass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowResourceRoleBypassInput() {
    return this._allowResourceRoleBypass;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // cluster_name - computed: false, optional: false, required: true
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // discovery_username - computed: false, optional: true, required: false
  private _discoveryUsername?: string; 
  public get discoveryUsername() {
    return this.getStringAttribute('discovery_username');
  }
  public set discoveryUsername(value: string) {
    this._discoveryUsername = value;
  }
  public resetDiscoveryUsername() {
    this._discoveryUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryUsernameInput() {
    return this._discoveryUsername;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey?: string; 
  public get secretAccessKey() {
    return this.getStringAttribute('secret_access_key');
  }
  public set secretAccessKey(value: string) {
    this._secretAccessKey = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAmazonEksInstanceProfile {
  /**
  * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_resource_role_bypass Resource#allow_resource_role_bypass}
  */
  readonly allowResourceRoleBypass?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The name of the cluster to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#cluster_name Resource#cluster_name}
  */
  readonly clusterName: string;
  /**
  * If true, configures discovery of a cluster to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_username Resource#discovery_username}
  */
  readonly discoveryUsername?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to e.g. us-east-1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAmazonEksInstanceProfileToTerraform(struct?: ResourceAmazonEksInstanceProfileOutputReference | ResourceAmazonEksInstanceProfile): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_resource_role_bypass: cdktf.booleanToTerraform(struct!.allowResourceRoleBypass),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    discovery_username: cdktf.stringToTerraform(struct!.discoveryUsername),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAmazonEksInstanceProfileToHclTerraform(struct?: ResourceAmazonEksInstanceProfileOutputReference | ResourceAmazonEksInstanceProfile): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_resource_role_bypass: {
      value: cdktf.booleanToHclTerraform(struct!.allowResourceRoleBypass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_username: {
      value: cdktf.stringToHclTerraform(struct!.discoveryUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAmazonEksInstanceProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAmazonEksInstanceProfile | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowResourceRoleBypass !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowResourceRoleBypass = this._allowResourceRoleBypass;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._discoveryUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryUsername = this._discoveryUsername;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAmazonEksInstanceProfile | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowResourceRoleBypass = undefined;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clusterName = undefined;
      this._discoveryEnabled = undefined;
      this._discoveryUsername = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._healthcheckNamespace = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowResourceRoleBypass = value.allowResourceRoleBypass;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clusterName = value.clusterName;
      this._discoveryEnabled = value.discoveryEnabled;
      this._discoveryUsername = value.discoveryUsername;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // allow_resource_role_bypass - computed: false, optional: true, required: false
  private _allowResourceRoleBypass?: boolean | cdktf.IResolvable; 
  public get allowResourceRoleBypass() {
    return this.getBooleanAttribute('allow_resource_role_bypass');
  }
  public set allowResourceRoleBypass(value: boolean | cdktf.IResolvable) {
    this._allowResourceRoleBypass = value;
  }
  public resetAllowResourceRoleBypass() {
    this._allowResourceRoleBypass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowResourceRoleBypassInput() {
    return this._allowResourceRoleBypass;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // cluster_name - computed: false, optional: false, required: true
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // discovery_username - computed: false, optional: true, required: false
  private _discoveryUsername?: string; 
  public get discoveryUsername() {
    return this.getStringAttribute('discovery_username');
  }
  public set discoveryUsername(value: string) {
    this._discoveryUsername = value;
  }
  public resetDiscoveryUsername() {
    this._discoveryUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryUsernameInput() {
    return this._discoveryUsername;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAmazonEksInstanceProfileUserImpersonation {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The name of the cluster to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#cluster_name Resource#cluster_name}
  */
  readonly clusterName: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to e.g. us-east-1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAmazonEksInstanceProfileUserImpersonationToTerraform(struct?: ResourceAmazonEksInstanceProfileUserImpersonationOutputReference | ResourceAmazonEksInstanceProfileUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAmazonEksInstanceProfileUserImpersonationToHclTerraform(struct?: ResourceAmazonEksInstanceProfileUserImpersonationOutputReference | ResourceAmazonEksInstanceProfileUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAmazonEksInstanceProfileUserImpersonationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAmazonEksInstanceProfileUserImpersonation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAmazonEksInstanceProfileUserImpersonation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clusterName = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._healthcheckNamespace = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clusterName = value.clusterName;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // cluster_name - computed: false, optional: false, required: true
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAmazonEksUserImpersonation {
  /**
  * The Access Key ID to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#access_key Resource#access_key}
  */
  readonly accessKey?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The name of the cluster to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#cluster_name Resource#cluster_name}
  */
  readonly clusterName: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to e.g. us-east-1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * The Secret Access Key to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_access_key Resource#secret_access_key}
  */
  readonly secretAccessKey?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAmazonEksUserImpersonationToTerraform(struct?: ResourceAmazonEksUserImpersonationOutputReference | ResourceAmazonEksUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_access_key: cdktf.stringToTerraform(struct!.secretAccessKey),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAmazonEksUserImpersonationToHclTerraform(struct?: ResourceAmazonEksUserImpersonationOutputReference | ResourceAmazonEksUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.secretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAmazonEksUserImpersonationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAmazonEksUserImpersonation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAmazonEksUserImpersonation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clusterName = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._healthcheckNamespace = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretAccessKey = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clusterName = value.clusterName;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretAccessKey = value.secretAccessKey;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // cluster_name - computed: false, optional: false, required: true
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey?: string; 
  public get secretAccessKey() {
    return this.getStringAttribute('secret_access_key');
  }
  public set secretAccessKey(value: string) {
    this._secretAccessKey = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAmazonEs {
  /**
  * The Access Key ID to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#access_key Resource#access_key}
  */
  readonly accessKey?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial e.g. search-?.region.es.amazonaws.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to e.g. us-east-1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * The Secret Access Key to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_access_key Resource#secret_access_key}
  */
  readonly secretAccessKey?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAmazonEsToTerraform(struct?: ResourceAmazonEsOutputReference | ResourceAmazonEs): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_access_key: cdktf.stringToTerraform(struct!.secretAccessKey),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAmazonEsToHclTerraform(struct?: ResourceAmazonEsOutputReference | ResourceAmazonEs): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.secretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAmazonEsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAmazonEs | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAmazonEs | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretAccessKey = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretAccessKey = value.secretAccessKey;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey?: string; 
  public get secretAccessKey() {
    return this.getStringAttribute('secret_access_key');
  }
  public set secretAccessKey(value: string) {
    this._secretAccessKey = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAmazonEsiam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial e.g. search-?.region.es.amazonaws.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * Use TLS to connect to the OpenSearch server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
}

export function resourceAmazonEsiamToTerraform(struct?: ResourceAmazonEsiamOutputReference | ResourceAmazonEsiam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
  }
}


export function resourceAmazonEsiamToHclTerraform(struct?: ResourceAmazonEsiamOutputReference | ResourceAmazonEsiam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAmazonEsiamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAmazonEsiam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAmazonEsiam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }
}
export interface ResourceAmazonmqAmqp {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAmazonmqAmqpToTerraform(struct?: ResourceAmazonmqAmqpOutputReference | ResourceAmazonmqAmqp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAmazonmqAmqpToHclTerraform(struct?: ResourceAmazonmqAmqpOutputReference | ResourceAmazonmqAmqp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAmazonmqAmqpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAmazonmqAmqp | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAmazonmqAmqp | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAmazonmqAmqp091 {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAmazonmqAmqp091ToTerraform(struct?: ResourceAmazonmqAmqp091OutputReference | ResourceAmazonmqAmqp091): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAmazonmqAmqp091ToHclTerraform(struct?: ResourceAmazonmqAmqp091OutputReference | ResourceAmazonmqAmqp091): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAmazonmqAmqp091OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAmazonmqAmqp091 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAmazonmqAmqp091 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAthena {
  /**
  * The Access Key ID to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#access_key Resource#access_key}
  */
  readonly accessKey?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The AWS S3 output location.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#output Resource#output}
  */
  readonly output: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to e.g. us-east-1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region?: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * The Secret Access Key to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_access_key Resource#secret_access_key}
  */
  readonly secretAccessKey?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAthenaToTerraform(struct?: ResourceAthenaOutputReference | ResourceAthena): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    name: cdktf.stringToTerraform(struct!.name),
    output: cdktf.stringToTerraform(struct!.output),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_access_key: cdktf.stringToTerraform(struct!.secretAccessKey),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAthenaToHclTerraform(struct?: ResourceAthenaOutputReference | ResourceAthena): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.secretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAthenaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAthena | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAthena | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._name = undefined;
      this._output = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretAccessKey = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._name = value.name;
      this._output = value.output;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretAccessKey = value.secretAccessKey;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey?: string; 
  public get secretAccessKey() {
    return this.getStringAttribute('secret_access_key');
  }
  public set secretAccessKey(value: string) {
    this._secretAccessKey = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAthenaIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The AWS S3 output location.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#output Resource#output}
  */
  readonly output: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to e.g. us-east-1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region?: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAthenaIamToTerraform(struct?: ResourceAthenaIamOutputReference | ResourceAthenaIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    name: cdktf.stringToTerraform(struct!.name),
    output: cdktf.stringToTerraform(struct!.output),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAthenaIamToHclTerraform(struct?: ResourceAthenaIamOutputReference | ResourceAthenaIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAthenaIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAthenaIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAthenaIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._name = undefined;
      this._output = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._name = value.name;
      this._output = value.output;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAuroraMysql {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAuroraMysqlToTerraform(struct?: ResourceAuroraMysqlOutputReference | ResourceAuroraMysql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAuroraMysqlToHclTerraform(struct?: ResourceAuroraMysqlOutputReference | ResourceAuroraMysql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAuroraMysqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAuroraMysql | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAuroraMysql | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAuroraMysqlIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_assumption_arn Resource#role_assumption_arn}
  */
  readonly roleAssumptionArn?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAuroraMysqlIamToTerraform(struct?: ResourceAuroraMysqlIamOutputReference | ResourceAuroraMysqlIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_assumption_arn: cdktf.stringToTerraform(struct!.roleAssumptionArn),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAuroraMysqlIamToHclTerraform(struct?: ResourceAuroraMysqlIamOutputReference | ResourceAuroraMysqlIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_assumption_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleAssumptionArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAuroraMysqlIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAuroraMysqlIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleAssumptionArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleAssumptionArn = this._roleAssumptionArn;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAuroraMysqlIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleAssumptionArn = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleAssumptionArn = value.roleAssumptionArn;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_assumption_arn - computed: false, optional: true, required: false
  private _roleAssumptionArn?: string; 
  public get roleAssumptionArn() {
    return this.getStringAttribute('role_assumption_arn');
  }
  public set roleAssumptionArn(value: string) {
    this._roleAssumptionArn = value;
  }
  public resetRoleAssumptionArn() {
    this._roleAssumptionArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleAssumptionArnInput() {
    return this._roleAssumptionArn;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAuroraPostgres {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAuroraPostgresToTerraform(struct?: ResourceAuroraPostgresOutputReference | ResourceAuroraPostgres): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAuroraPostgresToHclTerraform(struct?: ResourceAuroraPostgresOutputReference | ResourceAuroraPostgres): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAuroraPostgresOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAuroraPostgres | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAuroraPostgres | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAuroraPostgresIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_assumption_arn Resource#role_assumption_arn}
  */
  readonly roleAssumptionArn?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAuroraPostgresIamToTerraform(struct?: ResourceAuroraPostgresIamOutputReference | ResourceAuroraPostgresIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_assumption_arn: cdktf.stringToTerraform(struct!.roleAssumptionArn),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAuroraPostgresIamToHclTerraform(struct?: ResourceAuroraPostgresIamOutputReference | ResourceAuroraPostgresIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_assumption_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleAssumptionArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAuroraPostgresIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAuroraPostgresIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleAssumptionArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleAssumptionArn = this._roleAssumptionArn;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAuroraPostgresIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleAssumptionArn = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleAssumptionArn = value.roleAssumptionArn;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_assumption_arn - computed: false, optional: true, required: false
  private _roleAssumptionArn?: string; 
  public get roleAssumptionArn() {
    return this.getStringAttribute('role_assumption_arn');
  }
  public set roleAssumptionArn(value: string) {
    this._roleAssumptionArn = value;
  }
  public resetRoleAssumptionArn() {
    this._roleAssumptionArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleAssumptionArnInput() {
    return this._roleAssumptionArn;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAws {
  /**
  * The Access Key ID to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#access_key Resource#access_key}
  */
  readonly accessKey?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The AWS region healthcheck requests should attempt to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_region Resource#healthcheck_region}
  */
  readonly healthcheckRegion: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * The Secret Access Key to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_access_key Resource#secret_access_key}
  */
  readonly secretAccessKey?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAwsToTerraform(struct?: ResourceAwsOutputReference | ResourceAws): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_region: cdktf.stringToTerraform(struct!.healthcheckRegion),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_access_key: cdktf.stringToTerraform(struct!.secretAccessKey),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAwsToHclTerraform(struct?: ResourceAwsOutputReference | ResourceAws): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_region: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckRegion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.secretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAws | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckRegion !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckRegion = this._healthcheckRegion;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAws | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._healthcheckRegion = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretAccessKey = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._healthcheckRegion = value.healthcheckRegion;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretAccessKey = value.secretAccessKey;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_region - computed: false, optional: false, required: true
  private _healthcheckRegion?: string; 
  public get healthcheckRegion() {
    return this.getStringAttribute('healthcheck_region');
  }
  public set healthcheckRegion(value: string) {
    this._healthcheckRegion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckRegionInput() {
    return this._healthcheckRegion;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey?: string; 
  public get secretAccessKey() {
    return this.getStringAttribute('secret_access_key');
  }
  public set secretAccessKey(value: string) {
    this._secretAccessKey = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAwsConsole {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#enable_env_variables Resource#enable_env_variables}
  */
  readonly enableEnvVariables?: boolean | cdktf.IResolvable;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * The length of time in seconds AWS console sessions will live before needing to reauthenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#session_expiry Resource#session_expiry}
  */
  readonly sessionExpiry?: number;
  /**
  * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAwsConsoleToTerraform(struct?: ResourceAwsConsoleOutputReference | ResourceAwsConsole): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    enable_env_variables: cdktf.booleanToTerraform(struct!.enableEnvVariables),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    session_expiry: cdktf.numberToTerraform(struct!.sessionExpiry),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAwsConsoleToHclTerraform(struct?: ResourceAwsConsoleOutputReference | ResourceAwsConsole): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_env_variables: {
      value: cdktf.booleanToHclTerraform(struct!.enableEnvVariables),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_expiry: {
      value: cdktf.numberToHclTerraform(struct!.sessionExpiry),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAwsConsoleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAwsConsole | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._enableEnvVariables !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEnvVariables = this._enableEnvVariables;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._sessionExpiry !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionExpiry = this._sessionExpiry;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAwsConsole | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._enableEnvVariables = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretStoreId = undefined;
      this._sessionExpiry = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._enableEnvVariables = value.enableEnvVariables;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretStoreId = value.secretStoreId;
      this._sessionExpiry = value.sessionExpiry;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // enable_env_variables - computed: false, optional: true, required: false
  private _enableEnvVariables?: boolean | cdktf.IResolvable; 
  public get enableEnvVariables() {
    return this.getBooleanAttribute('enable_env_variables');
  }
  public set enableEnvVariables(value: boolean | cdktf.IResolvable) {
    this._enableEnvVariables = value;
  }
  public resetEnableEnvVariables() {
    this._enableEnvVariables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEnvVariablesInput() {
    return this._enableEnvVariables;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // session_expiry - computed: false, optional: true, required: false
  private _sessionExpiry?: number; 
  public get sessionExpiry() {
    return this.getNumberAttribute('session_expiry');
  }
  public set sessionExpiry(value: number) {
    this._sessionExpiry = value;
  }
  public resetSessionExpiry() {
    this._sessionExpiry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionExpiryInput() {
    return this._sessionExpiry;
  }

  // subdomain - computed: false, optional: false, required: true
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAwsConsoleStaticKeyPair {
  /**
  * The Access Key ID to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#access_key Resource#access_key}
  */
  readonly accessKey?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * The Secret Access Key to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_access_key Resource#secret_access_key}
  */
  readonly secretAccessKey?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * The length of time in seconds AWS console sessions will live before needing to reauthenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#session_expiry Resource#session_expiry}
  */
  readonly sessionExpiry?: number;
  /**
  * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAwsConsoleStaticKeyPairToTerraform(struct?: ResourceAwsConsoleStaticKeyPairOutputReference | ResourceAwsConsoleStaticKeyPair): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_access_key: cdktf.stringToTerraform(struct!.secretAccessKey),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    session_expiry: cdktf.numberToTerraform(struct!.sessionExpiry),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAwsConsoleStaticKeyPairToHclTerraform(struct?: ResourceAwsConsoleStaticKeyPairOutputReference | ResourceAwsConsoleStaticKeyPair): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.secretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_expiry: {
      value: cdktf.numberToHclTerraform(struct!.sessionExpiry),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAwsConsoleStaticKeyPairOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAwsConsoleStaticKeyPair | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._sessionExpiry !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionExpiry = this._sessionExpiry;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAwsConsoleStaticKeyPair | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretAccessKey = undefined;
      this._secretStoreId = undefined;
      this._sessionExpiry = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretAccessKey = value.secretAccessKey;
      this._secretStoreId = value.secretStoreId;
      this._sessionExpiry = value.sessionExpiry;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey?: string; 
  public get secretAccessKey() {
    return this.getStringAttribute('secret_access_key');
  }
  public set secretAccessKey(value: string) {
    this._secretAccessKey = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // session_expiry - computed: false, optional: true, required: false
  private _sessionExpiry?: number; 
  public get sessionExpiry() {
    return this.getNumberAttribute('session_expiry');
  }
  public set sessionExpiry(value: number) {
    this._sessionExpiry = value;
  }
  public resetSessionExpiry() {
    this._sessionExpiry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionExpiryInput() {
    return this._sessionExpiry;
  }

  // subdomain - computed: false, optional: false, required: true
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAwsInstanceProfile {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#enable_env_variables Resource#enable_env_variables}
  */
  readonly enableEnvVariables?: boolean | cdktf.IResolvable;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceAwsInstanceProfileToTerraform(struct?: ResourceAwsInstanceProfileOutputReference | ResourceAwsInstanceProfile): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    enable_env_variables: cdktf.booleanToTerraform(struct!.enableEnvVariables),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceAwsInstanceProfileToHclTerraform(struct?: ResourceAwsInstanceProfileOutputReference | ResourceAwsInstanceProfile): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_env_variables: {
      value: cdktf.booleanToHclTerraform(struct!.enableEnvVariables),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAwsInstanceProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAwsInstanceProfile | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._enableEnvVariables !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEnvVariables = this._enableEnvVariables;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAwsInstanceProfile | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._enableEnvVariables = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._enableEnvVariables = value.enableEnvVariables;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // enable_env_variables - computed: false, optional: true, required: false
  private _enableEnvVariables?: boolean | cdktf.IResolvable; 
  public get enableEnvVariables() {
    return this.getBooleanAttribute('enable_env_variables');
  }
  public set enableEnvVariables(value: boolean | cdktf.IResolvable) {
    this._enableEnvVariables = value;
  }
  public resetEnableEnvVariables() {
    this._enableEnvVariables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEnvVariablesInput() {
    return this._enableEnvVariables;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceAzure {
  /**
  * The application ID to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#app_id Resource#app_id}
  */
  readonly appId?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The tenant ID to authenticate to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tenant_id Resource#tenant_id}
  */
  readonly tenantId?: string;
}

export function resourceAzureToTerraform(struct?: ResourceAzureOutputReference | ResourceAzure): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_id: cdktf.stringToTerraform(struct!.appId),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
  }
}


export function resourceAzureToHclTerraform(struct?: ResourceAzureOutputReference | ResourceAzure): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_id: {
      value: cdktf.stringToHclTerraform(struct!.appId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAzureOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAzure | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appId !== undefined) {
      hasAnyValues = true;
      internalValueResult.appId = this._appId;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAzure | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._appId = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._name = undefined;
      this._password = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tenantId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._appId = value.appId;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._name = value.name;
      this._password = value.password;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tenantId = value.tenantId;
    }
  }

  // app_id - computed: false, optional: true, required: false
  private _appId?: string; 
  public get appId() {
    return this.getStringAttribute('app_id');
  }
  public set appId(value: string) {
    this._appId = value;
  }
  public resetAppId() {
    this._appId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appIdInput() {
    return this._appId;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }
}
export interface ResourceAzureCertificate {
  /**
  * The application ID to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#app_id Resource#app_id}
  */
  readonly appId?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The service Principal certificate file, both private and public key included.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_certificate Resource#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The tenant ID to authenticate to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tenant_id Resource#tenant_id}
  */
  readonly tenantId?: string;
}

export function resourceAzureCertificateToTerraform(struct?: ResourceAzureCertificateOutputReference | ResourceAzureCertificate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_id: cdktf.stringToTerraform(struct!.appId),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
  }
}


export function resourceAzureCertificateToHclTerraform(struct?: ResourceAzureCertificateOutputReference | ResourceAzureCertificate): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_id: {
      value: cdktf.stringToHclTerraform(struct!.appId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAzureCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAzureCertificate | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appId !== undefined) {
      hasAnyValues = true;
      internalValueResult.appId = this._appId;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAzureCertificate | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._appId = undefined;
      this._bindInterface = undefined;
      this._clientCertificate = undefined;
      this._egressFilter = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tenantId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._appId = value.appId;
      this._bindInterface = value.bindInterface;
      this._clientCertificate = value.clientCertificate;
      this._egressFilter = value.egressFilter;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tenantId = value.tenantId;
    }
  }

  // app_id - computed: false, optional: true, required: false
  private _appId?: string; 
  public get appId() {
    return this.getStringAttribute('app_id');
  }
  public set appId(value: string) {
    this._appId = value;
  }
  public resetAppId() {
    this._appId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appIdInput() {
    return this._appId;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }
}
export interface ResourceAzureMysql {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAzureMysqlToTerraform(struct?: ResourceAzureMysqlOutputReference | ResourceAzureMysql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAzureMysqlToHclTerraform(struct?: ResourceAzureMysqlOutputReference | ResourceAzureMysql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAzureMysqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAzureMysql | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAzureMysql | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAzureMysqlManagedIdentity {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAzureMysqlManagedIdentityToTerraform(struct?: ResourceAzureMysqlManagedIdentityOutputReference | ResourceAzureMysqlManagedIdentity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAzureMysqlManagedIdentityToHclTerraform(struct?: ResourceAzureMysqlManagedIdentityOutputReference | ResourceAzureMysqlManagedIdentity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAzureMysqlManagedIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAzureMysqlManagedIdentity | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAzureMysqlManagedIdentity | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAzurePostgres {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with. For Azure Postgres, this also will include the hostname of the target server for Azure Single Server compatibility. For Flexible servers, use the normal Postgres type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAzurePostgresToTerraform(struct?: ResourceAzurePostgresOutputReference | ResourceAzurePostgres): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAzurePostgresToHclTerraform(struct?: ResourceAzurePostgresOutputReference | ResourceAzurePostgres): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAzurePostgresOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAzurePostgres | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAzurePostgres | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceAzurePostgresManagedIdentity {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceAzurePostgresManagedIdentityToTerraform(struct?: ResourceAzurePostgresManagedIdentityOutputReference | ResourceAzurePostgresManagedIdentity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceAzurePostgresManagedIdentityToHclTerraform(struct?: ResourceAzurePostgresManagedIdentityOutputReference | ResourceAzurePostgresManagedIdentity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceAzurePostgresManagedIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceAzurePostgresManagedIdentity | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceAzurePostgresManagedIdentity | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceBigQuery {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * The JSON Private key to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#private_key Resource#private_key}
  */
  readonly privateKey?: string;
  /**
  * The project to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#project Resource#project}
  */
  readonly project: string;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceBigQueryToTerraform(struct?: ResourceBigQueryOutputReference | ResourceBigQuery): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    project: cdktf.stringToTerraform(struct!.project),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceBigQueryToHclTerraform(struct?: ResourceBigQueryOutputReference | ResourceBigQuery): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceBigQueryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceBigQuery | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceBigQuery | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._privateKey = undefined;
      this._project = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._privateKey = value.privateKey;
      this._project = value.project;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // project - computed: false, optional: false, required: true
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceCassandra {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceCassandraToTerraform(struct?: ResourceCassandraOutputReference | ResourceCassandra): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceCassandraToHclTerraform(struct?: ResourceCassandraOutputReference | ResourceCassandra): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceCassandraOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceCassandra | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceCassandra | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceCitus {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceCitusToTerraform(struct?: ResourceCitusOutputReference | ResourceCitus): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceCitusToHclTerraform(struct?: ResourceCitusOutputReference | ResourceCitus): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceCitusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceCitus | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceCitus | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceClickHouseHttp {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The URL to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#url Resource#url}
  */
  readonly url: string;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceClickHouseHttpToTerraform(struct?: ResourceClickHouseHttpOutputReference | ResourceClickHouseHttp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceClickHouseHttpToHclTerraform(struct?: ResourceClickHouseHttpOutputReference | ResourceClickHouseHttp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceClickHouseHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceClickHouseHttp | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceClickHouseHttp | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._name = undefined;
      this._password = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._tags = undefined;
      this._url = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._name = value.name;
      this._password = value.password;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._tags = value.tags;
      this._url = value.url;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceClickHouseMySql {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceClickHouseMySqlToTerraform(struct?: ResourceClickHouseMySqlOutputReference | ResourceClickHouseMySql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceClickHouseMySqlToHclTerraform(struct?: ResourceClickHouseMySqlOutputReference | ResourceClickHouseMySql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceClickHouseMySqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceClickHouseMySql | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceClickHouseMySql | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceClickHouseTcp {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceClickHouseTcpToTerraform(struct?: ResourceClickHouseTcpOutputReference | ResourceClickHouseTcp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceClickHouseTcpToHclTerraform(struct?: ResourceClickHouseTcpOutputReference | ResourceClickHouseTcp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceClickHouseTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceClickHouseTcp | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceClickHouseTcp | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceClustrix {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceClustrixToTerraform(struct?: ResourceClustrixOutputReference | ResourceClustrix): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceClustrixToHclTerraform(struct?: ResourceClustrixOutputReference | ResourceClustrix): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceClustrixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceClustrix | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceClustrix | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceCockroach {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceCockroachToTerraform(struct?: ResourceCockroachOutputReference | ResourceCockroach): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceCockroachToHclTerraform(struct?: ResourceCockroachOutputReference | ResourceCockroach): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceCockroachOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceCockroach | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceCockroach | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceCouchbaseDatabase {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The port number for N1QL queries. Default HTTP is 8093. Default HTTPS is 18093.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#n_1_ql_port Resource#n_1_ql_port}
  */
  readonly n1QlPort: number;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceCouchbaseDatabaseToTerraform(struct?: ResourceCouchbaseDatabaseOutputReference | ResourceCouchbaseDatabase): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    n_1_ql_port: cdktf.numberToTerraform(struct!.n1QlPort),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceCouchbaseDatabaseToHclTerraform(struct?: ResourceCouchbaseDatabaseOutputReference | ResourceCouchbaseDatabase): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    n_1_ql_port: {
      value: cdktf.numberToHclTerraform(struct!.n1QlPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceCouchbaseDatabaseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceCouchbaseDatabase | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._n1QlPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.n1QlPort = this._n1QlPort;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceCouchbaseDatabase | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._n1QlPort = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._n1QlPort = value.n1QlPort;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // n_1_ql_port - computed: false, optional: false, required: true
  private _n1QlPort?: number; 
  public get n1QlPort() {
    return this.getNumberAttribute('n_1_ql_port');
  }
  public set n1QlPort(value: number) {
    this._n1QlPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get n1QlPortInput() {
    return this._n1QlPort;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceCouchbaseWebUi {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The base address of your website without the path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#url Resource#url}
  */
  readonly url: string;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceCouchbaseWebUiToTerraform(struct?: ResourceCouchbaseWebUiOutputReference | ResourceCouchbaseWebUi): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceCouchbaseWebUiToHclTerraform(struct?: ResourceCouchbaseWebUiOutputReference | ResourceCouchbaseWebUi): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceCouchbaseWebUiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceCouchbaseWebUi | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceCouchbaseWebUi | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._name = undefined;
      this._password = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._url = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._name = value.name;
      this._password = value.password;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._url = value.url;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: false, optional: false, required: true
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceDb2I {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceDb2IToTerraform(struct?: ResourceDb2IOutputReference | ResourceDb2I): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceDb2IToHclTerraform(struct?: ResourceDb2IOutputReference | ResourceDb2I): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDb2IOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDb2I | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDb2I | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceDb2Luw {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceDb2LuwToTerraform(struct?: ResourceDb2LuwOutputReference | ResourceDb2Luw): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceDb2LuwToHclTerraform(struct?: ResourceDb2LuwOutputReference | ResourceDb2Luw): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDb2LuwOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDb2Luw | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDb2Luw | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceDocumentDbHost {
  /**
  * The authentication database to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#auth_database Resource#auth_database}
  */
  readonly authDatabase: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceDocumentDbHostToTerraform(struct?: ResourceDocumentDbHostOutputReference | ResourceDocumentDbHost): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_database: cdktf.stringToTerraform(struct!.authDatabase),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceDocumentDbHostToHclTerraform(struct?: ResourceDocumentDbHostOutputReference | ResourceDocumentDbHost): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_database: {
      value: cdktf.stringToHclTerraform(struct!.authDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDocumentDbHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDocumentDbHost | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.authDatabase = this._authDatabase;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDocumentDbHost | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authDatabase = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authDatabase = value.authDatabase;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // auth_database - computed: false, optional: false, required: true
  private _authDatabase?: string; 
  public get authDatabase() {
    return this.getStringAttribute('auth_database');
  }
  public set authDatabase(value: string) {
    this._authDatabase = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authDatabaseInput() {
    return this._authDatabase;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceDocumentDbHostIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceDocumentDbHostIamToTerraform(struct?: ResourceDocumentDbHostIamOutputReference | ResourceDocumentDbHostIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceDocumentDbHostIamToHclTerraform(struct?: ResourceDocumentDbHostIamOutputReference | ResourceDocumentDbHostIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDocumentDbHostIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDocumentDbHostIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDocumentDbHostIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceDocumentDbReplicaSet {
  /**
  * The authentication database to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#auth_database Resource#auth_database}
  */
  readonly authDatabase: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Set to connect to a replica instead of the primary node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#connect_to_replica Resource#connect_to_replica}
  */
  readonly connectToReplica?: boolean | cdktf.IResolvable;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The name of the mongo replicaset.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#replica_set Resource#replica_set}
  */
  readonly replicaSet: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceDocumentDbReplicaSetToTerraform(struct?: ResourceDocumentDbReplicaSetOutputReference | ResourceDocumentDbReplicaSet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_database: cdktf.stringToTerraform(struct!.authDatabase),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    connect_to_replica: cdktf.booleanToTerraform(struct!.connectToReplica),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    replica_set: cdktf.stringToTerraform(struct!.replicaSet),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceDocumentDbReplicaSetToHclTerraform(struct?: ResourceDocumentDbReplicaSetOutputReference | ResourceDocumentDbReplicaSet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_database: {
      value: cdktf.stringToHclTerraform(struct!.authDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_to_replica: {
      value: cdktf.booleanToHclTerraform(struct!.connectToReplica),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replica_set: {
      value: cdktf.stringToHclTerraform(struct!.replicaSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDocumentDbReplicaSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDocumentDbReplicaSet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.authDatabase = this._authDatabase;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._connectToReplica !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectToReplica = this._connectToReplica;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._replicaSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicaSet = this._replicaSet;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDocumentDbReplicaSet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authDatabase = undefined;
      this._bindInterface = undefined;
      this._connectToReplica = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._replicaSet = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authDatabase = value.authDatabase;
      this._bindInterface = value.bindInterface;
      this._connectToReplica = value.connectToReplica;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._replicaSet = value.replicaSet;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // auth_database - computed: false, optional: false, required: true
  private _authDatabase?: string; 
  public get authDatabase() {
    return this.getStringAttribute('auth_database');
  }
  public set authDatabase(value: string) {
    this._authDatabase = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authDatabaseInput() {
    return this._authDatabase;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // connect_to_replica - computed: false, optional: true, required: false
  private _connectToReplica?: boolean | cdktf.IResolvable; 
  public get connectToReplica() {
    return this.getBooleanAttribute('connect_to_replica');
  }
  public set connectToReplica(value: boolean | cdktf.IResolvable) {
    this._connectToReplica = value;
  }
  public resetConnectToReplica() {
    this._connectToReplica = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectToReplicaInput() {
    return this._connectToReplica;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // replica_set - computed: false, optional: false, required: true
  private _replicaSet?: string; 
  public get replicaSet() {
    return this.getStringAttribute('replica_set');
  }
  public set replicaSet(value: string) {
    this._replicaSet = value;
  }
  // Temporarily expose input value. Use with caution.
  public get replicaSetInput() {
    return this._replicaSet;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceDocumentDbReplicaSetIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Set to connect to a replica instead of the primary node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#connect_to_replica Resource#connect_to_replica}
  */
  readonly connectToReplica?: boolean | cdktf.IResolvable;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The region of the document db cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceDocumentDbReplicaSetIamToTerraform(struct?: ResourceDocumentDbReplicaSetIamOutputReference | ResourceDocumentDbReplicaSetIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    connect_to_replica: cdktf.booleanToTerraform(struct!.connectToReplica),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceDocumentDbReplicaSetIamToHclTerraform(struct?: ResourceDocumentDbReplicaSetIamOutputReference | ResourceDocumentDbReplicaSetIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_to_replica: {
      value: cdktf.booleanToHclTerraform(struct!.connectToReplica),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDocumentDbReplicaSetIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDocumentDbReplicaSetIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._connectToReplica !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectToReplica = this._connectToReplica;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDocumentDbReplicaSetIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._connectToReplica = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._connectToReplica = value.connectToReplica;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // connect_to_replica - computed: false, optional: true, required: false
  private _connectToReplica?: boolean | cdktf.IResolvable; 
  public get connectToReplica() {
    return this.getBooleanAttribute('connect_to_replica');
  }
  public set connectToReplica(value: boolean | cdktf.IResolvable) {
    this._connectToReplica = value;
  }
  public resetConnectToReplica() {
    this._connectToReplica = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectToReplicaInput() {
    return this._connectToReplica;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceDruid {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceDruidToTerraform(struct?: ResourceDruidOutputReference | ResourceDruid): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceDruidToHclTerraform(struct?: ResourceDruidOutputReference | ResourceDruid): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDruidOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDruid | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDruid | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceDynamoDb {
  /**
  * The Access Key ID to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#access_key Resource#access_key}
  */
  readonly accessKey?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial e.g. dynamodb.region.amazonaws.com
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The region to authenticate requests against e.g. us-east-1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * The Secret Access Key to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_access_key Resource#secret_access_key}
  */
  readonly secretAccessKey?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceDynamoDbToTerraform(struct?: ResourceDynamoDbOutputReference | ResourceDynamoDb): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_access_key: cdktf.stringToTerraform(struct!.secretAccessKey),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceDynamoDbToHclTerraform(struct?: ResourceDynamoDbOutputReference | ResourceDynamoDb): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.secretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDynamoDbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDynamoDb | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDynamoDb | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretAccessKey = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretAccessKey = value.secretAccessKey;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey?: string; 
  public get secretAccessKey() {
    return this.getStringAttribute('secret_access_key');
  }
  public set secretAccessKey(value: string) {
    this._secretAccessKey = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceDynamoDbiam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial e.g. dynamodb.region.amazonaws.com
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The region to authenticate requests against e.g. us-east-1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceDynamoDbiamToTerraform(struct?: ResourceDynamoDbiamOutputReference | ResourceDynamoDbiam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceDynamoDbiamToHclTerraform(struct?: ResourceDynamoDbiamOutputReference | ResourceDynamoDbiam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceDynamoDbiamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceDynamoDbiam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceDynamoDbiam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceElastic {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceElasticToTerraform(struct?: ResourceElasticOutputReference | ResourceElastic): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceElasticToHclTerraform(struct?: ResourceElasticOutputReference | ResourceElastic): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceElasticOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceElastic | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceElastic | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceElasticacheRedis {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceElasticacheRedisToTerraform(struct?: ResourceElasticacheRedisOutputReference | ResourceElasticacheRedis): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceElasticacheRedisToHclTerraform(struct?: ResourceElasticacheRedisOutputReference | ResourceElasticacheRedis): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceElasticacheRedisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceElasticacheRedis | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceElasticacheRedis | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceElasticacheRedisIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * AWS region is needed in addition to hostname to generate the IAM signature
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_assumption_arn Resource#role_assumption_arn}
  */
  readonly roleAssumptionArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceElasticacheRedisIamToTerraform(struct?: ResourceElasticacheRedisIamOutputReference | ResourceElasticacheRedisIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_assumption_arn: cdktf.stringToTerraform(struct!.roleAssumptionArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceElasticacheRedisIamToHclTerraform(struct?: ResourceElasticacheRedisIamOutputReference | ResourceElasticacheRedisIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_assumption_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleAssumptionArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceElasticacheRedisIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceElasticacheRedisIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleAssumptionArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleAssumptionArn = this._roleAssumptionArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceElasticacheRedisIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleAssumptionArn = undefined;
      this._roleExternalId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleAssumptionArn = value.roleAssumptionArn;
      this._roleExternalId = value.roleExternalId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_assumption_arn - computed: false, optional: true, required: false
  private _roleAssumptionArn?: string; 
  public get roleAssumptionArn() {
    return this.getStringAttribute('role_assumption_arn');
  }
  public set roleAssumptionArn(value: string) {
    this._roleAssumptionArn = value;
  }
  public resetRoleAssumptionArn() {
    this._roleAssumptionArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleAssumptionArnInput() {
    return this._roleAssumptionArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceEntraId {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * If true, configures discovery of the tenant to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * comma separated list of group names to filter by. Supports wildcards (*)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#group_names Resource#group_names}
  */
  readonly groupNames?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId: string;
  /**
  * The management group ID to authenticate scope Privileges to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#management_group_id Resource#management_group_id}
  */
  readonly managementGroupId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The privilege levels specify which Groups are managed externally
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#privilege_levels Resource#privilege_levels}
  */
  readonly privilegeLevels?: string;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * filters discovered groups to the specified Resource Group
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#resource_group_id Resource#resource_group_id}
  */
  readonly resourceGroupId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * The subscription ID to authenticate scope Privileges to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subscription_id Resource#subscription_id}
  */
  readonly subscriptionId?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The connector ID to authenticate through.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tenant_id Resource#tenant_id}
  */
  readonly tenantId: string;
}

export function resourceEntraIdToTerraform(struct?: ResourceEntraIdOutputReference | ResourceEntraId): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    group_names: cdktf.stringToTerraform(struct!.groupNames),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    management_group_id: cdktf.stringToTerraform(struct!.managementGroupId),
    name: cdktf.stringToTerraform(struct!.name),
    privilege_levels: cdktf.stringToTerraform(struct!.privilegeLevels),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    resource_group_id: cdktf.stringToTerraform(struct!.resourceGroupId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    subscription_id: cdktf.stringToTerraform(struct!.subscriptionId),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
  }
}


export function resourceEntraIdToHclTerraform(struct?: ResourceEntraIdOutputReference | ResourceEntraId): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_names: {
      value: cdktf.stringToHclTerraform(struct!.groupNames),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    management_group_id: {
      value: cdktf.stringToHclTerraform(struct!.managementGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    privilege_levels: {
      value: cdktf.stringToHclTerraform(struct!.privilegeLevels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_group_id: {
      value: cdktf.stringToHclTerraform(struct!.resourceGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subscription_id: {
      value: cdktf.stringToHclTerraform(struct!.subscriptionId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceEntraIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceEntraId | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._groupNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupNames = this._groupNames;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._managementGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.managementGroupId = this._managementGroupId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._privilegeLevels !== undefined) {
      hasAnyValues = true;
      internalValueResult.privilegeLevels = this._privilegeLevels;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._resourceGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceGroupId = this._resourceGroupId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._subscriptionId !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptionId = this._subscriptionId;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceEntraId | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._discoveryEnabled = undefined;
      this._egressFilter = undefined;
      this._groupNames = undefined;
      this._identitySetId = undefined;
      this._managementGroupId = undefined;
      this._name = undefined;
      this._privilegeLevels = undefined;
      this._proxyClusterId = undefined;
      this._resourceGroupId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._subscriptionId = undefined;
      this._tags = undefined;
      this._tenantId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._discoveryEnabled = value.discoveryEnabled;
      this._egressFilter = value.egressFilter;
      this._groupNames = value.groupNames;
      this._identitySetId = value.identitySetId;
      this._managementGroupId = value.managementGroupId;
      this._name = value.name;
      this._privilegeLevels = value.privilegeLevels;
      this._proxyClusterId = value.proxyClusterId;
      this._resourceGroupId = value.resourceGroupId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._subscriptionId = value.subscriptionId;
      this._tags = value.tags;
      this._tenantId = value.tenantId;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // group_names - computed: false, optional: true, required: false
  private _groupNames?: string; 
  public get groupNames() {
    return this.getStringAttribute('group_names');
  }
  public set groupNames(value: string) {
    this._groupNames = value;
  }
  public resetGroupNames() {
    this._groupNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupNamesInput() {
    return this._groupNames;
  }

  // identity_set_id - computed: false, optional: false, required: true
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // management_group_id - computed: false, optional: true, required: false
  private _managementGroupId?: string; 
  public get managementGroupId() {
    return this.getStringAttribute('management_group_id');
  }
  public set managementGroupId(value: string) {
    this._managementGroupId = value;
  }
  public resetManagementGroupId() {
    this._managementGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get managementGroupIdInput() {
    return this._managementGroupId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // privilege_levels - computed: false, optional: true, required: false
  private _privilegeLevels?: string; 
  public get privilegeLevels() {
    return this.getStringAttribute('privilege_levels');
  }
  public set privilegeLevels(value: string) {
    this._privilegeLevels = value;
  }
  public resetPrivilegeLevels() {
    this._privilegeLevels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privilegeLevelsInput() {
    return this._privilegeLevels;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // resource_group_id - computed: false, optional: true, required: false
  private _resourceGroupId?: string; 
  public get resourceGroupId() {
    return this.getStringAttribute('resource_group_id');
  }
  public set resourceGroupId(value: string) {
    this._resourceGroupId = value;
  }
  public resetResourceGroupId() {
    this._resourceGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceGroupIdInput() {
    return this._resourceGroupId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // subscription_id - computed: false, optional: true, required: false
  private _subscriptionId?: string; 
  public get subscriptionId() {
    return this.getStringAttribute('subscription_id');
  }
  public set subscriptionId(value: string) {
    this._subscriptionId = value;
  }
  public resetSubscriptionId() {
    this._subscriptionId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionIdInput() {
    return this._subscriptionId;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tenant_id - computed: false, optional: false, required: true
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }
}
export interface ResourceGcp {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The service account keyfile to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#keyfile Resource#keyfile}
  */
  readonly keyfile?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Space separated scopes that this login should assume into when authenticating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#scopes Resource#scopes}
  */
  readonly scopes: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceGcpToTerraform(struct?: ResourceGcpOutputReference | ResourceGcp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    keyfile: cdktf.stringToTerraform(struct!.keyfile),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    scopes: cdktf.stringToTerraform(struct!.scopes),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceGcpToHclTerraform(struct?: ResourceGcpOutputReference | ResourceGcp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keyfile: {
      value: cdktf.stringToHclTerraform(struct!.keyfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scopes: {
      value: cdktf.stringToHclTerraform(struct!.scopes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceGcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceGcp | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._keyfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyfile = this._keyfile;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceGcp | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._keyfile = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._scopes = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._keyfile = value.keyfile;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._scopes = value.scopes;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // keyfile - computed: false, optional: true, required: false
  private _keyfile?: string; 
  public get keyfile() {
    return this.getStringAttribute('keyfile');
  }
  public set keyfile(value: string) {
    this._keyfile = value;
  }
  public resetKeyfile() {
    this._keyfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyfileInput() {
    return this._keyfile;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // scopes - computed: false, optional: false, required: true
  private _scopes?: string; 
  public get scopes() {
    return this.getStringAttribute('scopes');
  }
  public set scopes(value: string) {
    this._scopes = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceGcpConsole {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * The length of time in seconds console sessions will live before needing to reauthenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#session_expiry Resource#session_expiry}
  */
  readonly sessionExpiry?: number;
  /**
  * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The ID of the Workforce Identity Pool in GCP to use for federated authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#workforce_pool_id Resource#workforce_pool_id}
  */
  readonly workforcePoolId: string;
  /**
  * The ID of the Workforce Identity Provider in GCP to use for federated authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#workforce_provider_id Resource#workforce_provider_id}
  */
  readonly workforceProviderId: string;
}

export function resourceGcpConsoleToTerraform(struct?: ResourceGcpConsoleOutputReference | ResourceGcpConsole): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    session_expiry: cdktf.numberToTerraform(struct!.sessionExpiry),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    workforce_pool_id: cdktf.stringToTerraform(struct!.workforcePoolId),
    workforce_provider_id: cdktf.stringToTerraform(struct!.workforceProviderId),
  }
}


export function resourceGcpConsoleToHclTerraform(struct?: ResourceGcpConsoleOutputReference | ResourceGcpConsole): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_expiry: {
      value: cdktf.numberToHclTerraform(struct!.sessionExpiry),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    workforce_pool_id: {
      value: cdktf.stringToHclTerraform(struct!.workforcePoolId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workforce_provider_id: {
      value: cdktf.stringToHclTerraform(struct!.workforceProviderId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceGcpConsoleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceGcpConsole | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._sessionExpiry !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionExpiry = this._sessionExpiry;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._workforcePoolId !== undefined) {
      hasAnyValues = true;
      internalValueResult.workforcePoolId = this._workforcePoolId;
    }
    if (this._workforceProviderId !== undefined) {
      hasAnyValues = true;
      internalValueResult.workforceProviderId = this._workforceProviderId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceGcpConsole | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._sessionExpiry = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._workforcePoolId = undefined;
      this._workforceProviderId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._sessionExpiry = value.sessionExpiry;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._workforcePoolId = value.workforcePoolId;
      this._workforceProviderId = value.workforceProviderId;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // session_expiry - computed: false, optional: true, required: false
  private _sessionExpiry?: number; 
  public get sessionExpiry() {
    return this.getNumberAttribute('session_expiry');
  }
  public set sessionExpiry(value: number) {
    this._sessionExpiry = value;
  }
  public resetSessionExpiry() {
    this._sessionExpiry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionExpiryInput() {
    return this._sessionExpiry;
  }

  // subdomain - computed: false, optional: false, required: true
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // workforce_pool_id - computed: false, optional: false, required: true
  private _workforcePoolId?: string; 
  public get workforcePoolId() {
    return this.getStringAttribute('workforce_pool_id');
  }
  public set workforcePoolId(value: string) {
    this._workforcePoolId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get workforcePoolIdInput() {
    return this._workforcePoolId;
  }

  // workforce_provider_id - computed: false, optional: false, required: true
  private _workforceProviderId?: string; 
  public get workforceProviderId() {
    return this.getStringAttribute('workforce_provider_id');
  }
  public set workforceProviderId(value: string) {
    this._workforceProviderId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get workforceProviderIdInput() {
    return this._workforceProviderId;
  }
}
export interface ResourceGcpwif {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * When specified, all project scoped requests will use this Project ID, overriding the project ID specified by clients
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#project_id Resource#project_id}
  */
  readonly projectId?: string;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Space separated scopes that this login should assume into when authenticating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#scopes Resource#scopes}
  */
  readonly scopes: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * The length of time in seconds console sessions will live before needing to reauthenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#session_expiry Resource#session_expiry}
  */
  readonly sessionExpiry?: number;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The ID of the Workforce Identity Pool in GCP to use for federated authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#workforce_pool_id Resource#workforce_pool_id}
  */
  readonly workforcePoolId: string;
  /**
  * The ID of the Workforce Identity Provider in GCP to use for federated authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#workforce_provider_id Resource#workforce_provider_id}
  */
  readonly workforceProviderId: string;
}

export function resourceGcpwifToTerraform(struct?: ResourceGcpwifOutputReference | ResourceGcpwif): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    project_id: cdktf.stringToTerraform(struct!.projectId),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    scopes: cdktf.stringToTerraform(struct!.scopes),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    session_expiry: cdktf.numberToTerraform(struct!.sessionExpiry),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    workforce_pool_id: cdktf.stringToTerraform(struct!.workforcePoolId),
    workforce_provider_id: cdktf.stringToTerraform(struct!.workforceProviderId),
  }
}


export function resourceGcpwifToHclTerraform(struct?: ResourceGcpwifOutputReference | ResourceGcpwif): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scopes: {
      value: cdktf.stringToHclTerraform(struct!.scopes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_expiry: {
      value: cdktf.numberToHclTerraform(struct!.sessionExpiry),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    workforce_pool_id: {
      value: cdktf.stringToHclTerraform(struct!.workforcePoolId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workforce_provider_id: {
      value: cdktf.stringToHclTerraform(struct!.workforceProviderId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceGcpwifOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceGcpwif | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._sessionExpiry !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionExpiry = this._sessionExpiry;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._workforcePoolId !== undefined) {
      hasAnyValues = true;
      internalValueResult.workforcePoolId = this._workforcePoolId;
    }
    if (this._workforceProviderId !== undefined) {
      hasAnyValues = true;
      internalValueResult.workforceProviderId = this._workforceProviderId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceGcpwif | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._projectId = undefined;
      this._proxyClusterId = undefined;
      this._scopes = undefined;
      this._secretStoreId = undefined;
      this._sessionExpiry = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._workforcePoolId = undefined;
      this._workforceProviderId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._projectId = value.projectId;
      this._proxyClusterId = value.proxyClusterId;
      this._scopes = value.scopes;
      this._secretStoreId = value.secretStoreId;
      this._sessionExpiry = value.sessionExpiry;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._workforcePoolId = value.workforcePoolId;
      this._workforceProviderId = value.workforceProviderId;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // project_id - computed: false, optional: true, required: false
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  public resetProjectId() {
    this._projectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // scopes - computed: false, optional: false, required: true
  private _scopes?: string; 
  public get scopes() {
    return this.getStringAttribute('scopes');
  }
  public set scopes(value: string) {
    this._scopes = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // session_expiry - computed: false, optional: true, required: false
  private _sessionExpiry?: number; 
  public get sessionExpiry() {
    return this.getNumberAttribute('session_expiry');
  }
  public set sessionExpiry(value: number) {
    this._sessionExpiry = value;
  }
  public resetSessionExpiry() {
    this._sessionExpiry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionExpiryInput() {
    return this._sessionExpiry;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // workforce_pool_id - computed: false, optional: false, required: true
  private _workforcePoolId?: string; 
  public get workforcePoolId() {
    return this.getStringAttribute('workforce_pool_id');
  }
  public set workforcePoolId(value: string) {
    this._workforcePoolId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get workforcePoolIdInput() {
    return this._workforcePoolId;
  }

  // workforce_provider_id - computed: false, optional: false, required: true
  private _workforceProviderId?: string; 
  public get workforceProviderId() {
    return this.getStringAttribute('workforce_provider_id');
  }
  public set workforceProviderId(value: string) {
    this._workforceProviderId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get workforceProviderIdInput() {
    return this._workforceProviderId;
  }
}
export interface ResourceGoogleGke {
  /**
  * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_resource_role_bypass Resource#allow_resource_role_bypass}
  */
  readonly allowResourceRoleBypass?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * If true, configures discovery of a cluster to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_username Resource#discovery_username}
  */
  readonly discoveryUsername?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * The service account key to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#service_account_key Resource#service_account_key}
  */
  readonly serviceAccountKey?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceGoogleGkeToTerraform(struct?: ResourceGoogleGkeOutputReference | ResourceGoogleGke): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_resource_role_bypass: cdktf.booleanToTerraform(struct!.allowResourceRoleBypass),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    discovery_username: cdktf.stringToTerraform(struct!.discoveryUsername),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    service_account_key: cdktf.stringToTerraform(struct!.serviceAccountKey),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceGoogleGkeToHclTerraform(struct?: ResourceGoogleGkeOutputReference | ResourceGoogleGke): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_resource_role_bypass: {
      value: cdktf.booleanToHclTerraform(struct!.allowResourceRoleBypass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_username: {
      value: cdktf.stringToHclTerraform(struct!.discoveryUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_key: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceGoogleGkeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceGoogleGke | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowResourceRoleBypass !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowResourceRoleBypass = this._allowResourceRoleBypass;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._discoveryUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryUsername = this._discoveryUsername;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._serviceAccountKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountKey = this._serviceAccountKey;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceGoogleGke | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowResourceRoleBypass = undefined;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._discoveryEnabled = undefined;
      this._discoveryUsername = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._healthcheckNamespace = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._serviceAccountKey = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowResourceRoleBypass = value.allowResourceRoleBypass;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._discoveryEnabled = value.discoveryEnabled;
      this._discoveryUsername = value.discoveryUsername;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._serviceAccountKey = value.serviceAccountKey;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // allow_resource_role_bypass - computed: false, optional: true, required: false
  private _allowResourceRoleBypass?: boolean | cdktf.IResolvable; 
  public get allowResourceRoleBypass() {
    return this.getBooleanAttribute('allow_resource_role_bypass');
  }
  public set allowResourceRoleBypass(value: boolean | cdktf.IResolvable) {
    this._allowResourceRoleBypass = value;
  }
  public resetAllowResourceRoleBypass() {
    this._allowResourceRoleBypass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowResourceRoleBypassInput() {
    return this._allowResourceRoleBypass;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // discovery_username - computed: false, optional: true, required: false
  private _discoveryUsername?: string; 
  public get discoveryUsername() {
    return this.getStringAttribute('discovery_username');
  }
  public set discoveryUsername(value: string) {
    this._discoveryUsername = value;
  }
  public resetDiscoveryUsername() {
    this._discoveryUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryUsernameInput() {
    return this._discoveryUsername;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // service_account_key - computed: false, optional: true, required: false
  private _serviceAccountKey?: string; 
  public get serviceAccountKey() {
    return this.getStringAttribute('service_account_key');
  }
  public set serviceAccountKey(value: string) {
    this._serviceAccountKey = value;
  }
  public resetServiceAccountKey() {
    this._serviceAccountKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountKeyInput() {
    return this._serviceAccountKey;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceGoogleGkeUserImpersonation {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The endpoint to dial.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * The service account key to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#service_account_key Resource#service_account_key}
  */
  readonly serviceAccountKey?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceGoogleGkeUserImpersonationToTerraform(struct?: ResourceGoogleGkeUserImpersonationOutputReference | ResourceGoogleGkeUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    service_account_key: cdktf.stringToTerraform(struct!.serviceAccountKey),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceGoogleGkeUserImpersonationToHclTerraform(struct?: ResourceGoogleGkeUserImpersonationOutputReference | ResourceGoogleGkeUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_key: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceGoogleGkeUserImpersonationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceGoogleGkeUserImpersonation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._serviceAccountKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountKey = this._serviceAccountKey;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceGoogleGkeUserImpersonation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._healthcheckNamespace = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._serviceAccountKey = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._serviceAccountKey = value.serviceAccountKey;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // service_account_key - computed: false, optional: true, required: false
  private _serviceAccountKey?: string; 
  public get serviceAccountKey() {
    return this.getStringAttribute('service_account_key');
  }
  public set serviceAccountKey(value: string) {
    this._serviceAccountKey = value;
  }
  public resetServiceAccountKey() {
    this._serviceAccountKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountKeyInput() {
    return this._serviceAccountKey;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceGreenplum {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceGreenplumToTerraform(struct?: ResourceGreenplumOutputReference | ResourceGreenplum): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceGreenplumToHclTerraform(struct?: ResourceGreenplumOutputReference | ResourceGreenplum): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceGreenplumOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceGreenplum | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceGreenplum | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceHttpAuth {
  /**
  * The content to set as the authorization header.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#auth_header Resource#auth_header}
  */
  readonly authHeader?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Automatically redirect to this path upon connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#default_path Resource#default_path}
  */
  readonly defaultPath?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Header names (e.g. Authorization), to omit from logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#headers_blacklist Resource#headers_blacklist}
  */
  readonly headersBlacklist?: string;
  /**
  * This path will be used to check the health of your site.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_path Resource#healthcheck_path}
  */
  readonly healthcheckPath: string;
  /**
  * The host header will be overwritten with this field if provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#host_override Resource#host_override}
  */
  readonly hostOverride?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The base address of your website without the path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#url Resource#url}
  */
  readonly url: string;
}

export function resourceHttpAuthToTerraform(struct?: ResourceHttpAuthOutputReference | ResourceHttpAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header: cdktf.stringToTerraform(struct!.authHeader),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    default_path: cdktf.stringToTerraform(struct!.defaultPath),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    headers_blacklist: cdktf.stringToTerraform(struct!.headersBlacklist),
    healthcheck_path: cdktf.stringToTerraform(struct!.healthcheckPath),
    host_override: cdktf.stringToTerraform(struct!.hostOverride),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function resourceHttpAuthToHclTerraform(struct?: ResourceHttpAuthOutputReference | ResourceHttpAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header: {
      value: cdktf.stringToHclTerraform(struct!.authHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_path: {
      value: cdktf.stringToHclTerraform(struct!.defaultPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers_blacklist: {
      value: cdktf.stringToHclTerraform(struct!.headersBlacklist),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_path: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_override: {
      value: cdktf.stringToHclTerraform(struct!.hostOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceHttpAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceHttpAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeader = this._authHeader;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._defaultPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultPath = this._defaultPath;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._headersBlacklist !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersBlacklist = this._headersBlacklist;
    }
    if (this._healthcheckPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckPath = this._healthcheckPath;
    }
    if (this._hostOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostOverride = this._hostOverride;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceHttpAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authHeader = undefined;
      this._bindInterface = undefined;
      this._defaultPath = undefined;
      this._egressFilter = undefined;
      this._headersBlacklist = undefined;
      this._healthcheckPath = undefined;
      this._hostOverride = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._url = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authHeader = value.authHeader;
      this._bindInterface = value.bindInterface;
      this._defaultPath = value.defaultPath;
      this._egressFilter = value.egressFilter;
      this._headersBlacklist = value.headersBlacklist;
      this._healthcheckPath = value.healthcheckPath;
      this._hostOverride = value.hostOverride;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._url = value.url;
    }
  }

  // auth_header - computed: false, optional: true, required: false
  private _authHeader?: string; 
  public get authHeader() {
    return this.getStringAttribute('auth_header');
  }
  public set authHeader(value: string) {
    this._authHeader = value;
  }
  public resetAuthHeader() {
    this._authHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderInput() {
    return this._authHeader;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // default_path - computed: false, optional: true, required: false
  private _defaultPath?: string; 
  public get defaultPath() {
    return this.getStringAttribute('default_path');
  }
  public set defaultPath(value: string) {
    this._defaultPath = value;
  }
  public resetDefaultPath() {
    this._defaultPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultPathInput() {
    return this._defaultPath;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // headers_blacklist - computed: false, optional: true, required: false
  private _headersBlacklist?: string; 
  public get headersBlacklist() {
    return this.getStringAttribute('headers_blacklist');
  }
  public set headersBlacklist(value: string) {
    this._headersBlacklist = value;
  }
  public resetHeadersBlacklist() {
    this._headersBlacklist = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersBlacklistInput() {
    return this._headersBlacklist;
  }

  // healthcheck_path - computed: false, optional: false, required: true
  private _healthcheckPath?: string; 
  public get healthcheckPath() {
    return this.getStringAttribute('healthcheck_path');
  }
  public set healthcheckPath(value: string) {
    this._healthcheckPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckPathInput() {
    return this._healthcheckPath;
  }

  // host_override - computed: false, optional: true, required: false
  private _hostOverride?: string; 
  public get hostOverride() {
    return this.getStringAttribute('host_override');
  }
  public set hostOverride(value: string) {
    this._hostOverride = value;
  }
  public resetHostOverride() {
    this._hostOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostOverrideInput() {
    return this._hostOverride;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: false, optional: false, required: true
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface ResourceHttpBasicAuth {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Automatically redirect to this path upon connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#default_path Resource#default_path}
  */
  readonly defaultPath?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Header names (e.g. Authorization), to omit from logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#headers_blacklist Resource#headers_blacklist}
  */
  readonly headersBlacklist?: string;
  /**
  * This path will be used to check the health of your site.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_path Resource#healthcheck_path}
  */
  readonly healthcheckPath: string;
  /**
  * The host header will be overwritten with this field if provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#host_override Resource#host_override}
  */
  readonly hostOverride?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The base address of your website without the path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#url Resource#url}
  */
  readonly url: string;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceHttpBasicAuthToTerraform(struct?: ResourceHttpBasicAuthOutputReference | ResourceHttpBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    default_path: cdktf.stringToTerraform(struct!.defaultPath),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    headers_blacklist: cdktf.stringToTerraform(struct!.headersBlacklist),
    healthcheck_path: cdktf.stringToTerraform(struct!.healthcheckPath),
    host_override: cdktf.stringToTerraform(struct!.hostOverride),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    url: cdktf.stringToTerraform(struct!.url),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceHttpBasicAuthToHclTerraform(struct?: ResourceHttpBasicAuthOutputReference | ResourceHttpBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_path: {
      value: cdktf.stringToHclTerraform(struct!.defaultPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers_blacklist: {
      value: cdktf.stringToHclTerraform(struct!.headersBlacklist),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_path: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_override: {
      value: cdktf.stringToHclTerraform(struct!.hostOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceHttpBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceHttpBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._defaultPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultPath = this._defaultPath;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._headersBlacklist !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersBlacklist = this._headersBlacklist;
    }
    if (this._healthcheckPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckPath = this._healthcheckPath;
    }
    if (this._hostOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostOverride = this._hostOverride;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceHttpBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._defaultPath = undefined;
      this._egressFilter = undefined;
      this._headersBlacklist = undefined;
      this._healthcheckPath = undefined;
      this._hostOverride = undefined;
      this._name = undefined;
      this._password = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._url = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._defaultPath = value.defaultPath;
      this._egressFilter = value.egressFilter;
      this._headersBlacklist = value.headersBlacklist;
      this._healthcheckPath = value.healthcheckPath;
      this._hostOverride = value.hostOverride;
      this._name = value.name;
      this._password = value.password;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._url = value.url;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // default_path - computed: false, optional: true, required: false
  private _defaultPath?: string; 
  public get defaultPath() {
    return this.getStringAttribute('default_path');
  }
  public set defaultPath(value: string) {
    this._defaultPath = value;
  }
  public resetDefaultPath() {
    this._defaultPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultPathInput() {
    return this._defaultPath;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // headers_blacklist - computed: false, optional: true, required: false
  private _headersBlacklist?: string; 
  public get headersBlacklist() {
    return this.getStringAttribute('headers_blacklist');
  }
  public set headersBlacklist(value: string) {
    this._headersBlacklist = value;
  }
  public resetHeadersBlacklist() {
    this._headersBlacklist = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersBlacklistInput() {
    return this._headersBlacklist;
  }

  // healthcheck_path - computed: false, optional: false, required: true
  private _healthcheckPath?: string; 
  public get healthcheckPath() {
    return this.getStringAttribute('healthcheck_path');
  }
  public set healthcheckPath(value: string) {
    this._healthcheckPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckPathInput() {
    return this._healthcheckPath;
  }

  // host_override - computed: false, optional: true, required: false
  private _hostOverride?: string; 
  public get hostOverride() {
    return this.getStringAttribute('host_override');
  }
  public set hostOverride(value: string) {
    this._hostOverride = value;
  }
  public resetHostOverride() {
    this._hostOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostOverrideInput() {
    return this._hostOverride;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: false, optional: false, required: true
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceHttpNoAuth {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Automatically redirect to this path upon connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#default_path Resource#default_path}
  */
  readonly defaultPath?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Header names (e.g. Authorization), to omit from logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#headers_blacklist Resource#headers_blacklist}
  */
  readonly headersBlacklist?: string;
  /**
  * This path will be used to check the health of your site.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_path Resource#healthcheck_path}
  */
  readonly healthcheckPath: string;
  /**
  * The host header will be overwritten with this field if provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#host_override Resource#host_override}
  */
  readonly hostOverride?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The base address of your website without the path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#url Resource#url}
  */
  readonly url: string;
}

export function resourceHttpNoAuthToTerraform(struct?: ResourceHttpNoAuthOutputReference | ResourceHttpNoAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    default_path: cdktf.stringToTerraform(struct!.defaultPath),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    headers_blacklist: cdktf.stringToTerraform(struct!.headersBlacklist),
    healthcheck_path: cdktf.stringToTerraform(struct!.healthcheckPath),
    host_override: cdktf.stringToTerraform(struct!.hostOverride),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function resourceHttpNoAuthToHclTerraform(struct?: ResourceHttpNoAuthOutputReference | ResourceHttpNoAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_path: {
      value: cdktf.stringToHclTerraform(struct!.defaultPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers_blacklist: {
      value: cdktf.stringToHclTerraform(struct!.headersBlacklist),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_path: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_override: {
      value: cdktf.stringToHclTerraform(struct!.hostOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceHttpNoAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceHttpNoAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._defaultPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultPath = this._defaultPath;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._headersBlacklist !== undefined) {
      hasAnyValues = true;
      internalValueResult.headersBlacklist = this._headersBlacklist;
    }
    if (this._healthcheckPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckPath = this._healthcheckPath;
    }
    if (this._hostOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostOverride = this._hostOverride;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceHttpNoAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._defaultPath = undefined;
      this._egressFilter = undefined;
      this._headersBlacklist = undefined;
      this._healthcheckPath = undefined;
      this._hostOverride = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._url = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._defaultPath = value.defaultPath;
      this._egressFilter = value.egressFilter;
      this._headersBlacklist = value.headersBlacklist;
      this._healthcheckPath = value.healthcheckPath;
      this._hostOverride = value.hostOverride;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._url = value.url;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // default_path - computed: false, optional: true, required: false
  private _defaultPath?: string; 
  public get defaultPath() {
    return this.getStringAttribute('default_path');
  }
  public set defaultPath(value: string) {
    this._defaultPath = value;
  }
  public resetDefaultPath() {
    this._defaultPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultPathInput() {
    return this._defaultPath;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // headers_blacklist - computed: false, optional: true, required: false
  private _headersBlacklist?: string; 
  public get headersBlacklist() {
    return this.getStringAttribute('headers_blacklist');
  }
  public set headersBlacklist(value: string) {
    this._headersBlacklist = value;
  }
  public resetHeadersBlacklist() {
    this._headersBlacklist = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersBlacklistInput() {
    return this._headersBlacklist;
  }

  // healthcheck_path - computed: false, optional: false, required: true
  private _healthcheckPath?: string; 
  public get healthcheckPath() {
    return this.getStringAttribute('healthcheck_path');
  }
  public set healthcheckPath(value: string) {
    this._healthcheckPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckPathInput() {
    return this._healthcheckPath;
  }

  // host_override - computed: false, optional: true, required: false
  private _hostOverride?: string; 
  public get hostOverride() {
    return this.getStringAttribute('host_override');
  }
  public set hostOverride(value: string) {
    this._hostOverride = value;
  }
  public resetHostOverride() {
    this._hostOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostOverrideInput() {
    return this._hostOverride;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: false, optional: false, required: true
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface ResourceKubernetes {
  /**
  * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_resource_role_bypass Resource#allow_resource_role_bypass}
  */
  readonly allowResourceRoleBypass?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The certificate to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_certificate Resource#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * The key to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_key Resource#client_key}
  */
  readonly clientKey?: string;
  /**
  * If true, configures discovery of a cluster to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_username Resource#discovery_username}
  */
  readonly discoveryUsername?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceKubernetesToTerraform(struct?: ResourceKubernetesOutputReference | ResourceKubernetes): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_resource_role_bypass: cdktf.booleanToTerraform(struct!.allowResourceRoleBypass),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    client_key: cdktf.stringToTerraform(struct!.clientKey),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    discovery_username: cdktf.stringToTerraform(struct!.discoveryUsername),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceKubernetesToHclTerraform(struct?: ResourceKubernetesOutputReference | ResourceKubernetes): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_resource_role_bypass: {
      value: cdktf.booleanToHclTerraform(struct!.allowResourceRoleBypass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_key: {
      value: cdktf.stringToHclTerraform(struct!.clientKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_username: {
      value: cdktf.stringToHclTerraform(struct!.discoveryUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceKubernetes | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowResourceRoleBypass !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowResourceRoleBypass = this._allowResourceRoleBypass;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._clientKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientKey = this._clientKey;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._discoveryUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryUsername = this._discoveryUsername;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceKubernetes | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowResourceRoleBypass = undefined;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clientCertificate = undefined;
      this._clientKey = undefined;
      this._discoveryEnabled = undefined;
      this._discoveryUsername = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowResourceRoleBypass = value.allowResourceRoleBypass;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clientCertificate = value.clientCertificate;
      this._clientKey = value.clientKey;
      this._discoveryEnabled = value.discoveryEnabled;
      this._discoveryUsername = value.discoveryUsername;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // allow_resource_role_bypass - computed: false, optional: true, required: false
  private _allowResourceRoleBypass?: boolean | cdktf.IResolvable; 
  public get allowResourceRoleBypass() {
    return this.getBooleanAttribute('allow_resource_role_bypass');
  }
  public set allowResourceRoleBypass(value: boolean | cdktf.IResolvable) {
    this._allowResourceRoleBypass = value;
  }
  public resetAllowResourceRoleBypass() {
    this._allowResourceRoleBypass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowResourceRoleBypassInput() {
    return this._allowResourceRoleBypass;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // client_key - computed: false, optional: true, required: false
  private _clientKey?: string; 
  public get clientKey() {
    return this.getStringAttribute('client_key');
  }
  public set clientKey(value: string) {
    this._clientKey = value;
  }
  public resetClientKey() {
    this._clientKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientKeyInput() {
    return this._clientKey;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // discovery_username - computed: false, optional: true, required: false
  private _discoveryUsername?: string; 
  public get discoveryUsername() {
    return this.getStringAttribute('discovery_username');
  }
  public set discoveryUsername(value: string) {
    this._discoveryUsername = value;
  }
  public resetDiscoveryUsername() {
    this._discoveryUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryUsernameInput() {
    return this._discoveryUsername;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceKubernetesBasicAuth {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceKubernetesBasicAuthToTerraform(struct?: ResourceKubernetesBasicAuthOutputReference | ResourceKubernetesBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceKubernetesBasicAuthToHclTerraform(struct?: ResourceKubernetesBasicAuthOutputReference | ResourceKubernetesBasicAuth): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceKubernetesBasicAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceKubernetesBasicAuth | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceKubernetesBasicAuth | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceKubernetesPodIdentity {
  /**
  * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_resource_role_bypass Resource#allow_resource_role_bypass}
  */
  readonly allowResourceRoleBypass?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * If true, configures discovery of a cluster to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_username Resource#discovery_username}
  */
  readonly discoveryUsername?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceKubernetesPodIdentityToTerraform(struct?: ResourceKubernetesPodIdentityOutputReference | ResourceKubernetesPodIdentity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_resource_role_bypass: cdktf.booleanToTerraform(struct!.allowResourceRoleBypass),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    discovery_username: cdktf.stringToTerraform(struct!.discoveryUsername),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceKubernetesPodIdentityToHclTerraform(struct?: ResourceKubernetesPodIdentityOutputReference | ResourceKubernetesPodIdentity): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_resource_role_bypass: {
      value: cdktf.booleanToHclTerraform(struct!.allowResourceRoleBypass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_username: {
      value: cdktf.stringToHclTerraform(struct!.discoveryUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceKubernetesPodIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceKubernetesPodIdentity | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowResourceRoleBypass !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowResourceRoleBypass = this._allowResourceRoleBypass;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._discoveryUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryUsername = this._discoveryUsername;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceKubernetesPodIdentity | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowResourceRoleBypass = undefined;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._discoveryEnabled = undefined;
      this._discoveryUsername = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowResourceRoleBypass = value.allowResourceRoleBypass;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._discoveryEnabled = value.discoveryEnabled;
      this._discoveryUsername = value.discoveryUsername;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // allow_resource_role_bypass - computed: false, optional: true, required: false
  private _allowResourceRoleBypass?: boolean | cdktf.IResolvable; 
  public get allowResourceRoleBypass() {
    return this.getBooleanAttribute('allow_resource_role_bypass');
  }
  public set allowResourceRoleBypass(value: boolean | cdktf.IResolvable) {
    this._allowResourceRoleBypass = value;
  }
  public resetAllowResourceRoleBypass() {
    this._allowResourceRoleBypass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowResourceRoleBypassInput() {
    return this._allowResourceRoleBypass;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // discovery_username - computed: false, optional: true, required: false
  private _discoveryUsername?: string; 
  public get discoveryUsername() {
    return this.getStringAttribute('discovery_username');
  }
  public set discoveryUsername(value: string) {
    this._discoveryUsername = value;
  }
  public resetDiscoveryUsername() {
    this._discoveryUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryUsernameInput() {
    return this._discoveryUsername;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceKubernetesServiceAccount {
  /**
  * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_resource_role_bypass Resource#allow_resource_role_bypass}
  */
  readonly allowResourceRoleBypass?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * If true, configures discovery of a cluster to be run from a node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_enabled Resource#discovery_enabled}
  */
  readonly discoveryEnabled?: boolean | cdktf.IResolvable;
  /**
  * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#discovery_username Resource#discovery_username}
  */
  readonly discoveryUsername?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The API token to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#token Resource#token}
  */
  readonly token?: string;
}

export function resourceKubernetesServiceAccountToTerraform(struct?: ResourceKubernetesServiceAccountOutputReference | ResourceKubernetesServiceAccount): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_resource_role_bypass: cdktf.booleanToTerraform(struct!.allowResourceRoleBypass),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    discovery_enabled: cdktf.booleanToTerraform(struct!.discoveryEnabled),
    discovery_username: cdktf.stringToTerraform(struct!.discoveryUsername),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    token: cdktf.stringToTerraform(struct!.token),
  }
}


export function resourceKubernetesServiceAccountToHclTerraform(struct?: ResourceKubernetesServiceAccountOutputReference | ResourceKubernetesServiceAccount): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_resource_role_bypass: {
      value: cdktf.booleanToHclTerraform(struct!.allowResourceRoleBypass),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    discovery_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.discoveryEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    discovery_username: {
      value: cdktf.stringToHclTerraform(struct!.discoveryUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceKubernetesServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceKubernetesServiceAccount | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowResourceRoleBypass !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowResourceRoleBypass = this._allowResourceRoleBypass;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._discoveryEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryEnabled = this._discoveryEnabled;
    }
    if (this._discoveryUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.discoveryUsername = this._discoveryUsername;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceKubernetesServiceAccount | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowResourceRoleBypass = undefined;
      this._bindInterface = undefined;
      this._discoveryEnabled = undefined;
      this._discoveryUsername = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._token = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowResourceRoleBypass = value.allowResourceRoleBypass;
      this._bindInterface = value.bindInterface;
      this._discoveryEnabled = value.discoveryEnabled;
      this._discoveryUsername = value.discoveryUsername;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._token = value.token;
    }
  }

  // allow_resource_role_bypass - computed: false, optional: true, required: false
  private _allowResourceRoleBypass?: boolean | cdktf.IResolvable; 
  public get allowResourceRoleBypass() {
    return this.getBooleanAttribute('allow_resource_role_bypass');
  }
  public set allowResourceRoleBypass(value: boolean | cdktf.IResolvable) {
    this._allowResourceRoleBypass = value;
  }
  public resetAllowResourceRoleBypass() {
    this._allowResourceRoleBypass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowResourceRoleBypassInput() {
    return this._allowResourceRoleBypass;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // discovery_enabled - computed: false, optional: true, required: false
  private _discoveryEnabled?: boolean | cdktf.IResolvable; 
  public get discoveryEnabled() {
    return this.getBooleanAttribute('discovery_enabled');
  }
  public set discoveryEnabled(value: boolean | cdktf.IResolvable) {
    this._discoveryEnabled = value;
  }
  public resetDiscoveryEnabled() {
    this._discoveryEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryEnabledInput() {
    return this._discoveryEnabled;
  }

  // discovery_username - computed: false, optional: true, required: false
  private _discoveryUsername?: string; 
  public get discoveryUsername() {
    return this.getStringAttribute('discovery_username');
  }
  public set discoveryUsername(value: string) {
    this._discoveryUsername = value;
  }
  public resetDiscoveryUsername() {
    this._discoveryUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get discoveryUsernameInput() {
    return this._discoveryUsername;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }
}
export interface ResourceKubernetesServiceAccountUserImpersonation {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The API token to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#token Resource#token}
  */
  readonly token?: string;
}

export function resourceKubernetesServiceAccountUserImpersonationToTerraform(struct?: ResourceKubernetesServiceAccountUserImpersonationOutputReference | ResourceKubernetesServiceAccountUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    token: cdktf.stringToTerraform(struct!.token),
  }
}


export function resourceKubernetesServiceAccountUserImpersonationToHclTerraform(struct?: ResourceKubernetesServiceAccountUserImpersonationOutputReference | ResourceKubernetesServiceAccountUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceKubernetesServiceAccountUserImpersonationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceKubernetesServiceAccountUserImpersonation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceKubernetesServiceAccountUserImpersonation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._token = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._token = value.token;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }
}
export interface ResourceKubernetesUserImpersonation {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The certificate to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_certificate Resource#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * The key to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_key Resource#client_key}
  */
  readonly clientKey?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_namespace Resource#healthcheck_namespace}
  */
  readonly healthcheckNamespace?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceKubernetesUserImpersonationToTerraform(struct?: ResourceKubernetesUserImpersonationOutputReference | ResourceKubernetesUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    client_key: cdktf.stringToTerraform(struct!.clientKey),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_namespace: cdktf.stringToTerraform(struct!.healthcheckNamespace),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceKubernetesUserImpersonationToHclTerraform(struct?: ResourceKubernetesUserImpersonationOutputReference | ResourceKubernetesUserImpersonation): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_key: {
      value: cdktf.stringToHclTerraform(struct!.clientKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_namespace: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceKubernetesUserImpersonationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceKubernetesUserImpersonation | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._clientKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientKey = this._clientKey;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckNamespace = this._healthcheckNamespace;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceKubernetesUserImpersonation | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clientCertificate = undefined;
      this._clientKey = undefined;
      this._egressFilter = undefined;
      this._healthcheckNamespace = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clientCertificate = value.clientCertificate;
      this._clientKey = value.clientKey;
      this._egressFilter = value.egressFilter;
      this._healthcheckNamespace = value.healthcheckNamespace;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // client_key - computed: false, optional: true, required: false
  private _clientKey?: string; 
  public get clientKey() {
    return this.getStringAttribute('client_key');
  }
  public set clientKey(value: string) {
    this._clientKey = value;
  }
  public resetClientKey() {
    this._clientKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientKeyInput() {
    return this._clientKey;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_namespace - computed: true, optional: true, required: false
  private _healthcheckNamespace?: string; 
  public get healthcheckNamespace() {
    return this.getStringAttribute('healthcheck_namespace');
  }
  public set healthcheckNamespace(value: string) {
    this._healthcheckNamespace = value;
  }
  public resetHealthcheckNamespace() {
    this._healthcheckNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckNamespaceInput() {
    return this._healthcheckNamespace;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceMaria {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMariaToTerraform(struct?: ResourceMariaOutputReference | ResourceMaria): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMariaToHclTerraform(struct?: ResourceMariaOutputReference | ResourceMaria): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMariaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMaria | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMaria | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMcp {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceMcpToTerraform(struct?: ResourceMcpOutputReference | ResourceMcp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceMcpToHclTerraform(struct?: ResourceMcpOutputReference | ResourceMcp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMcp | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMcp | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceMemcached {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceMemcachedToTerraform(struct?: ResourceMemcachedOutputReference | ResourceMemcached): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceMemcachedToHclTerraform(struct?: ResourceMemcachedOutputReference | ResourceMemcached): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMemcachedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMemcached | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMemcached | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceMemsql {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMemsqlToTerraform(struct?: ResourceMemsqlOutputReference | ResourceMemsql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMemsqlToHclTerraform(struct?: ResourceMemsqlOutputReference | ResourceMemsql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMemsqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMemsql | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMemsql | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMongoHost {
  /**
  * The authentication database to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#auth_database Resource#auth_database}
  */
  readonly authDatabase: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMongoHostToTerraform(struct?: ResourceMongoHostOutputReference | ResourceMongoHost): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_database: cdktf.stringToTerraform(struct!.authDatabase),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMongoHostToHclTerraform(struct?: ResourceMongoHostOutputReference | ResourceMongoHost): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_database: {
      value: cdktf.stringToHclTerraform(struct!.authDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMongoHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMongoHost | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.authDatabase = this._authDatabase;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMongoHost | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authDatabase = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authDatabase = value.authDatabase;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // auth_database - computed: false, optional: false, required: true
  private _authDatabase?: string; 
  public get authDatabase() {
    return this.getStringAttribute('auth_database');
  }
  public set authDatabase(value: string) {
    this._authDatabase = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authDatabaseInput() {
    return this._authDatabase;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMongoLegacyHost {
  /**
  * The authentication database to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#auth_database Resource#auth_database}
  */
  readonly authDatabase: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMongoLegacyHostToTerraform(struct?: ResourceMongoLegacyHostOutputReference | ResourceMongoLegacyHost): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_database: cdktf.stringToTerraform(struct!.authDatabase),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMongoLegacyHostToHclTerraform(struct?: ResourceMongoLegacyHostOutputReference | ResourceMongoLegacyHost): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_database: {
      value: cdktf.stringToHclTerraform(struct!.authDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMongoLegacyHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMongoLegacyHost | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.authDatabase = this._authDatabase;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMongoLegacyHost | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authDatabase = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authDatabase = value.authDatabase;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // auth_database - computed: false, optional: false, required: true
  private _authDatabase?: string; 
  public get authDatabase() {
    return this.getStringAttribute('auth_database');
  }
  public set authDatabase(value: string) {
    this._authDatabase = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authDatabaseInput() {
    return this._authDatabase;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMongoLegacyReplicaset {
  /**
  * The authentication database to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#auth_database Resource#auth_database}
  */
  readonly authDatabase: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Set to connect to a replica instead of the primary node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#connect_to_replica Resource#connect_to_replica}
  */
  readonly connectToReplica?: boolean | cdktf.IResolvable;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The name of the mongo replicaset.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#replica_set Resource#replica_set}
  */
  readonly replicaSet: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMongoLegacyReplicasetToTerraform(struct?: ResourceMongoLegacyReplicasetOutputReference | ResourceMongoLegacyReplicaset): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_database: cdktf.stringToTerraform(struct!.authDatabase),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    connect_to_replica: cdktf.booleanToTerraform(struct!.connectToReplica),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    replica_set: cdktf.stringToTerraform(struct!.replicaSet),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMongoLegacyReplicasetToHclTerraform(struct?: ResourceMongoLegacyReplicasetOutputReference | ResourceMongoLegacyReplicaset): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_database: {
      value: cdktf.stringToHclTerraform(struct!.authDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_to_replica: {
      value: cdktf.booleanToHclTerraform(struct!.connectToReplica),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replica_set: {
      value: cdktf.stringToHclTerraform(struct!.replicaSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMongoLegacyReplicasetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMongoLegacyReplicaset | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.authDatabase = this._authDatabase;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._connectToReplica !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectToReplica = this._connectToReplica;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._replicaSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicaSet = this._replicaSet;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMongoLegacyReplicaset | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authDatabase = undefined;
      this._bindInterface = undefined;
      this._connectToReplica = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._replicaSet = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authDatabase = value.authDatabase;
      this._bindInterface = value.bindInterface;
      this._connectToReplica = value.connectToReplica;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._replicaSet = value.replicaSet;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // auth_database - computed: false, optional: false, required: true
  private _authDatabase?: string; 
  public get authDatabase() {
    return this.getStringAttribute('auth_database');
  }
  public set authDatabase(value: string) {
    this._authDatabase = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authDatabaseInput() {
    return this._authDatabase;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // connect_to_replica - computed: false, optional: true, required: false
  private _connectToReplica?: boolean | cdktf.IResolvable; 
  public get connectToReplica() {
    return this.getBooleanAttribute('connect_to_replica');
  }
  public set connectToReplica(value: boolean | cdktf.IResolvable) {
    this._connectToReplica = value;
  }
  public resetConnectToReplica() {
    this._connectToReplica = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectToReplicaInput() {
    return this._connectToReplica;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // replica_set - computed: false, optional: false, required: true
  private _replicaSet?: string; 
  public get replicaSet() {
    return this.getStringAttribute('replica_set');
  }
  public set replicaSet(value: string) {
    this._replicaSet = value;
  }
  // Temporarily expose input value. Use with caution.
  public get replicaSetInput() {
    return this._replicaSet;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMongoReplicaSet {
  /**
  * The authentication database to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#auth_database Resource#auth_database}
  */
  readonly authDatabase: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Set to connect to a replica instead of the primary node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#connect_to_replica Resource#connect_to_replica}
  */
  readonly connectToReplica?: boolean | cdktf.IResolvable;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The name of the mongo replicaset.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#replica_set Resource#replica_set}
  */
  readonly replicaSet: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMongoReplicaSetToTerraform(struct?: ResourceMongoReplicaSetOutputReference | ResourceMongoReplicaSet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_database: cdktf.stringToTerraform(struct!.authDatabase),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    connect_to_replica: cdktf.booleanToTerraform(struct!.connectToReplica),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    replica_set: cdktf.stringToTerraform(struct!.replicaSet),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMongoReplicaSetToHclTerraform(struct?: ResourceMongoReplicaSetOutputReference | ResourceMongoReplicaSet): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_database: {
      value: cdktf.stringToHclTerraform(struct!.authDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_to_replica: {
      value: cdktf.booleanToHclTerraform(struct!.connectToReplica),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replica_set: {
      value: cdktf.stringToHclTerraform(struct!.replicaSet),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMongoReplicaSetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMongoReplicaSet | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.authDatabase = this._authDatabase;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._connectToReplica !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectToReplica = this._connectToReplica;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._replicaSet !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicaSet = this._replicaSet;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMongoReplicaSet | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authDatabase = undefined;
      this._bindInterface = undefined;
      this._connectToReplica = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._replicaSet = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authDatabase = value.authDatabase;
      this._bindInterface = value.bindInterface;
      this._connectToReplica = value.connectToReplica;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._replicaSet = value.replicaSet;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // auth_database - computed: false, optional: false, required: true
  private _authDatabase?: string; 
  public get authDatabase() {
    return this.getStringAttribute('auth_database');
  }
  public set authDatabase(value: string) {
    this._authDatabase = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authDatabaseInput() {
    return this._authDatabase;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // connect_to_replica - computed: false, optional: true, required: false
  private _connectToReplica?: boolean | cdktf.IResolvable; 
  public get connectToReplica() {
    return this.getBooleanAttribute('connect_to_replica');
  }
  public set connectToReplica(value: boolean | cdktf.IResolvable) {
    this._connectToReplica = value;
  }
  public resetConnectToReplica() {
    this._connectToReplica = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectToReplicaInput() {
    return this._connectToReplica;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // replica_set - computed: false, optional: false, required: true
  private _replicaSet?: string; 
  public get replicaSet() {
    return this.getStringAttribute('replica_set');
  }
  public set replicaSet(value: string) {
    this._replicaSet = value;
  }
  // Temporarily expose input value. Use with caution.
  public get replicaSetInput() {
    return this._replicaSet;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMongoShardedCluster {
  /**
  * The authentication database to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#auth_database Resource#auth_database}
  */
  readonly authDatabase: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMongoShardedClusterToTerraform(struct?: ResourceMongoShardedClusterOutputReference | ResourceMongoShardedCluster): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_database: cdktf.stringToTerraform(struct!.authDatabase),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMongoShardedClusterToHclTerraform(struct?: ResourceMongoShardedClusterOutputReference | ResourceMongoShardedCluster): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_database: {
      value: cdktf.stringToHclTerraform(struct!.authDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMongoShardedClusterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMongoShardedCluster | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.authDatabase = this._authDatabase;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMongoShardedCluster | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._authDatabase = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._authDatabase = value.authDatabase;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // auth_database - computed: false, optional: false, required: true
  private _authDatabase?: string; 
  public get authDatabase() {
    return this.getStringAttribute('auth_database');
  }
  public set authDatabase(value: string) {
    this._authDatabase = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authDatabaseInput() {
    return this._authDatabase;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMtlsMysql {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The certificate to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_certificate Resource#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * The key to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_key Resource#client_key}
  */
  readonly clientKey?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Server name for TLS verification (unverified by StrongDM if empty)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#server_name Resource#server_name}
  */
  readonly serverName?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMtlsMysqlToTerraform(struct?: ResourceMtlsMysqlOutputReference | ResourceMtlsMysql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    client_key: cdktf.stringToTerraform(struct!.clientKey),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    server_name: cdktf.stringToTerraform(struct!.serverName),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMtlsMysqlToHclTerraform(struct?: ResourceMtlsMysqlOutputReference | ResourceMtlsMysql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_key: {
      value: cdktf.stringToHclTerraform(struct!.clientKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMtlsMysqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMtlsMysql | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._clientKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientKey = this._clientKey;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMtlsMysql | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clientCertificate = undefined;
      this._clientKey = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._serverName = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clientCertificate = value.clientCertificate;
      this._clientKey = value.clientKey;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._serverName = value.serverName;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // client_key - computed: false, optional: true, required: false
  private _clientKey?: string; 
  public get clientKey() {
    return this.getStringAttribute('client_key');
  }
  public set clientKey(value: string) {
    this._clientKey = value;
  }
  public resetClientKey() {
    this._clientKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientKeyInput() {
    return this._clientKey;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMtlsPostgres {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The CA to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#certificate_authority Resource#certificate_authority}
  */
  readonly certificateAuthority?: string;
  /**
  * The certificate to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_certificate Resource#client_certificate}
  */
  readonly clientCertificate?: string;
  /**
  * The key to authenticate TLS connections with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_key Resource#client_key}
  */
  readonly clientKey?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Server name for TLS verification (unverified by StrongDM if empty)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#server_name Resource#server_name}
  */
  readonly serverName?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMtlsPostgresToTerraform(struct?: ResourceMtlsPostgresOutputReference | ResourceMtlsPostgres): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    certificate_authority: cdktf.stringToTerraform(struct!.certificateAuthority),
    client_certificate: cdktf.stringToTerraform(struct!.clientCertificate),
    client_key: cdktf.stringToTerraform(struct!.clientKey),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    server_name: cdktf.stringToTerraform(struct!.serverName),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMtlsPostgresToHclTerraform(struct?: ResourceMtlsPostgresOutputReference | ResourceMtlsPostgres): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_authority: {
      value: cdktf.stringToHclTerraform(struct!.certificateAuthority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_certificate: {
      value: cdktf.stringToHclTerraform(struct!.clientCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_key: {
      value: cdktf.stringToHclTerraform(struct!.clientKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_name: {
      value: cdktf.stringToHclTerraform(struct!.serverName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMtlsPostgresOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMtlsPostgres | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._certificateAuthority !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateAuthority = this._certificateAuthority;
    }
    if (this._clientCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate;
    }
    if (this._clientKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientKey = this._clientKey;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._serverName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverName = this._serverName;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMtlsPostgres | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._certificateAuthority = undefined;
      this._clientCertificate = undefined;
      this._clientKey = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._serverName = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._certificateAuthority = value.certificateAuthority;
      this._clientCertificate = value.clientCertificate;
      this._clientKey = value.clientKey;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._serverName = value.serverName;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // certificate_authority - computed: false, optional: true, required: false
  private _certificateAuthority?: string; 
  public get certificateAuthority() {
    return this.getStringAttribute('certificate_authority');
  }
  public set certificateAuthority(value: string) {
    this._certificateAuthority = value;
  }
  public resetCertificateAuthority() {
    this._certificateAuthority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateAuthorityInput() {
    return this._certificateAuthority;
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate?: string; 
  public get clientCertificate() {
    return this.getStringAttribute('client_certificate');
  }
  public set clientCertificate(value: string) {
    this._clientCertificate = value;
  }
  public resetClientCertificate() {
    this._clientCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate;
  }

  // client_key - computed: false, optional: true, required: false
  private _clientKey?: string; 
  public get clientKey() {
    return this.getStringAttribute('client_key');
  }
  public set clientKey(value: string) {
    this._clientKey = value;
  }
  public resetClientKey() {
    this._clientKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientKeyInput() {
    return this._clientKey;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // server_name - computed: false, optional: true, required: false
  private _serverName?: string; 
  public get serverName() {
    return this.getStringAttribute('server_name');
  }
  public set serverName(value: string) {
    this._serverName = value;
  }
  public resetServerName() {
    this._serverName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverNameInput() {
    return this._serverName;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceMysql {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceMysqlToTerraform(struct?: ResourceMysqlOutputReference | ResourceMysql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceMysqlToHclTerraform(struct?: ResourceMysqlOutputReference | ResourceMysql): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceMysqlOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceMysql | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceMysql | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceNeptune {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceNeptuneToTerraform(struct?: ResourceNeptuneOutputReference | ResourceNeptune): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceNeptuneToHclTerraform(struct?: ResourceNeptuneOutputReference | ResourceNeptune): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceNeptuneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceNeptune | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceNeptune | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceNeptuneIam {
  /**
  * The Access Key ID to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#access_key Resource#access_key}
  */
  readonly accessKey?: string;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#endpoint Resource#endpoint}
  */
  readonly endpoint: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * The role to assume after logging in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_arn Resource#role_arn}
  */
  readonly roleArn?: string;
  /**
  * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_external_id Resource#role_external_id}
  */
  readonly roleExternalId?: string;
  /**
  * The Secret Access Key to use to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_access_key Resource#secret_access_key}
  */
  readonly secretAccessKey?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceNeptuneIamToTerraform(struct?: ResourceNeptuneIamOutputReference | ResourceNeptuneIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: cdktf.stringToTerraform(struct!.accessKey),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    role_external_id: cdktf.stringToTerraform(struct!.roleExternalId),
    secret_access_key: cdktf.stringToTerraform(struct!.secretAccessKey),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceNeptuneIamToHclTerraform(struct?: ResourceNeptuneIamOutputReference | ResourceNeptuneIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: cdktf.stringToHclTerraform(struct!.accessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.roleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_access_key: {
      value: cdktf.stringToHclTerraform(struct!.secretAccessKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceNeptuneIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceNeptuneIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._roleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleExternalId = this._roleExternalId;
    }
    if (this._secretAccessKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKey = this._secretAccessKey;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceNeptuneIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._accessKey = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._endpoint = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleArn = undefined;
      this._roleExternalId = undefined;
      this._secretAccessKey = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._accessKey = value.accessKey;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._endpoint = value.endpoint;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleArn = value.roleArn;
      this._roleExternalId = value.roleExternalId;
      this._secretAccessKey = value.secretAccessKey;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // access_key - computed: false, optional: true, required: false
  private _accessKey?: string; 
  public get accessKey() {
    return this.getStringAttribute('access_key');
  }
  public set accessKey(value: string) {
    this._accessKey = value;
  }
  public resetAccessKey() {
    this._accessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_arn - computed: false, optional: true, required: false
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  public resetRoleArn() {
    this._roleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // role_external_id - computed: false, optional: true, required: false
  private _roleExternalId?: string; 
  public get roleExternalId() {
    return this.getStringAttribute('role_external_id');
  }
  public set roleExternalId(value: string) {
    this._roleExternalId = value;
  }
  public resetRoleExternalId() {
    this._roleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleExternalIdInput() {
    return this._roleExternalId;
  }

  // secret_access_key - computed: false, optional: true, required: false
  private _secretAccessKey?: string; 
  public get secretAccessKey() {
    return this.getStringAttribute('secret_access_key');
  }
  public set secretAccessKey(value: string) {
    this._secretAccessKey = value;
  }
  public resetSecretAccessKey() {
    this._secretAccessKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeyInput() {
    return this._secretAccessKey;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceOracle {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Oracle service name to connect to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceOracleToTerraform(struct?: ResourceOracleOutputReference | ResourceOracle): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceOracleToHclTerraform(struct?: ResourceOracleOutputReference | ResourceOracle): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceOracleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceOracle | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceOracle | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceOracleNne {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Oracle service name to connect to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceOracleNneToTerraform(struct?: ResourceOracleNneOutputReference | ResourceOracleNne): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceOracleNneToHclTerraform(struct?: ResourceOracleNneOutputReference | ResourceOracleNne): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceOracleNneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceOracleNne | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceOracleNne | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourcePostgres {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourcePostgresToTerraform(struct?: ResourcePostgresOutputReference | ResourcePostgres): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourcePostgresToHclTerraform(struct?: ResourcePostgresOutputReference | ResourcePostgres): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourcePostgresOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourcePostgres | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourcePostgres | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourcePresto {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourcePrestoToTerraform(struct?: ResourcePrestoOutputReference | ResourcePresto): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourcePrestoToHclTerraform(struct?: ResourcePrestoOutputReference | ResourcePresto): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourcePrestoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourcePresto | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourcePresto | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceRabbitmqAmqp091 {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceRabbitmqAmqp091ToTerraform(struct?: ResourceRabbitmqAmqp091OutputReference | ResourceRabbitmqAmqp091): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceRabbitmqAmqp091ToHclTerraform(struct?: ResourceRabbitmqAmqp091OutputReference | ResourceRabbitmqAmqp091): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRabbitmqAmqp091OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRabbitmqAmqp091 | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRabbitmqAmqp091 | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceRawTcp {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceRawTcpToTerraform(struct?: ResourceRawTcpOutputReference | ResourceRawTcp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceRawTcpToHclTerraform(struct?: ResourceRawTcpOutputReference | ResourceRawTcp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRawTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRawTcp | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRawTcp | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceRdp {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#downgrade_nla_connections Resource#downgrade_nla_connections}
  */
  readonly downgradeNlaConnections?: boolean | cdktf.IResolvable;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#lock_required Resource#lock_required}
  */
  readonly lockRequired?: boolean | cdktf.IResolvable;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceRdpToTerraform(struct?: ResourceRdpOutputReference | ResourceRdp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    downgrade_nla_connections: cdktf.booleanToTerraform(struct!.downgradeNlaConnections),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    lock_required: cdktf.booleanToTerraform(struct!.lockRequired),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceRdpToHclTerraform(struct?: ResourceRdpOutputReference | ResourceRdp): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    downgrade_nla_connections: {
      value: cdktf.booleanToHclTerraform(struct!.downgradeNlaConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lock_required: {
      value: cdktf.booleanToHclTerraform(struct!.lockRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRdpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRdp | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._downgradeNlaConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.downgradeNlaConnections = this._downgradeNlaConnections;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._lockRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.lockRequired = this._lockRequired;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRdp | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._downgradeNlaConnections = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._lockRequired = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._downgradeNlaConnections = value.downgradeNlaConnections;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._lockRequired = value.lockRequired;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // downgrade_nla_connections - computed: false, optional: true, required: false
  private _downgradeNlaConnections?: boolean | cdktf.IResolvable; 
  public get downgradeNlaConnections() {
    return this.getBooleanAttribute('downgrade_nla_connections');
  }
  public set downgradeNlaConnections(value: boolean | cdktf.IResolvable) {
    this._downgradeNlaConnections = value;
  }
  public resetDowngradeNlaConnections() {
    this._downgradeNlaConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get downgradeNlaConnectionsInput() {
    return this._downgradeNlaConnections;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // lock_required - computed: false, optional: true, required: false
  private _lockRequired?: boolean | cdktf.IResolvable; 
  public get lockRequired() {
    return this.getBooleanAttribute('lock_required');
  }
  public set lockRequired(value: boolean | cdktf.IResolvable) {
    this._lockRequired = value;
  }
  public resetLockRequired() {
    this._lockRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lockRequiredInput() {
    return this._lockRequired;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceRdpCert {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Comma-separated list of Active Directory Domain Controller hostnames for LDAPS SID resolution. Utilized for strong certificate mapping in full enforcement mode when the identity alias does not specify a SID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#dc_hostnames Resource#dc_hostnames}
  */
  readonly dcHostnames?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#lock_required Resource#lock_required}
  */
  readonly lockRequired?: boolean | cdktf.IResolvable;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Windows Security Identifier (SID) of the configured Username, required for strong certificate mapping in full enforcement mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#sid Resource#sid}
  */
  readonly sid?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceRdpCertToTerraform(struct?: ResourceRdpCertOutputReference | ResourceRdpCert): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    dc_hostnames: cdktf.stringToTerraform(struct!.dcHostnames),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    lock_required: cdktf.booleanToTerraform(struct!.lockRequired),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    sid: cdktf.stringToTerraform(struct!.sid),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceRdpCertToHclTerraform(struct?: ResourceRdpCertOutputReference | ResourceRdpCert): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dc_hostnames: {
      value: cdktf.stringToHclTerraform(struct!.dcHostnames),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lock_required: {
      value: cdktf.booleanToHclTerraform(struct!.lockRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sid: {
      value: cdktf.stringToHclTerraform(struct!.sid),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRdpCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRdpCert | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._dcHostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.dcHostnames = this._dcHostnames;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._lockRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.lockRequired = this._lockRequired;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._sid !== undefined) {
      hasAnyValues = true;
      internalValueResult.sid = this._sid;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRdpCert | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._dcHostnames = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._lockRequired = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._sid = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._dcHostnames = value.dcHostnames;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._lockRequired = value.lockRequired;
      this._name = value.name;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._sid = value.sid;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // dc_hostnames - computed: false, optional: true, required: false
  private _dcHostnames?: string; 
  public get dcHostnames() {
    return this.getStringAttribute('dc_hostnames');
  }
  public set dcHostnames(value: string) {
    this._dcHostnames = value;
  }
  public resetDcHostnames() {
    this._dcHostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dcHostnamesInput() {
    return this._dcHostnames;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // lock_required - computed: false, optional: true, required: false
  private _lockRequired?: boolean | cdktf.IResolvable; 
  public get lockRequired() {
    return this.getBooleanAttribute('lock_required');
  }
  public set lockRequired(value: boolean | cdktf.IResolvable) {
    this._lockRequired = value;
  }
  public resetLockRequired() {
    this._lockRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lockRequiredInput() {
    return this._lockRequired;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // sid - computed: false, optional: true, required: false
  private _sid?: string; 
  public get sid() {
    return this.getStringAttribute('sid');
  }
  public set sid(value: string) {
    this._sid = value;
  }
  public resetSid() {
    this._sid = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sidInput() {
    return this._sid;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceRdsPostgresIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_assumption_arn Resource#role_assumption_arn}
  */
  readonly roleAssumptionArn?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceRdsPostgresIamToTerraform(struct?: ResourceRdsPostgresIamOutputReference | ResourceRdsPostgresIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_assumption_arn: cdktf.stringToTerraform(struct!.roleAssumptionArn),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceRdsPostgresIamToHclTerraform(struct?: ResourceRdsPostgresIamOutputReference | ResourceRdsPostgresIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_assumption_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleAssumptionArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRdsPostgresIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRdsPostgresIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleAssumptionArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleAssumptionArn = this._roleAssumptionArn;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRdsPostgresIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleAssumptionArn = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleAssumptionArn = value.roleAssumptionArn;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_assumption_arn - computed: false, optional: true, required: false
  private _roleAssumptionArn?: string; 
  public get roleAssumptionArn() {
    return this.getStringAttribute('role_assumption_arn');
  }
  public set roleAssumptionArn(value: string) {
    this._roleAssumptionArn = value;
  }
  public resetRoleAssumptionArn() {
    this._roleAssumptionArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleAssumptionArnInput() {
    return this._roleAssumptionArn;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceRedis {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceRedisToTerraform(struct?: ResourceRedisOutputReference | ResourceRedis): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceRedisToHclTerraform(struct?: ResourceRedisOutputReference | ResourceRedis): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRedisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRedis | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRedis | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceRedisCluster {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceRedisClusterToTerraform(struct?: ResourceRedisClusterOutputReference | ResourceRedisCluster): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceRedisClusterToHclTerraform(struct?: ResourceRedisClusterOutputReference | ResourceRedisCluster): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRedisClusterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRedisCluster | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRedisCluster | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceRedshift {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceRedshiftToTerraform(struct?: ResourceRedshiftOutputReference | ResourceRedshift): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceRedshiftToHclTerraform(struct?: ResourceRedshiftOutputReference | ResourceRedshift): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRedshiftOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRedshift | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRedshift | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceRedshiftIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * Cluster Identified of Redshift cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#cluster_id Resource#cluster_id}
  */
  readonly clusterId: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_assumption_arn Resource#role_assumption_arn}
  */
  readonly roleAssumptionArn?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceRedshiftIamToTerraform(struct?: ResourceRedshiftIamOutputReference | ResourceRedshiftIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    cluster_id: cdktf.stringToTerraform(struct!.clusterId),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_assumption_arn: cdktf.stringToTerraform(struct!.roleAssumptionArn),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceRedshiftIamToHclTerraform(struct?: ResourceRedshiftIamOutputReference | ResourceRedshiftIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_assumption_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleAssumptionArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRedshiftIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRedshiftIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._clusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterId = this._clusterId;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleAssumptionArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleAssumptionArn = this._roleAssumptionArn;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRedshiftIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._clusterId = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleAssumptionArn = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._clusterId = value.clusterId;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleAssumptionArn = value.roleAssumptionArn;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // cluster_id - computed: false, optional: false, required: true
  private _clusterId?: string; 
  public get clusterId() {
    return this.getStringAttribute('cluster_id');
  }
  public set clusterId(value: string) {
    this._clusterId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterIdInput() {
    return this._clusterId;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_assumption_arn - computed: false, optional: true, required: false
  private _roleAssumptionArn?: string; 
  public get roleAssumptionArn() {
    return this.getStringAttribute('role_assumption_arn');
  }
  public set roleAssumptionArn(value: string) {
    this._roleAssumptionArn = value;
  }
  public resetRoleAssumptionArn() {
    this._roleAssumptionArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleAssumptionArnInput() {
    return this._roleAssumptionArn;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceRedshiftServerlessIam {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The AWS region to connect to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#region Resource#region}
  */
  readonly region: string;
  /**
  * If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#role_assumption_arn Resource#role_assumption_arn}
  */
  readonly roleAssumptionArn?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * Workgroup name in the serverless Redshift
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#workgroup Resource#workgroup}
  */
  readonly workgroup: string;
}

export function resourceRedshiftServerlessIamToTerraform(struct?: ResourceRedshiftServerlessIamOutputReference | ResourceRedshiftServerlessIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    region: cdktf.stringToTerraform(struct!.region),
    role_assumption_arn: cdktf.stringToTerraform(struct!.roleAssumptionArn),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    workgroup: cdktf.stringToTerraform(struct!.workgroup),
  }
}


export function resourceRedshiftServerlessIamToHclTerraform(struct?: ResourceRedshiftServerlessIamOutputReference | ResourceRedshiftServerlessIam): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_assumption_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleAssumptionArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    workgroup: {
      value: cdktf.stringToHclTerraform(struct!.workgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceRedshiftServerlessIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceRedshiftServerlessIam | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._roleAssumptionArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleAssumptionArn = this._roleAssumptionArn;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._workgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.workgroup = this._workgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceRedshiftServerlessIam | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._region = undefined;
      this._roleAssumptionArn = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._workgroup = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._region = value.region;
      this._roleAssumptionArn = value.roleAssumptionArn;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._workgroup = value.workgroup;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role_assumption_arn - computed: false, optional: true, required: false
  private _roleAssumptionArn?: string; 
  public get roleAssumptionArn() {
    return this.getStringAttribute('role_assumption_arn');
  }
  public set roleAssumptionArn(value: string) {
    this._roleAssumptionArn = value;
  }
  public resetRoleAssumptionArn() {
    this._roleAssumptionArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleAssumptionArnInput() {
    return this._roleAssumptionArn;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // workgroup - computed: false, optional: false, required: true
  private _workgroup?: string; 
  public get workgroup() {
    return this.getStringAttribute('workgroup');
  }
  public set workgroup(value: string) {
    this._workgroup = value;
  }
  // Temporarily expose input value. Use with caution.
  public get workgroupInput() {
    return this._workgroup;
  }
}
export interface ResourceSingleStore {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks. Does not affect client requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#require_native_auth Resource#require_native_auth}
  */
  readonly requireNativeAuth?: boolean | cdktf.IResolvable;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If true, appends the hostname to the username when hitting a database.azure.com address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#use_azure_single_server_usernames Resource#use_azure_single_server_usernames}
  */
  readonly useAzureSingleServerUsernames?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSingleStoreToTerraform(struct?: ResourceSingleStoreOutputReference | ResourceSingleStore): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    require_native_auth: cdktf.booleanToTerraform(struct!.requireNativeAuth),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    use_azure_single_server_usernames: cdktf.booleanToTerraform(struct!.useAzureSingleServerUsernames),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSingleStoreToHclTerraform(struct?: ResourceSingleStoreOutputReference | ResourceSingleStore): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    require_native_auth: {
      value: cdktf.booleanToHclTerraform(struct!.requireNativeAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    use_azure_single_server_usernames: {
      value: cdktf.booleanToHclTerraform(struct!.useAzureSingleServerUsernames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSingleStoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSingleStore | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._requireNativeAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireNativeAuth = this._requireNativeAuth;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._useAzureSingleServerUsernames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useAzureSingleServerUsernames = this._useAzureSingleServerUsernames;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSingleStore | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._requireNativeAuth = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._useAzureSingleServerUsernames = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._requireNativeAuth = value.requireNativeAuth;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._useAzureSingleServerUsernames = value.useAzureSingleServerUsernames;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // require_native_auth - computed: false, optional: true, required: false
  private _requireNativeAuth?: boolean | cdktf.IResolvable; 
  public get requireNativeAuth() {
    return this.getBooleanAttribute('require_native_auth');
  }
  public set requireNativeAuth(value: boolean | cdktf.IResolvable) {
    this._requireNativeAuth = value;
  }
  public resetRequireNativeAuth() {
    this._requireNativeAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireNativeAuthInput() {
    return this._requireNativeAuth;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // use_azure_single_server_usernames - computed: false, optional: true, required: false
  private _useAzureSingleServerUsernames?: boolean | cdktf.IResolvable; 
  public get useAzureSingleServerUsernames() {
    return this.getBooleanAttribute('use_azure_single_server_usernames');
  }
  public set useAzureSingleServerUsernames(value: boolean | cdktf.IResolvable) {
    this._useAzureSingleServerUsernames = value;
  }
  public resetUseAzureSingleServerUsernames() {
    this._useAzureSingleServerUsernames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useAzureSingleServerUsernamesInput() {
    return this._useAzureSingleServerUsernames;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSnowflake {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * Deprecated: https://www.snowflake.com/en/blog/blocking-single-factor-password-authentification/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * RSA Private Key for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#private_key Resource#private_key}
  */
  readonly privateKey?: string;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The schema to provide on authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#schema Resource#schema}
  */
  readonly schema?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSnowflakeToTerraform(struct?: ResourceSnowflakeOutputReference | ResourceSnowflake): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    schema: cdktf.stringToTerraform(struct!.schema),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSnowflakeToHclTerraform(struct?: ResourceSnowflakeOutputReference | ResourceSnowflake): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSnowflakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSnowflake | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSnowflake | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._portOverride = undefined;
      this._privateKey = undefined;
      this._proxyClusterId = undefined;
      this._schema = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._portOverride = value.portOverride;
      this._privateKey = value.privateKey;
      this._proxyClusterId = value.proxyClusterId;
      this._schema = value.schema;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: true, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // schema - computed: false, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSnowsight {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * If true, select the ACS with isDefault=true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#connect_to_default Resource#connect_to_default}
  */
  readonly connectToDefault?: boolean | cdktf.IResolvable;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The StrongDM user email to use for healthchecks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#healthcheck_username Resource#healthcheck_username}
  */
  readonly healthcheckUsername: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The Metadata for your snowflake IDP integration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#saml_metadata Resource#saml_metadata}
  */
  readonly samlMetadata?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
}

export function resourceSnowsightToTerraform(struct?: ResourceSnowsightOutputReference | ResourceSnowsight): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    connect_to_default: cdktf.booleanToTerraform(struct!.connectToDefault),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    healthcheck_username: cdktf.stringToTerraform(struct!.healthcheckUsername),
    name: cdktf.stringToTerraform(struct!.name),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    saml_metadata: cdktf.stringToTerraform(struct!.samlMetadata),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
  }
}


export function resourceSnowsightToHclTerraform(struct?: ResourceSnowsightOutputReference | ResourceSnowsight): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connect_to_default: {
      value: cdktf.booleanToHclTerraform(struct!.connectToDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.healthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    saml_metadata: {
      value: cdktf.stringToHclTerraform(struct!.samlMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSnowsightOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSnowsight | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._connectToDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectToDefault = this._connectToDefault;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._healthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthcheckUsername = this._healthcheckUsername;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._samlMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.samlMetadata = this._samlMetadata;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSnowsight | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._connectToDefault = undefined;
      this._egressFilter = undefined;
      this._healthcheckUsername = undefined;
      this._name = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._samlMetadata = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._connectToDefault = value.connectToDefault;
      this._egressFilter = value.egressFilter;
      this._healthcheckUsername = value.healthcheckUsername;
      this._name = value.name;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._samlMetadata = value.samlMetadata;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // connect_to_default - computed: false, optional: true, required: false
  private _connectToDefault?: boolean | cdktf.IResolvable; 
  public get connectToDefault() {
    return this.getBooleanAttribute('connect_to_default');
  }
  public set connectToDefault(value: boolean | cdktf.IResolvable) {
    this._connectToDefault = value;
  }
  public resetConnectToDefault() {
    this._connectToDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectToDefaultInput() {
    return this._connectToDefault;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // healthcheck_username - computed: false, optional: false, required: true
  private _healthcheckUsername?: string; 
  public get healthcheckUsername() {
    return this.getStringAttribute('healthcheck_username');
  }
  public set healthcheckUsername(value: string) {
    this._healthcheckUsername = value;
  }
  // Temporarily expose input value. Use with caution.
  public get healthcheckUsernameInput() {
    return this._healthcheckUsername;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // saml_metadata - computed: false, optional: true, required: false
  private _samlMetadata?: string; 
  public get samlMetadata() {
    return this.getStringAttribute('saml_metadata');
  }
  public set samlMetadata(value: string) {
    this._samlMetadata = value;
  }
  public resetSamlMetadata() {
    this._samlMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get samlMetadataInput() {
    return this._samlMetadata;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: false, optional: false, required: true
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }
}
export interface ResourceSqlServer {
  /**
  * Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_deprecated_encryption Resource#allow_deprecated_encryption}
  */
  readonly allowDeprecatedEncryption?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks, and used for clients if Override Default Database is true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The Schema to use to direct initial requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#schema Resource#schema}
  */
  readonly schema?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSqlServerToTerraform(struct?: ResourceSqlServerOutputReference | ResourceSqlServer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_deprecated_encryption: cdktf.booleanToTerraform(struct!.allowDeprecatedEncryption),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    schema: cdktf.stringToTerraform(struct!.schema),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSqlServerToHclTerraform(struct?: ResourceSqlServerOutputReference | ResourceSqlServer): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_deprecated_encryption: {
      value: cdktf.booleanToHclTerraform(struct!.allowDeprecatedEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSqlServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSqlServer | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowDeprecatedEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowDeprecatedEncryption = this._allowDeprecatedEncryption;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSqlServer | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowDeprecatedEncryption = undefined;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._schema = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowDeprecatedEncryption = value.allowDeprecatedEncryption;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._schema = value.schema;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // allow_deprecated_encryption - computed: false, optional: true, required: false
  private _allowDeprecatedEncryption?: boolean | cdktf.IResolvable; 
  public get allowDeprecatedEncryption() {
    return this.getBooleanAttribute('allow_deprecated_encryption');
  }
  public set allowDeprecatedEncryption(value: boolean | cdktf.IResolvable) {
    this._allowDeprecatedEncryption = value;
  }
  public resetAllowDeprecatedEncryption() {
    this._allowDeprecatedEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowDeprecatedEncryptionInput() {
    return this._allowDeprecatedEncryption;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // schema - computed: false, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSqlServerAzureAd {
  /**
  * Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_deprecated_encryption Resource#allow_deprecated_encryption}
  */
  readonly allowDeprecatedEncryption?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The Azure AD application (client) ID with which to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#client_id Resource#client_id}
  */
  readonly clientId?: string;
  /**
  * The database for healthchecks, and used for clients if Override Default Database is true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The Schema to use to direct initial requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#schema Resource#schema}
  */
  readonly schema?: string;
  /**
  * The Azure AD client secret (application password) with which to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret Resource#secret}
  */
  readonly secret?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The Azure AD directory (tenant) ID with which to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tenant_id Resource#tenant_id}
  */
  readonly tenantId?: string;
}

export function resourceSqlServerAzureAdToTerraform(struct?: ResourceSqlServerAzureAdOutputReference | ResourceSqlServerAzureAd): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_deprecated_encryption: cdktf.booleanToTerraform(struct!.allowDeprecatedEncryption),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    schema: cdktf.stringToTerraform(struct!.schema),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
  }
}


export function resourceSqlServerAzureAdToHclTerraform(struct?: ResourceSqlServerAzureAdOutputReference | ResourceSqlServerAzureAd): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_deprecated_encryption: {
      value: cdktf.booleanToHclTerraform(struct!.allowDeprecatedEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSqlServerAzureAdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSqlServerAzureAd | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowDeprecatedEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowDeprecatedEncryption = this._allowDeprecatedEncryption;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSqlServerAzureAd | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowDeprecatedEncryption = undefined;
      this._bindInterface = undefined;
      this._clientId = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._schema = undefined;
      this._secret = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tenantId = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowDeprecatedEncryption = value.allowDeprecatedEncryption;
      this._bindInterface = value.bindInterface;
      this._clientId = value.clientId;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._schema = value.schema;
      this._secret = value.secret;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tenantId = value.tenantId;
    }
  }

  // allow_deprecated_encryption - computed: false, optional: true, required: false
  private _allowDeprecatedEncryption?: boolean | cdktf.IResolvable; 
  public get allowDeprecatedEncryption() {
    return this.getBooleanAttribute('allow_deprecated_encryption');
  }
  public set allowDeprecatedEncryption(value: boolean | cdktf.IResolvable) {
    this._allowDeprecatedEncryption = value;
  }
  public resetAllowDeprecatedEncryption() {
    this._allowDeprecatedEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowDeprecatedEncryptionInput() {
    return this._allowDeprecatedEncryption;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // schema - computed: false, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }
}
export interface ResourceSqlServerKerberosAd {
  /**
  * Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_deprecated_encryption Resource#allow_deprecated_encryption}
  */
  readonly allowDeprecatedEncryption?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The database for healthchecks, and used for clients if Override Default Database is true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#keytab Resource#keytab}
  */
  readonly keytab?: string;
  /**
  * The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#krb_config Resource#krb_config}
  */
  readonly krbConfig?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#override_database Resource#override_database}
  */
  readonly overrideDatabase?: boolean | cdktf.IResolvable;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * The Active Directory domain (realm) to which the configured username belongs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#realm Resource#realm}
  */
  readonly realm?: string;
  /**
  * The Schema to use to direct initial requests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#schema Resource#schema}
  */
  readonly schema?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#server_spn Resource#server_spn}
  */
  readonly serverSpn: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSqlServerKerberosAdToTerraform(struct?: ResourceSqlServerKerberosAdOutputReference | ResourceSqlServerKerberosAd): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_deprecated_encryption: cdktf.booleanToTerraform(struct!.allowDeprecatedEncryption),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    keytab: cdktf.stringToTerraform(struct!.keytab),
    krb_config: cdktf.stringToTerraform(struct!.krbConfig),
    name: cdktf.stringToTerraform(struct!.name),
    override_database: cdktf.booleanToTerraform(struct!.overrideDatabase),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    realm: cdktf.stringToTerraform(struct!.realm),
    schema: cdktf.stringToTerraform(struct!.schema),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    server_spn: cdktf.stringToTerraform(struct!.serverSpn),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSqlServerKerberosAdToHclTerraform(struct?: ResourceSqlServerKerberosAdOutputReference | ResourceSqlServerKerberosAd): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_deprecated_encryption: {
      value: cdktf.booleanToHclTerraform(struct!.allowDeprecatedEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keytab: {
      value: cdktf.stringToHclTerraform(struct!.keytab),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    krb_config: {
      value: cdktf.stringToHclTerraform(struct!.krbConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override_database: {
      value: cdktf.booleanToHclTerraform(struct!.overrideDatabase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    realm: {
      value: cdktf.stringToHclTerraform(struct!.realm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_spn: {
      value: cdktf.stringToHclTerraform(struct!.serverSpn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSqlServerKerberosAdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSqlServerKerberosAd | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowDeprecatedEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowDeprecatedEncryption = this._allowDeprecatedEncryption;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._keytab !== undefined) {
      hasAnyValues = true;
      internalValueResult.keytab = this._keytab;
    }
    if (this._krbConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.krbConfig = this._krbConfig;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._overrideDatabase !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrideDatabase = this._overrideDatabase;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._realm !== undefined) {
      hasAnyValues = true;
      internalValueResult.realm = this._realm;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._serverSpn !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSpn = this._serverSpn;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSqlServerKerberosAd | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowDeprecatedEncryption = undefined;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._keytab = undefined;
      this._krbConfig = undefined;
      this._name = undefined;
      this._overrideDatabase = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._realm = undefined;
      this._schema = undefined;
      this._secretStoreId = undefined;
      this._serverSpn = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowDeprecatedEncryption = value.allowDeprecatedEncryption;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._keytab = value.keytab;
      this._krbConfig = value.krbConfig;
      this._name = value.name;
      this._overrideDatabase = value.overrideDatabase;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._realm = value.realm;
      this._schema = value.schema;
      this._secretStoreId = value.secretStoreId;
      this._serverSpn = value.serverSpn;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // allow_deprecated_encryption - computed: false, optional: true, required: false
  private _allowDeprecatedEncryption?: boolean | cdktf.IResolvable; 
  public get allowDeprecatedEncryption() {
    return this.getBooleanAttribute('allow_deprecated_encryption');
  }
  public set allowDeprecatedEncryption(value: boolean | cdktf.IResolvable) {
    this._allowDeprecatedEncryption = value;
  }
  public resetAllowDeprecatedEncryption() {
    this._allowDeprecatedEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowDeprecatedEncryptionInput() {
    return this._allowDeprecatedEncryption;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // keytab - computed: false, optional: true, required: false
  private _keytab?: string; 
  public get keytab() {
    return this.getStringAttribute('keytab');
  }
  public set keytab(value: string) {
    this._keytab = value;
  }
  public resetKeytab() {
    this._keytab = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keytabInput() {
    return this._keytab;
  }

  // krb_config - computed: false, optional: true, required: false
  private _krbConfig?: string; 
  public get krbConfig() {
    return this.getStringAttribute('krb_config');
  }
  public set krbConfig(value: string) {
    this._krbConfig = value;
  }
  public resetKrbConfig() {
    this._krbConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get krbConfigInput() {
    return this._krbConfig;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // override_database - computed: false, optional: true, required: false
  private _overrideDatabase?: boolean | cdktf.IResolvable; 
  public get overrideDatabase() {
    return this.getBooleanAttribute('override_database');
  }
  public set overrideDatabase(value: boolean | cdktf.IResolvable) {
    this._overrideDatabase = value;
  }
  public resetOverrideDatabase() {
    this._overrideDatabase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideDatabaseInput() {
    return this._overrideDatabase;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // realm - computed: false, optional: true, required: false
  private _realm?: string; 
  public get realm() {
    return this.getStringAttribute('realm');
  }
  public set realm(value: string) {
    this._realm = value;
  }
  public resetRealm() {
    this._realm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get realmInput() {
    return this._realm;
  }

  // schema - computed: false, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // server_spn - computed: false, optional: false, required: true
  private _serverSpn?: string; 
  public get serverSpn() {
    return this.getStringAttribute('server_spn');
  }
  public set serverSpn(value: string) {
    this._serverSpn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSpnInput() {
    return this._serverSpn;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSsh {
  /**
  * Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_deprecated_key_exchanges Resource#allow_deprecated_key_exchanges}
  */
  readonly allowDeprecatedKeyExchanges?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The key type to use e.g. rsa-2048 or ed25519
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#key_type Resource#key_type}
  */
  readonly keyType?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * Whether port forwarding is allowed through this server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_forwarding Resource#port_forwarding}
  */
  readonly portForwarding?: boolean | cdktf.IResolvable;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSshToTerraform(struct?: ResourceSshOutputReference | ResourceSsh): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_deprecated_key_exchanges: cdktf.booleanToTerraform(struct!.allowDeprecatedKeyExchanges),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    key_type: cdktf.stringToTerraform(struct!.keyType),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_forwarding: cdktf.booleanToTerraform(struct!.portForwarding),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSshToHclTerraform(struct?: ResourceSshOutputReference | ResourceSsh): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_deprecated_key_exchanges: {
      value: cdktf.booleanToHclTerraform(struct!.allowDeprecatedKeyExchanges),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_type: {
      value: cdktf.stringToHclTerraform(struct!.keyType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_forwarding: {
      value: cdktf.booleanToHclTerraform(struct!.portForwarding),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSshOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSsh | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowDeprecatedKeyExchanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowDeprecatedKeyExchanges = this._allowDeprecatedKeyExchanges;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._keyType !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyType = this._keyType;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portForwarding !== undefined) {
      hasAnyValues = true;
      internalValueResult.portForwarding = this._portForwarding;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSsh | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowDeprecatedKeyExchanges = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._keyType = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portForwarding = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowDeprecatedKeyExchanges = value.allowDeprecatedKeyExchanges;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._keyType = value.keyType;
      this._name = value.name;
      this._port = value.port;
      this._portForwarding = value.portForwarding;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // allow_deprecated_key_exchanges - computed: false, optional: true, required: false
  private _allowDeprecatedKeyExchanges?: boolean | cdktf.IResolvable; 
  public get allowDeprecatedKeyExchanges() {
    return this.getBooleanAttribute('allow_deprecated_key_exchanges');
  }
  public set allowDeprecatedKeyExchanges(value: boolean | cdktf.IResolvable) {
    this._allowDeprecatedKeyExchanges = value;
  }
  public resetAllowDeprecatedKeyExchanges() {
    this._allowDeprecatedKeyExchanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowDeprecatedKeyExchangesInput() {
    return this._allowDeprecatedKeyExchanges;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // key_type - computed: true, optional: true, required: false
  private _keyType?: string; 
  public get keyType() {
    return this.getStringAttribute('key_type');
  }
  public set keyType(value: string) {
    this._keyType = value;
  }
  public resetKeyType() {
    this._keyType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyTypeInput() {
    return this._keyType;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_forwarding - computed: false, optional: true, required: false
  private _portForwarding?: boolean | cdktf.IResolvable; 
  public get portForwarding() {
    return this.getBooleanAttribute('port_forwarding');
  }
  public set portForwarding(value: boolean | cdktf.IResolvable) {
    this._portForwarding = value;
  }
  public resetPortForwarding() {
    this._portForwarding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portForwardingInput() {
    return this._portForwarding;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // public_key - computed: true, optional: false, required: false
  public get publicKey() {
    return this.getStringAttribute('public_key');
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSshCert {
  /**
  * Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_deprecated_key_exchanges Resource#allow_deprecated_key_exchanges}
  */
  readonly allowDeprecatedKeyExchanges?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * The key type to use e.g. rsa-2048 or ed25519
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#key_type Resource#key_type}
  */
  readonly keyType?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * Whether port forwarding is allowed through this server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_forwarding Resource#port_forwarding}
  */
  readonly portForwarding?: boolean | cdktf.IResolvable;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSshCertToTerraform(struct?: ResourceSshCertOutputReference | ResourceSshCert): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_deprecated_key_exchanges: cdktf.booleanToTerraform(struct!.allowDeprecatedKeyExchanges),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    key_type: cdktf.stringToTerraform(struct!.keyType),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_forwarding: cdktf.booleanToTerraform(struct!.portForwarding),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSshCertToHclTerraform(struct?: ResourceSshCertOutputReference | ResourceSshCert): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_deprecated_key_exchanges: {
      value: cdktf.booleanToHclTerraform(struct!.allowDeprecatedKeyExchanges),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_type: {
      value: cdktf.stringToHclTerraform(struct!.keyType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_forwarding: {
      value: cdktf.booleanToHclTerraform(struct!.portForwarding),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSshCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSshCert | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowDeprecatedKeyExchanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowDeprecatedKeyExchanges = this._allowDeprecatedKeyExchanges;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._keyType !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyType = this._keyType;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portForwarding !== undefined) {
      hasAnyValues = true;
      internalValueResult.portForwarding = this._portForwarding;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSshCert | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowDeprecatedKeyExchanges = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._keyType = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portForwarding = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowDeprecatedKeyExchanges = value.allowDeprecatedKeyExchanges;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._keyType = value.keyType;
      this._name = value.name;
      this._port = value.port;
      this._portForwarding = value.portForwarding;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // allow_deprecated_key_exchanges - computed: false, optional: true, required: false
  private _allowDeprecatedKeyExchanges?: boolean | cdktf.IResolvable; 
  public get allowDeprecatedKeyExchanges() {
    return this.getBooleanAttribute('allow_deprecated_key_exchanges');
  }
  public set allowDeprecatedKeyExchanges(value: boolean | cdktf.IResolvable) {
    this._allowDeprecatedKeyExchanges = value;
  }
  public resetAllowDeprecatedKeyExchanges() {
    this._allowDeprecatedKeyExchanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowDeprecatedKeyExchangesInput() {
    return this._allowDeprecatedKeyExchanges;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // key_type - computed: true, optional: true, required: false
  private _keyType?: string; 
  public get keyType() {
    return this.getStringAttribute('key_type');
  }
  public set keyType(value: string) {
    this._keyType = value;
  }
  public resetKeyType() {
    this._keyType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyTypeInput() {
    return this._keyType;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_forwarding - computed: false, optional: true, required: false
  private _portForwarding?: boolean | cdktf.IResolvable; 
  public get portForwarding() {
    return this.getBooleanAttribute('port_forwarding');
  }
  public set portForwarding(value: boolean | cdktf.IResolvable) {
    this._portForwarding = value;
  }
  public resetPortForwarding() {
    this._portForwarding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portForwardingInput() {
    return this._portForwarding;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSshCustomerKey {
  /**
  * Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_deprecated_key_exchanges Resource#allow_deprecated_key_exchanges}
  */
  readonly allowDeprecatedKeyExchanges?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_alias_healthcheck_username Resource#identity_alias_healthcheck_username}
  */
  readonly identityAliasHealthcheckUsername?: string;
  /**
  * The ID of the identity set to use for identity connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#identity_set_id Resource#identity_set_id}
  */
  readonly identitySetId?: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * Whether port forwarding is allowed through this server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_forwarding Resource#port_forwarding}
  */
  readonly portForwarding?: boolean | cdktf.IResolvable;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * The private key used to authenticate with the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#private_key Resource#private_key}
  */
  readonly privateKey?: string;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSshCustomerKeyToTerraform(struct?: ResourceSshCustomerKeyOutputReference | ResourceSshCustomerKey): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_deprecated_key_exchanges: cdktf.booleanToTerraform(struct!.allowDeprecatedKeyExchanges),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    identity_alias_healthcheck_username: cdktf.stringToTerraform(struct!.identityAliasHealthcheckUsername),
    identity_set_id: cdktf.stringToTerraform(struct!.identitySetId),
    name: cdktf.stringToTerraform(struct!.name),
    port: cdktf.numberToTerraform(struct!.port),
    port_forwarding: cdktf.booleanToTerraform(struct!.portForwarding),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSshCustomerKeyToHclTerraform(struct?: ResourceSshCustomerKeyOutputReference | ResourceSshCustomerKey): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_deprecated_key_exchanges: {
      value: cdktf.booleanToHclTerraform(struct!.allowDeprecatedKeyExchanges),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_alias_healthcheck_username: {
      value: cdktf.stringToHclTerraform(struct!.identityAliasHealthcheckUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_set_id: {
      value: cdktf.stringToHclTerraform(struct!.identitySetId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_forwarding: {
      value: cdktf.booleanToHclTerraform(struct!.portForwarding),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSshCustomerKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSshCustomerKey | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowDeprecatedKeyExchanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowDeprecatedKeyExchanges = this._allowDeprecatedKeyExchanges;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._identityAliasHealthcheckUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityAliasHealthcheckUsername = this._identityAliasHealthcheckUsername;
    }
    if (this._identitySetId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySetId = this._identitySetId;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portForwarding !== undefined) {
      hasAnyValues = true;
      internalValueResult.portForwarding = this._portForwarding;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSshCustomerKey | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowDeprecatedKeyExchanges = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._identityAliasHealthcheckUsername = undefined;
      this._identitySetId = undefined;
      this._name = undefined;
      this._port = undefined;
      this._portForwarding = undefined;
      this._portOverride = undefined;
      this._privateKey = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowDeprecatedKeyExchanges = value.allowDeprecatedKeyExchanges;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._identityAliasHealthcheckUsername = value.identityAliasHealthcheckUsername;
      this._identitySetId = value.identitySetId;
      this._name = value.name;
      this._port = value.port;
      this._portForwarding = value.portForwarding;
      this._portOverride = value.portOverride;
      this._privateKey = value.privateKey;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // allow_deprecated_key_exchanges - computed: false, optional: true, required: false
  private _allowDeprecatedKeyExchanges?: boolean | cdktf.IResolvable; 
  public get allowDeprecatedKeyExchanges() {
    return this.getBooleanAttribute('allow_deprecated_key_exchanges');
  }
  public set allowDeprecatedKeyExchanges(value: boolean | cdktf.IResolvable) {
    this._allowDeprecatedKeyExchanges = value;
  }
  public resetAllowDeprecatedKeyExchanges() {
    this._allowDeprecatedKeyExchanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowDeprecatedKeyExchangesInput() {
    return this._allowDeprecatedKeyExchanges;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // identity_alias_healthcheck_username - computed: false, optional: true, required: false
  private _identityAliasHealthcheckUsername?: string; 
  public get identityAliasHealthcheckUsername() {
    return this.getStringAttribute('identity_alias_healthcheck_username');
  }
  public set identityAliasHealthcheckUsername(value: string) {
    this._identityAliasHealthcheckUsername = value;
  }
  public resetIdentityAliasHealthcheckUsername() {
    this._identityAliasHealthcheckUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityAliasHealthcheckUsernameInput() {
    return this._identityAliasHealthcheckUsername;
  }

  // identity_set_id - computed: false, optional: true, required: false
  private _identitySetId?: string; 
  public get identitySetId() {
    return this.getStringAttribute('identity_set_id');
  }
  public set identitySetId(value: string) {
    this._identitySetId = value;
  }
  public resetIdentitySetId() {
    this._identitySetId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySetIdInput() {
    return this._identitySetId;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_forwarding - computed: false, optional: true, required: false
  private _portForwarding?: boolean | cdktf.IResolvable; 
  public get portForwarding() {
    return this.getBooleanAttribute('port_forwarding');
  }
  public set portForwarding(value: boolean | cdktf.IResolvable) {
    this._portForwarding = value;
  }
  public resetPortForwarding() {
    this._portForwarding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portForwardingInput() {
    return this._portForwarding;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSshPassword {
  /**
  * Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#allow_deprecated_key_exchanges Resource#allow_deprecated_key_exchanges}
  */
  readonly allowDeprecatedKeyExchanges?: boolean | cdktf.IResolvable;
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port: number;
  /**
  * Whether port forwarding is allowed through this server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_forwarding Resource#port_forwarding}
  */
  readonly portForwarding?: boolean | cdktf.IResolvable;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSshPasswordToTerraform(struct?: ResourceSshPasswordOutputReference | ResourceSshPassword): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_deprecated_key_exchanges: cdktf.booleanToTerraform(struct!.allowDeprecatedKeyExchanges),
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_forwarding: cdktf.booleanToTerraform(struct!.portForwarding),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSshPasswordToHclTerraform(struct?: ResourceSshPasswordOutputReference | ResourceSshPassword): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_deprecated_key_exchanges: {
      value: cdktf.booleanToHclTerraform(struct!.allowDeprecatedKeyExchanges),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_forwarding: {
      value: cdktf.booleanToHclTerraform(struct!.portForwarding),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSshPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSshPassword | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowDeprecatedKeyExchanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowDeprecatedKeyExchanges = this._allowDeprecatedKeyExchanges;
    }
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portForwarding !== undefined) {
      hasAnyValues = true;
      internalValueResult.portForwarding = this._portForwarding;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSshPassword | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._allowDeprecatedKeyExchanges = undefined;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portForwarding = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._allowDeprecatedKeyExchanges = value.allowDeprecatedKeyExchanges;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portForwarding = value.portForwarding;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // allow_deprecated_key_exchanges - computed: false, optional: true, required: false
  private _allowDeprecatedKeyExchanges?: boolean | cdktf.IResolvable; 
  public get allowDeprecatedKeyExchanges() {
    return this.getBooleanAttribute('allow_deprecated_key_exchanges');
  }
  public set allowDeprecatedKeyExchanges(value: boolean | cdktf.IResolvable) {
    this._allowDeprecatedKeyExchanges = value;
  }
  public resetAllowDeprecatedKeyExchanges() {
    this._allowDeprecatedKeyExchanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowDeprecatedKeyExchangesInput() {
    return this._allowDeprecatedKeyExchanges;
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_forwarding - computed: false, optional: true, required: false
  private _portForwarding?: boolean | cdktf.IResolvable; 
  public get portForwarding() {
    return this.getBooleanAttribute('port_forwarding');
  }
  public set portForwarding(value: boolean | cdktf.IResolvable) {
    this._portForwarding = value;
  }
  public resetPortForwarding() {
    this._portForwarding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portForwardingInput() {
    return this._portForwarding;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSybase {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSybaseToTerraform(struct?: ResourceSybaseOutputReference | ResourceSybase): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSybaseToHclTerraform(struct?: ResourceSybaseOutputReference | ResourceSybase): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSybaseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSybase | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSybase | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceSybaseIq {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceSybaseIqToTerraform(struct?: ResourceSybaseIqOutputReference | ResourceSybaseIq): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceSybaseIqToHclTerraform(struct?: ResourceSybaseIqOutputReference | ResourceSybaseIq): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceSybaseIqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceSybaseIq | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceSybaseIq | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceTeradata {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceTeradataToTerraform(struct?: ResourceTeradataOutputReference | ResourceTeradata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceTeradataToHclTerraform(struct?: ResourceTeradataOutputReference | ResourceTeradata): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceTeradataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceTeradata | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceTeradata | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceTimeouts {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#create Resource#create}
  */
  readonly create?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#default Resource#default}
  */
  readonly default?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#delete Resource#delete}
  */
  readonly delete?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#read Resource#read}
  */
  readonly read?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#update Resource#update}
  */
  readonly update?: string;
}

export function resourceTimeoutsToTerraform(struct?: ResourceTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create: cdktf.stringToTerraform(struct!.create),
    default: cdktf.stringToTerraform(struct!.default),
    delete: cdktf.stringToTerraform(struct!.delete),
    read: cdktf.stringToTerraform(struct!.read),
    update: cdktf.stringToTerraform(struct!.update),
  }
}


export function resourceTimeoutsToHclTerraform(struct?: ResourceTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create: {
      value: cdktf.stringToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default: {
      value: cdktf.stringToHclTerraform(struct!.default),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete: {
      value: cdktf.stringToHclTerraform(struct!.delete),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read: {
      value: cdktf.stringToHclTerraform(struct!.read),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    update: {
      value: cdktf.stringToHclTerraform(struct!.update),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceTimeoutsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): ResourceTimeouts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    if (this._default !== undefined) {
      hasAnyValues = true;
      internalValueResult.default = this._default;
    }
    if (this._delete !== undefined) {
      hasAnyValues = true;
      internalValueResult.delete = this._delete;
    }
    if (this._read !== undefined) {
      hasAnyValues = true;
      internalValueResult.read = this._read;
    }
    if (this._update !== undefined) {
      hasAnyValues = true;
      internalValueResult.update = this._update;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceTimeouts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._create = undefined;
      this._default = undefined;
      this._delete = undefined;
      this._read = undefined;
      this._update = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._create = value.create;
      this._default = value.default;
      this._delete = value.delete;
      this._read = value.read;
      this._update = value.update;
    }
  }

  // create - computed: false, optional: true, required: false
  private _create?: string; 
  public get create() {
    return this.getStringAttribute('create');
  }
  public set create(value: string) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }

  // default - computed: false, optional: true, required: false
  private _default?: string; 
  public get default() {
    return this.getStringAttribute('default');
  }
  public set default(value: string) {
    this._default = value;
  }
  public resetDefault() {
    this._default = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultInput() {
    return this._default;
  }

  // delete - computed: false, optional: true, required: false
  private _delete?: string; 
  public get delete() {
    return this.getStringAttribute('delete');
  }
  public set delete(value: string) {
    this._delete = value;
  }
  public resetDelete() {
    this._delete = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteInput() {
    return this._delete;
  }

  // read - computed: false, optional: true, required: false
  private _read?: string; 
  public get read() {
    return this.getStringAttribute('read');
  }
  public set read(value: string) {
    this._read = value;
  }
  public resetRead() {
    this._read = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readInput() {
    return this._read;
  }

  // update - computed: false, optional: true, required: false
  private _update?: string; 
  public get update() {
    return this.getStringAttribute('update');
  }
  public set update(value: string) {
    this._update = value;
  }
  public resetUpdate() {
    this._update = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateInput() {
    return this._update;
  }
}
export interface ResourceTrino {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * If set, TLS must be used to connect to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tls_required Resource#tls_required}
  */
  readonly tlsRequired?: boolean | cdktf.IResolvable;
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceTrinoToTerraform(struct?: ResourceTrinoOutputReference | ResourceTrino): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    tls_required: cdktf.booleanToTerraform(struct!.tlsRequired),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceTrinoToHclTerraform(struct?: ResourceTrinoOutputReference | ResourceTrino): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    tls_required: {
      value: cdktf.booleanToHclTerraform(struct!.tlsRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceTrinoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceTrino | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._tlsRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsRequired = this._tlsRequired;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceTrino | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._tlsRequired = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._tlsRequired = value.tlsRequired;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // tls_required - computed: false, optional: true, required: false
  private _tlsRequired?: boolean | cdktf.IResolvable; 
  public get tlsRequired() {
    return this.getBooleanAttribute('tls_required');
  }
  public set tlsRequired(value: boolean | cdktf.IResolvable) {
    this._tlsRequired = value;
  }
  public resetTlsRequired() {
    this._tlsRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsRequiredInput() {
    return this._tlsRequired;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface ResourceVertica {
  /**
  * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided and may also be set to one of the ResourceIPAllocationMode constants to select between VNM, loopback, or default allocation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#bind_interface Resource#bind_interface}
  */
  readonly bindInterface?: string;
  /**
  * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#database Resource#database}
  */
  readonly database: string;
  /**
  * A filter applied to the routing logic to pin datasource to nodes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#egress_filter Resource#egress_filter}
  */
  readonly egressFilter?: string;
  /**
  * The host to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#hostname Resource#hostname}
  */
  readonly hostname: string;
  /**
  * Unique human-readable name of the Resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#name Resource#name}
  */
  readonly name: string;
  /**
  * The password to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#password Resource#password}
  */
  readonly password?: string;
  /**
  * The port to dial to initiate a connection from the egress node to this resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port Resource#port}
  */
  readonly port?: number;
  /**
  * The local port used by clients to connect to this resource. It is automatically generated if not provided on create and may be re-generated on update by specifying a value of -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#port_override Resource#port_override}
  */
  readonly portOverride?: number;
  /**
  * ID of the proxy cluster for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#proxy_cluster_id Resource#proxy_cluster_id}
  */
  readonly proxyClusterId?: string;
  /**
  * ID of the secret store containing credentials for this resource, if any.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#secret_store_id Resource#secret_store_id}
  */
  readonly secretStoreId?: string;
  /**
  * DNS subdomain through which this resource may be accessed on clients.  (e.g. "app-prod1" allows the resource to be accessed at "app-prod1.your-org-name.sdm-proxy-domain"). Only applicable to HTTP-based resources or resources using virtual networking mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#subdomain Resource#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Tags is a map of key, value pairs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#tags Resource#tags}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The username to authenticate with.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#username Resource#username}
  */
  readonly username?: string;
}

export function resourceVerticaToTerraform(struct?: ResourceVerticaOutputReference | ResourceVertica): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bind_interface: cdktf.stringToTerraform(struct!.bindInterface),
    database: cdktf.stringToTerraform(struct!.database),
    egress_filter: cdktf.stringToTerraform(struct!.egressFilter),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    name: cdktf.stringToTerraform(struct!.name),
    password: cdktf.stringToTerraform(struct!.password),
    port: cdktf.numberToTerraform(struct!.port),
    port_override: cdktf.numberToTerraform(struct!.portOverride),
    proxy_cluster_id: cdktf.stringToTerraform(struct!.proxyClusterId),
    secret_store_id: cdktf.stringToTerraform(struct!.secretStoreId),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    tags: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.tags),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function resourceVerticaToHclTerraform(struct?: ResourceVerticaOutputReference | ResourceVertica): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bind_interface: {
      value: cdktf.stringToHclTerraform(struct!.bindInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    egress_filter: {
      value: cdktf.stringToHclTerraform(struct!.egressFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    port_override: {
      value: cdktf.numberToHclTerraform(struct!.portOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    proxy_cluster_id: {
      value: cdktf.stringToHclTerraform(struct!.proxyClusterId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_store_id: {
      value: cdktf.stringToHclTerraform(struct!.secretStoreId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tags: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.tags),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class ResourceVerticaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): ResourceVertica | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindInterface = this._bindInterface;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._egressFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.egressFilter = this._egressFilter;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._portOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.portOverride = this._portOverride;
    }
    if (this._proxyClusterId !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyClusterId = this._proxyClusterId;
    }
    if (this._secretStoreId !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretStoreId = this._secretStoreId;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: ResourceVertica | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._bindInterface = undefined;
      this._database = undefined;
      this._egressFilter = undefined;
      this._hostname = undefined;
      this._name = undefined;
      this._password = undefined;
      this._port = undefined;
      this._portOverride = undefined;
      this._proxyClusterId = undefined;
      this._secretStoreId = undefined;
      this._subdomain = undefined;
      this._tags = undefined;
      this._username = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._bindInterface = value.bindInterface;
      this._database = value.database;
      this._egressFilter = value.egressFilter;
      this._hostname = value.hostname;
      this._name = value.name;
      this._password = value.password;
      this._port = value.port;
      this._portOverride = value.portOverride;
      this._proxyClusterId = value.proxyClusterId;
      this._secretStoreId = value.secretStoreId;
      this._subdomain = value.subdomain;
      this._tags = value.tags;
      this._username = value.username;
    }
  }

  // bind_interface - computed: true, optional: true, required: false
  private _bindInterface?: string; 
  public get bindInterface() {
    return this.getStringAttribute('bind_interface');
  }
  public set bindInterface(value: string) {
    this._bindInterface = value;
  }
  public resetBindInterface() {
    this._bindInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindInterfaceInput() {
    return this._bindInterface;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // egress_filter - computed: false, optional: true, required: false
  private _egressFilter?: string; 
  public get egressFilter() {
    return this.getStringAttribute('egress_filter');
  }
  public set egressFilter(value: string) {
    this._egressFilter = value;
  }
  public resetEgressFilter() {
    this._egressFilter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get egressFilterInput() {
    return this._egressFilter;
  }

  // hostname - computed: false, optional: false, required: true
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // port_override - computed: true, optional: true, required: false
  private _portOverride?: number; 
  public get portOverride() {
    return this.getNumberAttribute('port_override');
  }
  public set portOverride(value: number) {
    this._portOverride = value;
  }
  public resetPortOverride() {
    this._portOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portOverrideInput() {
    return this._portOverride;
  }

  // proxy_cluster_id - computed: false, optional: true, required: false
  private _proxyClusterId?: string; 
  public get proxyClusterId() {
    return this.getStringAttribute('proxy_cluster_id');
  }
  public set proxyClusterId(value: string) {
    this._proxyClusterId = value;
  }
  public resetProxyClusterId() {
    this._proxyClusterId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyClusterIdInput() {
    return this._proxyClusterId;
  }

  // secret_store_id - computed: false, optional: true, required: false
  private _secretStoreId?: string; 
  public get secretStoreId() {
    return this.getStringAttribute('secret_store_id');
  }
  public set secretStoreId(value: string) {
    this._secretStoreId = value;
  }
  public resetSecretStoreId() {
    this._secretStoreId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretStoreIdInput() {
    return this._secretStoreId;
  }

  // subdomain - computed: true, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // tags - computed: false, optional: true, required: false
  private _tags?: { [key: string]: string }; 
  public get tags() {
    return this.getStringMapAttribute('tags');
  }
  public set tags(value: { [key: string]: string }) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource sdm_resource}
*/
export class Resource extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "sdm_resource";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a Resource resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the Resource to import
  * @param importFromId The id of the existing Resource that should be imported. Refer to the {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the Resource to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "sdm_resource", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/strongdm/sdm/15.27.0/docs/resources/resource sdm_resource} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ResourceConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ResourceConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'sdm_resource',
      terraformGeneratorMetadata: {
        providerName: 'sdm',
        providerVersion: '15.27.0'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._id = config.id;
    this._aerospike.internalValue = config.aerospike;
    this._aks.internalValue = config.aks;
    this._aksBasicAuth.internalValue = config.aksBasicAuth;
    this._aksServiceAccount.internalValue = config.aksServiceAccount;
    this._aksServiceAccountUserImpersonation.internalValue = config.aksServiceAccountUserImpersonation;
    this._aksUserImpersonation.internalValue = config.aksUserImpersonation;
    this._amazonEks.internalValue = config.amazonEks;
    this._amazonEksInstanceProfile.internalValue = config.amazonEksInstanceProfile;
    this._amazonEksInstanceProfileUserImpersonation.internalValue = config.amazonEksInstanceProfileUserImpersonation;
    this._amazonEksUserImpersonation.internalValue = config.amazonEksUserImpersonation;
    this._amazonEs.internalValue = config.amazonEs;
    this._amazonEsiam.internalValue = config.amazonEsiam;
    this._amazonmqAmqp.internalValue = config.amazonmqAmqp;
    this._amazonmqAmqp091.internalValue = config.amazonmqAmqp091;
    this._athena.internalValue = config.athena;
    this._athenaIam.internalValue = config.athenaIam;
    this._auroraMysql.internalValue = config.auroraMysql;
    this._auroraMysqlIam.internalValue = config.auroraMysqlIam;
    this._auroraPostgres.internalValue = config.auroraPostgres;
    this._auroraPostgresIam.internalValue = config.auroraPostgresIam;
    this._aws.internalValue = config.aws;
    this._awsConsole.internalValue = config.awsConsole;
    this._awsConsoleStaticKeyPair.internalValue = config.awsConsoleStaticKeyPair;
    this._awsInstanceProfile.internalValue = config.awsInstanceProfile;
    this._azure.internalValue = config.azure;
    this._azureCertificate.internalValue = config.azureCertificate;
    this._azureMysql.internalValue = config.azureMysql;
    this._azureMysqlManagedIdentity.internalValue = config.azureMysqlManagedIdentity;
    this._azurePostgres.internalValue = config.azurePostgres;
    this._azurePostgresManagedIdentity.internalValue = config.azurePostgresManagedIdentity;
    this._bigQuery.internalValue = config.bigQuery;
    this._cassandra.internalValue = config.cassandra;
    this._citus.internalValue = config.citus;
    this._clickHouseHttp.internalValue = config.clickHouseHttp;
    this._clickHouseMySql.internalValue = config.clickHouseMySql;
    this._clickHouseTcp.internalValue = config.clickHouseTcp;
    this._clustrix.internalValue = config.clustrix;
    this._cockroach.internalValue = config.cockroach;
    this._couchbaseDatabase.internalValue = config.couchbaseDatabase;
    this._couchbaseWebUi.internalValue = config.couchbaseWebUi;
    this._db2I.internalValue = config.db2I;
    this._db2Luw.internalValue = config.db2Luw;
    this._documentDbHost.internalValue = config.documentDbHost;
    this._documentDbHostIam.internalValue = config.documentDbHostIam;
    this._documentDbReplicaSet.internalValue = config.documentDbReplicaSet;
    this._documentDbReplicaSetIam.internalValue = config.documentDbReplicaSetIam;
    this._druid.internalValue = config.druid;
    this._dynamoDb.internalValue = config.dynamoDb;
    this._dynamoDbiam.internalValue = config.dynamoDbiam;
    this._elastic.internalValue = config.elastic;
    this._elasticacheRedis.internalValue = config.elasticacheRedis;
    this._elasticacheRedisIam.internalValue = config.elasticacheRedisIam;
    this._entraId.internalValue = config.entraId;
    this._gcp.internalValue = config.gcp;
    this._gcpConsole.internalValue = config.gcpConsole;
    this._gcpwif.internalValue = config.gcpwif;
    this._googleGke.internalValue = config.googleGke;
    this._googleGkeUserImpersonation.internalValue = config.googleGkeUserImpersonation;
    this._greenplum.internalValue = config.greenplum;
    this._httpAuth.internalValue = config.httpAuth;
    this._httpBasicAuth.internalValue = config.httpBasicAuth;
    this._httpNoAuth.internalValue = config.httpNoAuth;
    this._kubernetes.internalValue = config.kubernetes;
    this._kubernetesBasicAuth.internalValue = config.kubernetesBasicAuth;
    this._kubernetesPodIdentity.internalValue = config.kubernetesPodIdentity;
    this._kubernetesServiceAccount.internalValue = config.kubernetesServiceAccount;
    this._kubernetesServiceAccountUserImpersonation.internalValue = config.kubernetesServiceAccountUserImpersonation;
    this._kubernetesUserImpersonation.internalValue = config.kubernetesUserImpersonation;
    this._maria.internalValue = config.maria;
    this._mcp.internalValue = config.mcp;
    this._memcached.internalValue = config.memcached;
    this._memsql.internalValue = config.memsql;
    this._mongoHost.internalValue = config.mongoHost;
    this._mongoLegacyHost.internalValue = config.mongoLegacyHost;
    this._mongoLegacyReplicaset.internalValue = config.mongoLegacyReplicaset;
    this._mongoReplicaSet.internalValue = config.mongoReplicaSet;
    this._mongoShardedCluster.internalValue = config.mongoShardedCluster;
    this._mtlsMysql.internalValue = config.mtlsMysql;
    this._mtlsPostgres.internalValue = config.mtlsPostgres;
    this._mysql.internalValue = config.mysql;
    this._neptune.internalValue = config.neptune;
    this._neptuneIam.internalValue = config.neptuneIam;
    this._oracle.internalValue = config.oracle;
    this._oracleNne.internalValue = config.oracleNne;
    this._postgres.internalValue = config.postgres;
    this._presto.internalValue = config.presto;
    this._rabbitmqAmqp091.internalValue = config.rabbitmqAmqp091;
    this._rawTcp.internalValue = config.rawTcp;
    this._rdp.internalValue = config.rdp;
    this._rdpCert.internalValue = config.rdpCert;
    this._rdsPostgresIam.internalValue = config.rdsPostgresIam;
    this._redis.internalValue = config.redis;
    this._redisCluster.internalValue = config.redisCluster;
    this._redshift.internalValue = config.redshift;
    this._redshiftIam.internalValue = config.redshiftIam;
    this._redshiftServerlessIam.internalValue = config.redshiftServerlessIam;
    this._singleStore.internalValue = config.singleStore;
    this._snowflake.internalValue = config.snowflake;
    this._snowsight.internalValue = config.snowsight;
    this._sqlServer.internalValue = config.sqlServer;
    this._sqlServerAzureAd.internalValue = config.sqlServerAzureAd;
    this._sqlServerKerberosAd.internalValue = config.sqlServerKerberosAd;
    this._ssh.internalValue = config.ssh;
    this._sshCert.internalValue = config.sshCert;
    this._sshCustomerKey.internalValue = config.sshCustomerKey;
    this._sshPassword.internalValue = config.sshPassword;
    this._sybase.internalValue = config.sybase;
    this._sybaseIq.internalValue = config.sybaseIq;
    this._teradata.internalValue = config.teradata;
    this._timeouts.internalValue = config.timeouts;
    this._trino.internalValue = config.trino;
    this._vertica.internalValue = config.vertica;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // aerospike - computed: false, optional: true, required: false
  private _aerospike = new ResourceAerospikeOutputReference(this, "aerospike");
  public get aerospike() {
    return this._aerospike;
  }
  public putAerospike(value: ResourceAerospike) {
    this._aerospike.internalValue = value;
  }
  public resetAerospike() {
    this._aerospike.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aerospikeInput() {
    return this._aerospike.internalValue;
  }

  // aks - computed: false, optional: true, required: false
  private _aks = new ResourceAksOutputReference(this, "aks");
  public get aks() {
    return this._aks;
  }
  public putAks(value: ResourceAks) {
    this._aks.internalValue = value;
  }
  public resetAks() {
    this._aks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aksInput() {
    return this._aks.internalValue;
  }

  // aks_basic_auth - computed: false, optional: true, required: false
  private _aksBasicAuth = new ResourceAksBasicAuthOutputReference(this, "aks_basic_auth");
  public get aksBasicAuth() {
    return this._aksBasicAuth;
  }
  public putAksBasicAuth(value: ResourceAksBasicAuth) {
    this._aksBasicAuth.internalValue = value;
  }
  public resetAksBasicAuth() {
    this._aksBasicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aksBasicAuthInput() {
    return this._aksBasicAuth.internalValue;
  }

  // aks_service_account - computed: false, optional: true, required: false
  private _aksServiceAccount = new ResourceAksServiceAccountOutputReference(this, "aks_service_account");
  public get aksServiceAccount() {
    return this._aksServiceAccount;
  }
  public putAksServiceAccount(value: ResourceAksServiceAccount) {
    this._aksServiceAccount.internalValue = value;
  }
  public resetAksServiceAccount() {
    this._aksServiceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aksServiceAccountInput() {
    return this._aksServiceAccount.internalValue;
  }

  // aks_service_account_user_impersonation - computed: false, optional: true, required: false
  private _aksServiceAccountUserImpersonation = new ResourceAksServiceAccountUserImpersonationOutputReference(this, "aks_service_account_user_impersonation");
  public get aksServiceAccountUserImpersonation() {
    return this._aksServiceAccountUserImpersonation;
  }
  public putAksServiceAccountUserImpersonation(value: ResourceAksServiceAccountUserImpersonation) {
    this._aksServiceAccountUserImpersonation.internalValue = value;
  }
  public resetAksServiceAccountUserImpersonation() {
    this._aksServiceAccountUserImpersonation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aksServiceAccountUserImpersonationInput() {
    return this._aksServiceAccountUserImpersonation.internalValue;
  }

  // aks_user_impersonation - computed: false, optional: true, required: false
  private _aksUserImpersonation = new ResourceAksUserImpersonationOutputReference(this, "aks_user_impersonation");
  public get aksUserImpersonation() {
    return this._aksUserImpersonation;
  }
  public putAksUserImpersonation(value: ResourceAksUserImpersonation) {
    this._aksUserImpersonation.internalValue = value;
  }
  public resetAksUserImpersonation() {
    this._aksUserImpersonation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get aksUserImpersonationInput() {
    return this._aksUserImpersonation.internalValue;
  }

  // amazon_eks - computed: false, optional: true, required: false
  private _amazonEks = new ResourceAmazonEksOutputReference(this, "amazon_eks");
  public get amazonEks() {
    return this._amazonEks;
  }
  public putAmazonEks(value: ResourceAmazonEks) {
    this._amazonEks.internalValue = value;
  }
  public resetAmazonEks() {
    this._amazonEks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get amazonEksInput() {
    return this._amazonEks.internalValue;
  }

  // amazon_eks_instance_profile - computed: false, optional: true, required: false
  private _amazonEksInstanceProfile = new ResourceAmazonEksInstanceProfileOutputReference(this, "amazon_eks_instance_profile");
  public get amazonEksInstanceProfile() {
    return this._amazonEksInstanceProfile;
  }
  public putAmazonEksInstanceProfile(value: ResourceAmazonEksInstanceProfile) {
    this._amazonEksInstanceProfile.internalValue = value;
  }
  public resetAmazonEksInstanceProfile() {
    this._amazonEksInstanceProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get amazonEksInstanceProfileInput() {
    return this._amazonEksInstanceProfile.internalValue;
  }

  // amazon_eks_instance_profile_user_impersonation - computed: false, optional: true, required: false
  private _amazonEksInstanceProfileUserImpersonation = new ResourceAmazonEksInstanceProfileUserImpersonationOutputReference(this, "amazon_eks_instance_profile_user_impersonation");
  public get amazonEksInstanceProfileUserImpersonation() {
    return this._amazonEksInstanceProfileUserImpersonation;
  }
  public putAmazonEksInstanceProfileUserImpersonation(value: ResourceAmazonEksInstanceProfileUserImpersonation) {
    this._amazonEksInstanceProfileUserImpersonation.internalValue = value;
  }
  public resetAmazonEksInstanceProfileUserImpersonation() {
    this._amazonEksInstanceProfileUserImpersonation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get amazonEksInstanceProfileUserImpersonationInput() {
    return this._amazonEksInstanceProfileUserImpersonation.internalValue;
  }

  // amazon_eks_user_impersonation - computed: false, optional: true, required: false
  private _amazonEksUserImpersonation = new ResourceAmazonEksUserImpersonationOutputReference(this, "amazon_eks_user_impersonation");
  public get amazonEksUserImpersonation() {
    return this._amazonEksUserImpersonation;
  }
  public putAmazonEksUserImpersonation(value: ResourceAmazonEksUserImpersonation) {
    this._amazonEksUserImpersonation.internalValue = value;
  }
  public resetAmazonEksUserImpersonation() {
    this._amazonEksUserImpersonation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get amazonEksUserImpersonationInput() {
    return this._amazonEksUserImpersonation.internalValue;
  }

  // amazon_es - computed: false, optional: true, required: false
  private _amazonEs = new ResourceAmazonEsOutputReference(this, "amazon_es");
  public get amazonEs() {
    return this._amazonEs;
  }
  public putAmazonEs(value: ResourceAmazonEs) {
    this._amazonEs.internalValue = value;
  }
  public resetAmazonEs() {
    this._amazonEs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get amazonEsInput() {
    return this._amazonEs.internalValue;
  }

  // amazon_esiam - computed: false, optional: true, required: false
  private _amazonEsiam = new ResourceAmazonEsiamOutputReference(this, "amazon_esiam");
  public get amazonEsiam() {
    return this._amazonEsiam;
  }
  public putAmazonEsiam(value: ResourceAmazonEsiam) {
    this._amazonEsiam.internalValue = value;
  }
  public resetAmazonEsiam() {
    this._amazonEsiam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get amazonEsiamInput() {
    return this._amazonEsiam.internalValue;
  }

  // amazonmq_amqp - computed: false, optional: true, required: false
  private _amazonmqAmqp = new ResourceAmazonmqAmqpOutputReference(this, "amazonmq_amqp");
  public get amazonmqAmqp() {
    return this._amazonmqAmqp;
  }
  public putAmazonmqAmqp(value: ResourceAmazonmqAmqp) {
    this._amazonmqAmqp.internalValue = value;
  }
  public resetAmazonmqAmqp() {
    this._amazonmqAmqp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get amazonmqAmqpInput() {
    return this._amazonmqAmqp.internalValue;
  }

  // amazonmq_amqp_091 - computed: false, optional: true, required: false
  private _amazonmqAmqp091 = new ResourceAmazonmqAmqp091OutputReference(this, "amazonmq_amqp_091");
  public get amazonmqAmqp091() {
    return this._amazonmqAmqp091;
  }
  public putAmazonmqAmqp091(value: ResourceAmazonmqAmqp091) {
    this._amazonmqAmqp091.internalValue = value;
  }
  public resetAmazonmqAmqp091() {
    this._amazonmqAmqp091.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get amazonmqAmqp091Input() {
    return this._amazonmqAmqp091.internalValue;
  }

  // athena - computed: false, optional: true, required: false
  private _athena = new ResourceAthenaOutputReference(this, "athena");
  public get athena() {
    return this._athena;
  }
  public putAthena(value: ResourceAthena) {
    this._athena.internalValue = value;
  }
  public resetAthena() {
    this._athena.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get athenaInput() {
    return this._athena.internalValue;
  }

  // athena_iam - computed: false, optional: true, required: false
  private _athenaIam = new ResourceAthenaIamOutputReference(this, "athena_iam");
  public get athenaIam() {
    return this._athenaIam;
  }
  public putAthenaIam(value: ResourceAthenaIam) {
    this._athenaIam.internalValue = value;
  }
  public resetAthenaIam() {
    this._athenaIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get athenaIamInput() {
    return this._athenaIam.internalValue;
  }

  // aurora_mysql - computed: false, optional: true, required: false
  private _auroraMysql = new ResourceAuroraMysqlOutputReference(this, "aurora_mysql");
  public get auroraMysql() {
    return this._auroraMysql;
  }
  public putAuroraMysql(value: ResourceAuroraMysql) {
    this._auroraMysql.internalValue = value;
  }
  public resetAuroraMysql() {
    this._auroraMysql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auroraMysqlInput() {
    return this._auroraMysql.internalValue;
  }

  // aurora_mysql_iam - computed: false, optional: true, required: false
  private _auroraMysqlIam = new ResourceAuroraMysqlIamOutputReference(this, "aurora_mysql_iam");
  public get auroraMysqlIam() {
    return this._auroraMysqlIam;
  }
  public putAuroraMysqlIam(value: ResourceAuroraMysqlIam) {
    this._auroraMysqlIam.internalValue = value;
  }
  public resetAuroraMysqlIam() {
    this._auroraMysqlIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auroraMysqlIamInput() {
    return this._auroraMysqlIam.internalValue;
  }

  // aurora_postgres - computed: false, optional: true, required: false
  private _auroraPostgres = new ResourceAuroraPostgresOutputReference(this, "aurora_postgres");
  public get auroraPostgres() {
    return this._auroraPostgres;
  }
  public putAuroraPostgres(value: ResourceAuroraPostgres) {
    this._auroraPostgres.internalValue = value;
  }
  public resetAuroraPostgres() {
    this._auroraPostgres.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auroraPostgresInput() {
    return this._auroraPostgres.internalValue;
  }

  // aurora_postgres_iam - computed: false, optional: true, required: false
  private _auroraPostgresIam = new ResourceAuroraPostgresIamOutputReference(this, "aurora_postgres_iam");
  public get auroraPostgresIam() {
    return this._auroraPostgresIam;
  }
  public putAuroraPostgresIam(value: ResourceAuroraPostgresIam) {
    this._auroraPostgresIam.internalValue = value;
  }
  public resetAuroraPostgresIam() {
    this._auroraPostgresIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get auroraPostgresIamInput() {
    return this._auroraPostgresIam.internalValue;
  }

  // aws - computed: false, optional: true, required: false
  private _aws = new ResourceAwsOutputReference(this, "aws");
  public get aws() {
    return this._aws;
  }
  public putAws(value: ResourceAws) {
    this._aws.internalValue = value;
  }
  public resetAws() {
    this._aws.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsInput() {
    return this._aws.internalValue;
  }

  // aws_console - computed: false, optional: true, required: false
  private _awsConsole = new ResourceAwsConsoleOutputReference(this, "aws_console");
  public get awsConsole() {
    return this._awsConsole;
  }
  public putAwsConsole(value: ResourceAwsConsole) {
    this._awsConsole.internalValue = value;
  }
  public resetAwsConsole() {
    this._awsConsole.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsConsoleInput() {
    return this._awsConsole.internalValue;
  }

  // aws_console_static_key_pair - computed: false, optional: true, required: false
  private _awsConsoleStaticKeyPair = new ResourceAwsConsoleStaticKeyPairOutputReference(this, "aws_console_static_key_pair");
  public get awsConsoleStaticKeyPair() {
    return this._awsConsoleStaticKeyPair;
  }
  public putAwsConsoleStaticKeyPair(value: ResourceAwsConsoleStaticKeyPair) {
    this._awsConsoleStaticKeyPair.internalValue = value;
  }
  public resetAwsConsoleStaticKeyPair() {
    this._awsConsoleStaticKeyPair.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsConsoleStaticKeyPairInput() {
    return this._awsConsoleStaticKeyPair.internalValue;
  }

  // aws_instance_profile - computed: false, optional: true, required: false
  private _awsInstanceProfile = new ResourceAwsInstanceProfileOutputReference(this, "aws_instance_profile");
  public get awsInstanceProfile() {
    return this._awsInstanceProfile;
  }
  public putAwsInstanceProfile(value: ResourceAwsInstanceProfile) {
    this._awsInstanceProfile.internalValue = value;
  }
  public resetAwsInstanceProfile() {
    this._awsInstanceProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsInstanceProfileInput() {
    return this._awsInstanceProfile.internalValue;
  }

  // azure - computed: false, optional: true, required: false
  private _azure = new ResourceAzureOutputReference(this, "azure");
  public get azure() {
    return this._azure;
  }
  public putAzure(value: ResourceAzure) {
    this._azure.internalValue = value;
  }
  public resetAzure() {
    this._azure.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureInput() {
    return this._azure.internalValue;
  }

  // azure_certificate - computed: false, optional: true, required: false
  private _azureCertificate = new ResourceAzureCertificateOutputReference(this, "azure_certificate");
  public get azureCertificate() {
    return this._azureCertificate;
  }
  public putAzureCertificate(value: ResourceAzureCertificate) {
    this._azureCertificate.internalValue = value;
  }
  public resetAzureCertificate() {
    this._azureCertificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureCertificateInput() {
    return this._azureCertificate.internalValue;
  }

  // azure_mysql - computed: false, optional: true, required: false
  private _azureMysql = new ResourceAzureMysqlOutputReference(this, "azure_mysql");
  public get azureMysql() {
    return this._azureMysql;
  }
  public putAzureMysql(value: ResourceAzureMysql) {
    this._azureMysql.internalValue = value;
  }
  public resetAzureMysql() {
    this._azureMysql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureMysqlInput() {
    return this._azureMysql.internalValue;
  }

  // azure_mysql_managed_identity - computed: false, optional: true, required: false
  private _azureMysqlManagedIdentity = new ResourceAzureMysqlManagedIdentityOutputReference(this, "azure_mysql_managed_identity");
  public get azureMysqlManagedIdentity() {
    return this._azureMysqlManagedIdentity;
  }
  public putAzureMysqlManagedIdentity(value: ResourceAzureMysqlManagedIdentity) {
    this._azureMysqlManagedIdentity.internalValue = value;
  }
  public resetAzureMysqlManagedIdentity() {
    this._azureMysqlManagedIdentity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureMysqlManagedIdentityInput() {
    return this._azureMysqlManagedIdentity.internalValue;
  }

  // azure_postgres - computed: false, optional: true, required: false
  private _azurePostgres = new ResourceAzurePostgresOutputReference(this, "azure_postgres");
  public get azurePostgres() {
    return this._azurePostgres;
  }
  public putAzurePostgres(value: ResourceAzurePostgres) {
    this._azurePostgres.internalValue = value;
  }
  public resetAzurePostgres() {
    this._azurePostgres.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azurePostgresInput() {
    return this._azurePostgres.internalValue;
  }

  // azure_postgres_managed_identity - computed: false, optional: true, required: false
  private _azurePostgresManagedIdentity = new ResourceAzurePostgresManagedIdentityOutputReference(this, "azure_postgres_managed_identity");
  public get azurePostgresManagedIdentity() {
    return this._azurePostgresManagedIdentity;
  }
  public putAzurePostgresManagedIdentity(value: ResourceAzurePostgresManagedIdentity) {
    this._azurePostgresManagedIdentity.internalValue = value;
  }
  public resetAzurePostgresManagedIdentity() {
    this._azurePostgresManagedIdentity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azurePostgresManagedIdentityInput() {
    return this._azurePostgresManagedIdentity.internalValue;
  }

  // big_query - computed: false, optional: true, required: false
  private _bigQuery = new ResourceBigQueryOutputReference(this, "big_query");
  public get bigQuery() {
    return this._bigQuery;
  }
  public putBigQuery(value: ResourceBigQuery) {
    this._bigQuery.internalValue = value;
  }
  public resetBigQuery() {
    this._bigQuery.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bigQueryInput() {
    return this._bigQuery.internalValue;
  }

  // cassandra - computed: false, optional: true, required: false
  private _cassandra = new ResourceCassandraOutputReference(this, "cassandra");
  public get cassandra() {
    return this._cassandra;
  }
  public putCassandra(value: ResourceCassandra) {
    this._cassandra.internalValue = value;
  }
  public resetCassandra() {
    this._cassandra.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cassandraInput() {
    return this._cassandra.internalValue;
  }

  // citus - computed: false, optional: true, required: false
  private _citus = new ResourceCitusOutputReference(this, "citus");
  public get citus() {
    return this._citus;
  }
  public putCitus(value: ResourceCitus) {
    this._citus.internalValue = value;
  }
  public resetCitus() {
    this._citus.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get citusInput() {
    return this._citus.internalValue;
  }

  // click_house_http - computed: false, optional: true, required: false
  private _clickHouseHttp = new ResourceClickHouseHttpOutputReference(this, "click_house_http");
  public get clickHouseHttp() {
    return this._clickHouseHttp;
  }
  public putClickHouseHttp(value: ResourceClickHouseHttp) {
    this._clickHouseHttp.internalValue = value;
  }
  public resetClickHouseHttp() {
    this._clickHouseHttp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clickHouseHttpInput() {
    return this._clickHouseHttp.internalValue;
  }

  // click_house_my_sql - computed: false, optional: true, required: false
  private _clickHouseMySql = new ResourceClickHouseMySqlOutputReference(this, "click_house_my_sql");
  public get clickHouseMySql() {
    return this._clickHouseMySql;
  }
  public putClickHouseMySql(value: ResourceClickHouseMySql) {
    this._clickHouseMySql.internalValue = value;
  }
  public resetClickHouseMySql() {
    this._clickHouseMySql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clickHouseMySqlInput() {
    return this._clickHouseMySql.internalValue;
  }

  // click_house_tcp - computed: false, optional: true, required: false
  private _clickHouseTcp = new ResourceClickHouseTcpOutputReference(this, "click_house_tcp");
  public get clickHouseTcp() {
    return this._clickHouseTcp;
  }
  public putClickHouseTcp(value: ResourceClickHouseTcp) {
    this._clickHouseTcp.internalValue = value;
  }
  public resetClickHouseTcp() {
    this._clickHouseTcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clickHouseTcpInput() {
    return this._clickHouseTcp.internalValue;
  }

  // clustrix - computed: false, optional: true, required: false
  private _clustrix = new ResourceClustrixOutputReference(this, "clustrix");
  public get clustrix() {
    return this._clustrix;
  }
  public putClustrix(value: ResourceClustrix) {
    this._clustrix.internalValue = value;
  }
  public resetClustrix() {
    this._clustrix.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustrixInput() {
    return this._clustrix.internalValue;
  }

  // cockroach - computed: false, optional: true, required: false
  private _cockroach = new ResourceCockroachOutputReference(this, "cockroach");
  public get cockroach() {
    return this._cockroach;
  }
  public putCockroach(value: ResourceCockroach) {
    this._cockroach.internalValue = value;
  }
  public resetCockroach() {
    this._cockroach.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cockroachInput() {
    return this._cockroach.internalValue;
  }

  // couchbase_database - computed: false, optional: true, required: false
  private _couchbaseDatabase = new ResourceCouchbaseDatabaseOutputReference(this, "couchbase_database");
  public get couchbaseDatabase() {
    return this._couchbaseDatabase;
  }
  public putCouchbaseDatabase(value: ResourceCouchbaseDatabase) {
    this._couchbaseDatabase.internalValue = value;
  }
  public resetCouchbaseDatabase() {
    this._couchbaseDatabase.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get couchbaseDatabaseInput() {
    return this._couchbaseDatabase.internalValue;
  }

  // couchbase_web_ui - computed: false, optional: true, required: false
  private _couchbaseWebUi = new ResourceCouchbaseWebUiOutputReference(this, "couchbase_web_ui");
  public get couchbaseWebUi() {
    return this._couchbaseWebUi;
  }
  public putCouchbaseWebUi(value: ResourceCouchbaseWebUi) {
    this._couchbaseWebUi.internalValue = value;
  }
  public resetCouchbaseWebUi() {
    this._couchbaseWebUi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get couchbaseWebUiInput() {
    return this._couchbaseWebUi.internalValue;
  }

  // db_2_i - computed: false, optional: true, required: false
  private _db2I = new ResourceDb2IOutputReference(this, "db_2_i");
  public get db2I() {
    return this._db2I;
  }
  public putDb2I(value: ResourceDb2I) {
    this._db2I.internalValue = value;
  }
  public resetDb2I() {
    this._db2I.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get db2IInput() {
    return this._db2I.internalValue;
  }

  // db_2_luw - computed: false, optional: true, required: false
  private _db2Luw = new ResourceDb2LuwOutputReference(this, "db_2_luw");
  public get db2Luw() {
    return this._db2Luw;
  }
  public putDb2Luw(value: ResourceDb2Luw) {
    this._db2Luw.internalValue = value;
  }
  public resetDb2Luw() {
    this._db2Luw.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get db2LuwInput() {
    return this._db2Luw.internalValue;
  }

  // document_db_host - computed: false, optional: true, required: false
  private _documentDbHost = new ResourceDocumentDbHostOutputReference(this, "document_db_host");
  public get documentDbHost() {
    return this._documentDbHost;
  }
  public putDocumentDbHost(value: ResourceDocumentDbHost) {
    this._documentDbHost.internalValue = value;
  }
  public resetDocumentDbHost() {
    this._documentDbHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get documentDbHostInput() {
    return this._documentDbHost.internalValue;
  }

  // document_db_host_iam - computed: false, optional: true, required: false
  private _documentDbHostIam = new ResourceDocumentDbHostIamOutputReference(this, "document_db_host_iam");
  public get documentDbHostIam() {
    return this._documentDbHostIam;
  }
  public putDocumentDbHostIam(value: ResourceDocumentDbHostIam) {
    this._documentDbHostIam.internalValue = value;
  }
  public resetDocumentDbHostIam() {
    this._documentDbHostIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get documentDbHostIamInput() {
    return this._documentDbHostIam.internalValue;
  }

  // document_db_replica_set - computed: false, optional: true, required: false
  private _documentDbReplicaSet = new ResourceDocumentDbReplicaSetOutputReference(this, "document_db_replica_set");
  public get documentDbReplicaSet() {
    return this._documentDbReplicaSet;
  }
  public putDocumentDbReplicaSet(value: ResourceDocumentDbReplicaSet) {
    this._documentDbReplicaSet.internalValue = value;
  }
  public resetDocumentDbReplicaSet() {
    this._documentDbReplicaSet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get documentDbReplicaSetInput() {
    return this._documentDbReplicaSet.internalValue;
  }

  // document_db_replica_set_iam - computed: false, optional: true, required: false
  private _documentDbReplicaSetIam = new ResourceDocumentDbReplicaSetIamOutputReference(this, "document_db_replica_set_iam");
  public get documentDbReplicaSetIam() {
    return this._documentDbReplicaSetIam;
  }
  public putDocumentDbReplicaSetIam(value: ResourceDocumentDbReplicaSetIam) {
    this._documentDbReplicaSetIam.internalValue = value;
  }
  public resetDocumentDbReplicaSetIam() {
    this._documentDbReplicaSetIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get documentDbReplicaSetIamInput() {
    return this._documentDbReplicaSetIam.internalValue;
  }

  // druid - computed: false, optional: true, required: false
  private _druid = new ResourceDruidOutputReference(this, "druid");
  public get druid() {
    return this._druid;
  }
  public putDruid(value: ResourceDruid) {
    this._druid.internalValue = value;
  }
  public resetDruid() {
    this._druid.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get druidInput() {
    return this._druid.internalValue;
  }

  // dynamo_db - computed: false, optional: true, required: false
  private _dynamoDb = new ResourceDynamoDbOutputReference(this, "dynamo_db");
  public get dynamoDb() {
    return this._dynamoDb;
  }
  public putDynamoDb(value: ResourceDynamoDb) {
    this._dynamoDb.internalValue = value;
  }
  public resetDynamoDb() {
    this._dynamoDb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamoDbInput() {
    return this._dynamoDb.internalValue;
  }

  // dynamo_dbiam - computed: false, optional: true, required: false
  private _dynamoDbiam = new ResourceDynamoDbiamOutputReference(this, "dynamo_dbiam");
  public get dynamoDbiam() {
    return this._dynamoDbiam;
  }
  public putDynamoDbiam(value: ResourceDynamoDbiam) {
    this._dynamoDbiam.internalValue = value;
  }
  public resetDynamoDbiam() {
    this._dynamoDbiam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamoDbiamInput() {
    return this._dynamoDbiam.internalValue;
  }

  // elastic - computed: false, optional: true, required: false
  private _elastic = new ResourceElasticOutputReference(this, "elastic");
  public get elastic() {
    return this._elastic;
  }
  public putElastic(value: ResourceElastic) {
    this._elastic.internalValue = value;
  }
  public resetElastic() {
    this._elastic.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticInput() {
    return this._elastic.internalValue;
  }

  // elasticache_redis - computed: false, optional: true, required: false
  private _elasticacheRedis = new ResourceElasticacheRedisOutputReference(this, "elasticache_redis");
  public get elasticacheRedis() {
    return this._elasticacheRedis;
  }
  public putElasticacheRedis(value: ResourceElasticacheRedis) {
    this._elasticacheRedis.internalValue = value;
  }
  public resetElasticacheRedis() {
    this._elasticacheRedis.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticacheRedisInput() {
    return this._elasticacheRedis.internalValue;
  }

  // elasticache_redis_iam - computed: false, optional: true, required: false
  private _elasticacheRedisIam = new ResourceElasticacheRedisIamOutputReference(this, "elasticache_redis_iam");
  public get elasticacheRedisIam() {
    return this._elasticacheRedisIam;
  }
  public putElasticacheRedisIam(value: ResourceElasticacheRedisIam) {
    this._elasticacheRedisIam.internalValue = value;
  }
  public resetElasticacheRedisIam() {
    this._elasticacheRedisIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticacheRedisIamInput() {
    return this._elasticacheRedisIam.internalValue;
  }

  // entra_id - computed: false, optional: true, required: false
  private _entraId = new ResourceEntraIdOutputReference(this, "entra_id");
  public get entraId() {
    return this._entraId;
  }
  public putEntraId(value: ResourceEntraId) {
    this._entraId.internalValue = value;
  }
  public resetEntraId() {
    this._entraId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entraIdInput() {
    return this._entraId.internalValue;
  }

  // gcp - computed: false, optional: true, required: false
  private _gcp = new ResourceGcpOutputReference(this, "gcp");
  public get gcp() {
    return this._gcp;
  }
  public putGcp(value: ResourceGcp) {
    this._gcp.internalValue = value;
  }
  public resetGcp() {
    this._gcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcpInput() {
    return this._gcp.internalValue;
  }

  // gcp_console - computed: false, optional: true, required: false
  private _gcpConsole = new ResourceGcpConsoleOutputReference(this, "gcp_console");
  public get gcpConsole() {
    return this._gcpConsole;
  }
  public putGcpConsole(value: ResourceGcpConsole) {
    this._gcpConsole.internalValue = value;
  }
  public resetGcpConsole() {
    this._gcpConsole.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcpConsoleInput() {
    return this._gcpConsole.internalValue;
  }

  // gcpwif - computed: false, optional: true, required: false
  private _gcpwif = new ResourceGcpwifOutputReference(this, "gcpwif");
  public get gcpwif() {
    return this._gcpwif;
  }
  public putGcpwif(value: ResourceGcpwif) {
    this._gcpwif.internalValue = value;
  }
  public resetGcpwif() {
    this._gcpwif.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gcpwifInput() {
    return this._gcpwif.internalValue;
  }

  // google_gke - computed: false, optional: true, required: false
  private _googleGke = new ResourceGoogleGkeOutputReference(this, "google_gke");
  public get googleGke() {
    return this._googleGke;
  }
  public putGoogleGke(value: ResourceGoogleGke) {
    this._googleGke.internalValue = value;
  }
  public resetGoogleGke() {
    this._googleGke.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleGkeInput() {
    return this._googleGke.internalValue;
  }

  // google_gke_user_impersonation - computed: false, optional: true, required: false
  private _googleGkeUserImpersonation = new ResourceGoogleGkeUserImpersonationOutputReference(this, "google_gke_user_impersonation");
  public get googleGkeUserImpersonation() {
    return this._googleGkeUserImpersonation;
  }
  public putGoogleGkeUserImpersonation(value: ResourceGoogleGkeUserImpersonation) {
    this._googleGkeUserImpersonation.internalValue = value;
  }
  public resetGoogleGkeUserImpersonation() {
    this._googleGkeUserImpersonation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleGkeUserImpersonationInput() {
    return this._googleGkeUserImpersonation.internalValue;
  }

  // greenplum - computed: false, optional: true, required: false
  private _greenplum = new ResourceGreenplumOutputReference(this, "greenplum");
  public get greenplum() {
    return this._greenplum;
  }
  public putGreenplum(value: ResourceGreenplum) {
    this._greenplum.internalValue = value;
  }
  public resetGreenplum() {
    this._greenplum.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get greenplumInput() {
    return this._greenplum.internalValue;
  }

  // http_auth - computed: false, optional: true, required: false
  private _httpAuth = new ResourceHttpAuthOutputReference(this, "http_auth");
  public get httpAuth() {
    return this._httpAuth;
  }
  public putHttpAuth(value: ResourceHttpAuth) {
    this._httpAuth.internalValue = value;
  }
  public resetHttpAuth() {
    this._httpAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpAuthInput() {
    return this._httpAuth.internalValue;
  }

  // http_basic_auth - computed: false, optional: true, required: false
  private _httpBasicAuth = new ResourceHttpBasicAuthOutputReference(this, "http_basic_auth");
  public get httpBasicAuth() {
    return this._httpBasicAuth;
  }
  public putHttpBasicAuth(value: ResourceHttpBasicAuth) {
    this._httpBasicAuth.internalValue = value;
  }
  public resetHttpBasicAuth() {
    this._httpBasicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpBasicAuthInput() {
    return this._httpBasicAuth.internalValue;
  }

  // http_no_auth - computed: false, optional: true, required: false
  private _httpNoAuth = new ResourceHttpNoAuthOutputReference(this, "http_no_auth");
  public get httpNoAuth() {
    return this._httpNoAuth;
  }
  public putHttpNoAuth(value: ResourceHttpNoAuth) {
    this._httpNoAuth.internalValue = value;
  }
  public resetHttpNoAuth() {
    this._httpNoAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpNoAuthInput() {
    return this._httpNoAuth.internalValue;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new ResourceKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: ResourceKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // kubernetes_basic_auth - computed: false, optional: true, required: false
  private _kubernetesBasicAuth = new ResourceKubernetesBasicAuthOutputReference(this, "kubernetes_basic_auth");
  public get kubernetesBasicAuth() {
    return this._kubernetesBasicAuth;
  }
  public putKubernetesBasicAuth(value: ResourceKubernetesBasicAuth) {
    this._kubernetesBasicAuth.internalValue = value;
  }
  public resetKubernetesBasicAuth() {
    this._kubernetesBasicAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesBasicAuthInput() {
    return this._kubernetesBasicAuth.internalValue;
  }

  // kubernetes_pod_identity - computed: false, optional: true, required: false
  private _kubernetesPodIdentity = new ResourceKubernetesPodIdentityOutputReference(this, "kubernetes_pod_identity");
  public get kubernetesPodIdentity() {
    return this._kubernetesPodIdentity;
  }
  public putKubernetesPodIdentity(value: ResourceKubernetesPodIdentity) {
    this._kubernetesPodIdentity.internalValue = value;
  }
  public resetKubernetesPodIdentity() {
    this._kubernetesPodIdentity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesPodIdentityInput() {
    return this._kubernetesPodIdentity.internalValue;
  }

  // kubernetes_service_account - computed: false, optional: true, required: false
  private _kubernetesServiceAccount = new ResourceKubernetesServiceAccountOutputReference(this, "kubernetes_service_account");
  public get kubernetesServiceAccount() {
    return this._kubernetesServiceAccount;
  }
  public putKubernetesServiceAccount(value: ResourceKubernetesServiceAccount) {
    this._kubernetesServiceAccount.internalValue = value;
  }
  public resetKubernetesServiceAccount() {
    this._kubernetesServiceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesServiceAccountInput() {
    return this._kubernetesServiceAccount.internalValue;
  }

  // kubernetes_service_account_user_impersonation - computed: false, optional: true, required: false
  private _kubernetesServiceAccountUserImpersonation = new ResourceKubernetesServiceAccountUserImpersonationOutputReference(this, "kubernetes_service_account_user_impersonation");
  public get kubernetesServiceAccountUserImpersonation() {
    return this._kubernetesServiceAccountUserImpersonation;
  }
  public putKubernetesServiceAccountUserImpersonation(value: ResourceKubernetesServiceAccountUserImpersonation) {
    this._kubernetesServiceAccountUserImpersonation.internalValue = value;
  }
  public resetKubernetesServiceAccountUserImpersonation() {
    this._kubernetesServiceAccountUserImpersonation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesServiceAccountUserImpersonationInput() {
    return this._kubernetesServiceAccountUserImpersonation.internalValue;
  }

  // kubernetes_user_impersonation - computed: false, optional: true, required: false
  private _kubernetesUserImpersonation = new ResourceKubernetesUserImpersonationOutputReference(this, "kubernetes_user_impersonation");
  public get kubernetesUserImpersonation() {
    return this._kubernetesUserImpersonation;
  }
  public putKubernetesUserImpersonation(value: ResourceKubernetesUserImpersonation) {
    this._kubernetesUserImpersonation.internalValue = value;
  }
  public resetKubernetesUserImpersonation() {
    this._kubernetesUserImpersonation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesUserImpersonationInput() {
    return this._kubernetesUserImpersonation.internalValue;
  }

  // maria - computed: false, optional: true, required: false
  private _maria = new ResourceMariaOutputReference(this, "maria");
  public get maria() {
    return this._maria;
  }
  public putMaria(value: ResourceMaria) {
    this._maria.internalValue = value;
  }
  public resetMaria() {
    this._maria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mariaInput() {
    return this._maria.internalValue;
  }

  // mcp - computed: false, optional: true, required: false
  private _mcp = new ResourceMcpOutputReference(this, "mcp");
  public get mcp() {
    return this._mcp;
  }
  public putMcp(value: ResourceMcp) {
    this._mcp.internalValue = value;
  }
  public resetMcp() {
    this._mcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mcpInput() {
    return this._mcp.internalValue;
  }

  // memcached - computed: false, optional: true, required: false
  private _memcached = new ResourceMemcachedOutputReference(this, "memcached");
  public get memcached() {
    return this._memcached;
  }
  public putMemcached(value: ResourceMemcached) {
    this._memcached.internalValue = value;
  }
  public resetMemcached() {
    this._memcached.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memcachedInput() {
    return this._memcached.internalValue;
  }

  // memsql - computed: false, optional: true, required: false
  private _memsql = new ResourceMemsqlOutputReference(this, "memsql");
  public get memsql() {
    return this._memsql;
  }
  public putMemsql(value: ResourceMemsql) {
    this._memsql.internalValue = value;
  }
  public resetMemsql() {
    this._memsql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memsqlInput() {
    return this._memsql.internalValue;
  }

  // mongo_host - computed: false, optional: true, required: false
  private _mongoHost = new ResourceMongoHostOutputReference(this, "mongo_host");
  public get mongoHost() {
    return this._mongoHost;
  }
  public putMongoHost(value: ResourceMongoHost) {
    this._mongoHost.internalValue = value;
  }
  public resetMongoHost() {
    this._mongoHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mongoHostInput() {
    return this._mongoHost.internalValue;
  }

  // mongo_legacy_host - computed: false, optional: true, required: false
  private _mongoLegacyHost = new ResourceMongoLegacyHostOutputReference(this, "mongo_legacy_host");
  public get mongoLegacyHost() {
    return this._mongoLegacyHost;
  }
  public putMongoLegacyHost(value: ResourceMongoLegacyHost) {
    this._mongoLegacyHost.internalValue = value;
  }
  public resetMongoLegacyHost() {
    this._mongoLegacyHost.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mongoLegacyHostInput() {
    return this._mongoLegacyHost.internalValue;
  }

  // mongo_legacy_replicaset - computed: false, optional: true, required: false
  private _mongoLegacyReplicaset = new ResourceMongoLegacyReplicasetOutputReference(this, "mongo_legacy_replicaset");
  public get mongoLegacyReplicaset() {
    return this._mongoLegacyReplicaset;
  }
  public putMongoLegacyReplicaset(value: ResourceMongoLegacyReplicaset) {
    this._mongoLegacyReplicaset.internalValue = value;
  }
  public resetMongoLegacyReplicaset() {
    this._mongoLegacyReplicaset.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mongoLegacyReplicasetInput() {
    return this._mongoLegacyReplicaset.internalValue;
  }

  // mongo_replica_set - computed: false, optional: true, required: false
  private _mongoReplicaSet = new ResourceMongoReplicaSetOutputReference(this, "mongo_replica_set");
  public get mongoReplicaSet() {
    return this._mongoReplicaSet;
  }
  public putMongoReplicaSet(value: ResourceMongoReplicaSet) {
    this._mongoReplicaSet.internalValue = value;
  }
  public resetMongoReplicaSet() {
    this._mongoReplicaSet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mongoReplicaSetInput() {
    return this._mongoReplicaSet.internalValue;
  }

  // mongo_sharded_cluster - computed: false, optional: true, required: false
  private _mongoShardedCluster = new ResourceMongoShardedClusterOutputReference(this, "mongo_sharded_cluster");
  public get mongoShardedCluster() {
    return this._mongoShardedCluster;
  }
  public putMongoShardedCluster(value: ResourceMongoShardedCluster) {
    this._mongoShardedCluster.internalValue = value;
  }
  public resetMongoShardedCluster() {
    this._mongoShardedCluster.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mongoShardedClusterInput() {
    return this._mongoShardedCluster.internalValue;
  }

  // mtls_mysql - computed: false, optional: true, required: false
  private _mtlsMysql = new ResourceMtlsMysqlOutputReference(this, "mtls_mysql");
  public get mtlsMysql() {
    return this._mtlsMysql;
  }
  public putMtlsMysql(value: ResourceMtlsMysql) {
    this._mtlsMysql.internalValue = value;
  }
  public resetMtlsMysql() {
    this._mtlsMysql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtlsMysqlInput() {
    return this._mtlsMysql.internalValue;
  }

  // mtls_postgres - computed: false, optional: true, required: false
  private _mtlsPostgres = new ResourceMtlsPostgresOutputReference(this, "mtls_postgres");
  public get mtlsPostgres() {
    return this._mtlsPostgres;
  }
  public putMtlsPostgres(value: ResourceMtlsPostgres) {
    this._mtlsPostgres.internalValue = value;
  }
  public resetMtlsPostgres() {
    this._mtlsPostgres.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtlsPostgresInput() {
    return this._mtlsPostgres.internalValue;
  }

  // mysql - computed: false, optional: true, required: false
  private _mysql = new ResourceMysqlOutputReference(this, "mysql");
  public get mysql() {
    return this._mysql;
  }
  public putMysql(value: ResourceMysql) {
    this._mysql.internalValue = value;
  }
  public resetMysql() {
    this._mysql.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mysqlInput() {
    return this._mysql.internalValue;
  }

  // neptune - computed: false, optional: true, required: false
  private _neptune = new ResourceNeptuneOutputReference(this, "neptune");
  public get neptune() {
    return this._neptune;
  }
  public putNeptune(value: ResourceNeptune) {
    this._neptune.internalValue = value;
  }
  public resetNeptune() {
    this._neptune.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get neptuneInput() {
    return this._neptune.internalValue;
  }

  // neptune_iam - computed: false, optional: true, required: false
  private _neptuneIam = new ResourceNeptuneIamOutputReference(this, "neptune_iam");
  public get neptuneIam() {
    return this._neptuneIam;
  }
  public putNeptuneIam(value: ResourceNeptuneIam) {
    this._neptuneIam.internalValue = value;
  }
  public resetNeptuneIam() {
    this._neptuneIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get neptuneIamInput() {
    return this._neptuneIam.internalValue;
  }

  // oracle - computed: false, optional: true, required: false
  private _oracle = new ResourceOracleOutputReference(this, "oracle");
  public get oracle() {
    return this._oracle;
  }
  public putOracle(value: ResourceOracle) {
    this._oracle.internalValue = value;
  }
  public resetOracle() {
    this._oracle.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oracleInput() {
    return this._oracle.internalValue;
  }

  // oracle_nne - computed: false, optional: true, required: false
  private _oracleNne = new ResourceOracleNneOutputReference(this, "oracle_nne");
  public get oracleNne() {
    return this._oracleNne;
  }
  public putOracleNne(value: ResourceOracleNne) {
    this._oracleNne.internalValue = value;
  }
  public resetOracleNne() {
    this._oracleNne.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oracleNneInput() {
    return this._oracleNne.internalValue;
  }

  // postgres - computed: false, optional: true, required: false
  private _postgres = new ResourcePostgresOutputReference(this, "postgres");
  public get postgres() {
    return this._postgres;
  }
  public putPostgres(value: ResourcePostgres) {
    this._postgres.internalValue = value;
  }
  public resetPostgres() {
    this._postgres.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresInput() {
    return this._postgres.internalValue;
  }

  // presto - computed: false, optional: true, required: false
  private _presto = new ResourcePrestoOutputReference(this, "presto");
  public get presto() {
    return this._presto;
  }
  public putPresto(value: ResourcePresto) {
    this._presto.internalValue = value;
  }
  public resetPresto() {
    this._presto.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prestoInput() {
    return this._presto.internalValue;
  }

  // rabbitmq_amqp_091 - computed: false, optional: true, required: false
  private _rabbitmqAmqp091 = new ResourceRabbitmqAmqp091OutputReference(this, "rabbitmq_amqp_091");
  public get rabbitmqAmqp091() {
    return this._rabbitmqAmqp091;
  }
  public putRabbitmqAmqp091(value: ResourceRabbitmqAmqp091) {
    this._rabbitmqAmqp091.internalValue = value;
  }
  public resetRabbitmqAmqp091() {
    this._rabbitmqAmqp091.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rabbitmqAmqp091Input() {
    return this._rabbitmqAmqp091.internalValue;
  }

  // raw_tcp - computed: false, optional: true, required: false
  private _rawTcp = new ResourceRawTcpOutputReference(this, "raw_tcp");
  public get rawTcp() {
    return this._rawTcp;
  }
  public putRawTcp(value: ResourceRawTcp) {
    this._rawTcp.internalValue = value;
  }
  public resetRawTcp() {
    this._rawTcp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rawTcpInput() {
    return this._rawTcp.internalValue;
  }

  // rdp - computed: false, optional: true, required: false
  private _rdp = new ResourceRdpOutputReference(this, "rdp");
  public get rdp() {
    return this._rdp;
  }
  public putRdp(value: ResourceRdp) {
    this._rdp.internalValue = value;
  }
  public resetRdp() {
    this._rdp.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rdpInput() {
    return this._rdp.internalValue;
  }

  // rdp_cert - computed: false, optional: true, required: false
  private _rdpCert = new ResourceRdpCertOutputReference(this, "rdp_cert");
  public get rdpCert() {
    return this._rdpCert;
  }
  public putRdpCert(value: ResourceRdpCert) {
    this._rdpCert.internalValue = value;
  }
  public resetRdpCert() {
    this._rdpCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rdpCertInput() {
    return this._rdpCert.internalValue;
  }

  // rds_postgres_iam - computed: false, optional: true, required: false
  private _rdsPostgresIam = new ResourceRdsPostgresIamOutputReference(this, "rds_postgres_iam");
  public get rdsPostgresIam() {
    return this._rdsPostgresIam;
  }
  public putRdsPostgresIam(value: ResourceRdsPostgresIam) {
    this._rdsPostgresIam.internalValue = value;
  }
  public resetRdsPostgresIam() {
    this._rdsPostgresIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rdsPostgresIamInput() {
    return this._rdsPostgresIam.internalValue;
  }

  // redis - computed: false, optional: true, required: false
  private _redis = new ResourceRedisOutputReference(this, "redis");
  public get redis() {
    return this._redis;
  }
  public putRedis(value: ResourceRedis) {
    this._redis.internalValue = value;
  }
  public resetRedis() {
    this._redis.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redisInput() {
    return this._redis.internalValue;
  }

  // redis_cluster - computed: false, optional: true, required: false
  private _redisCluster = new ResourceRedisClusterOutputReference(this, "redis_cluster");
  public get redisCluster() {
    return this._redisCluster;
  }
  public putRedisCluster(value: ResourceRedisCluster) {
    this._redisCluster.internalValue = value;
  }
  public resetRedisCluster() {
    this._redisCluster.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redisClusterInput() {
    return this._redisCluster.internalValue;
  }

  // redshift - computed: false, optional: true, required: false
  private _redshift = new ResourceRedshiftOutputReference(this, "redshift");
  public get redshift() {
    return this._redshift;
  }
  public putRedshift(value: ResourceRedshift) {
    this._redshift.internalValue = value;
  }
  public resetRedshift() {
    this._redshift.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redshiftInput() {
    return this._redshift.internalValue;
  }

  // redshift_iam - computed: false, optional: true, required: false
  private _redshiftIam = new ResourceRedshiftIamOutputReference(this, "redshift_iam");
  public get redshiftIam() {
    return this._redshiftIam;
  }
  public putRedshiftIam(value: ResourceRedshiftIam) {
    this._redshiftIam.internalValue = value;
  }
  public resetRedshiftIam() {
    this._redshiftIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redshiftIamInput() {
    return this._redshiftIam.internalValue;
  }

  // redshift_serverless_iam - computed: false, optional: true, required: false
  private _redshiftServerlessIam = new ResourceRedshiftServerlessIamOutputReference(this, "redshift_serverless_iam");
  public get redshiftServerlessIam() {
    return this._redshiftServerlessIam;
  }
  public putRedshiftServerlessIam(value: ResourceRedshiftServerlessIam) {
    this._redshiftServerlessIam.internalValue = value;
  }
  public resetRedshiftServerlessIam() {
    this._redshiftServerlessIam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redshiftServerlessIamInput() {
    return this._redshiftServerlessIam.internalValue;
  }

  // single_store - computed: false, optional: true, required: false
  private _singleStore = new ResourceSingleStoreOutputReference(this, "single_store");
  public get singleStore() {
    return this._singleStore;
  }
  public putSingleStore(value: ResourceSingleStore) {
    this._singleStore.internalValue = value;
  }
  public resetSingleStore() {
    this._singleStore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleStoreInput() {
    return this._singleStore.internalValue;
  }

  // snowflake - computed: false, optional: true, required: false
  private _snowflake = new ResourceSnowflakeOutputReference(this, "snowflake");
  public get snowflake() {
    return this._snowflake;
  }
  public putSnowflake(value: ResourceSnowflake) {
    this._snowflake.internalValue = value;
  }
  public resetSnowflake() {
    this._snowflake.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snowflakeInput() {
    return this._snowflake.internalValue;
  }

  // snowsight - computed: false, optional: true, required: false
  private _snowsight = new ResourceSnowsightOutputReference(this, "snowsight");
  public get snowsight() {
    return this._snowsight;
  }
  public putSnowsight(value: ResourceSnowsight) {
    this._snowsight.internalValue = value;
  }
  public resetSnowsight() {
    this._snowsight.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get snowsightInput() {
    return this._snowsight.internalValue;
  }

  // sql_server - computed: false, optional: true, required: false
  private _sqlServer = new ResourceSqlServerOutputReference(this, "sql_server");
  public get sqlServer() {
    return this._sqlServer;
  }
  public putSqlServer(value: ResourceSqlServer) {
    this._sqlServer.internalValue = value;
  }
  public resetSqlServer() {
    this._sqlServer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlServerInput() {
    return this._sqlServer.internalValue;
  }

  // sql_server_azure_ad - computed: false, optional: true, required: false
  private _sqlServerAzureAd = new ResourceSqlServerAzureAdOutputReference(this, "sql_server_azure_ad");
  public get sqlServerAzureAd() {
    return this._sqlServerAzureAd;
  }
  public putSqlServerAzureAd(value: ResourceSqlServerAzureAd) {
    this._sqlServerAzureAd.internalValue = value;
  }
  public resetSqlServerAzureAd() {
    this._sqlServerAzureAd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlServerAzureAdInput() {
    return this._sqlServerAzureAd.internalValue;
  }

  // sql_server_kerberos_ad - computed: false, optional: true, required: false
  private _sqlServerKerberosAd = new ResourceSqlServerKerberosAdOutputReference(this, "sql_server_kerberos_ad");
  public get sqlServerKerberosAd() {
    return this._sqlServerKerberosAd;
  }
  public putSqlServerKerberosAd(value: ResourceSqlServerKerberosAd) {
    this._sqlServerKerberosAd.internalValue = value;
  }
  public resetSqlServerKerberosAd() {
    this._sqlServerKerberosAd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlServerKerberosAdInput() {
    return this._sqlServerKerberosAd.internalValue;
  }

  // ssh - computed: false, optional: true, required: false
  private _ssh = new ResourceSshOutputReference(this, "ssh");
  public get ssh() {
    return this._ssh;
  }
  public putSsh(value: ResourceSsh) {
    this._ssh.internalValue = value;
  }
  public resetSsh() {
    this._ssh.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshInput() {
    return this._ssh.internalValue;
  }

  // ssh_cert - computed: false, optional: true, required: false
  private _sshCert = new ResourceSshCertOutputReference(this, "ssh_cert");
  public get sshCert() {
    return this._sshCert;
  }
  public putSshCert(value: ResourceSshCert) {
    this._sshCert.internalValue = value;
  }
  public resetSshCert() {
    this._sshCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshCertInput() {
    return this._sshCert.internalValue;
  }

  // ssh_customer_key - computed: false, optional: true, required: false
  private _sshCustomerKey = new ResourceSshCustomerKeyOutputReference(this, "ssh_customer_key");
  public get sshCustomerKey() {
    return this._sshCustomerKey;
  }
  public putSshCustomerKey(value: ResourceSshCustomerKey) {
    this._sshCustomerKey.internalValue = value;
  }
  public resetSshCustomerKey() {
    this._sshCustomerKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshCustomerKeyInput() {
    return this._sshCustomerKey.internalValue;
  }

  // ssh_password - computed: false, optional: true, required: false
  private _sshPassword = new ResourceSshPasswordOutputReference(this, "ssh_password");
  public get sshPassword() {
    return this._sshPassword;
  }
  public putSshPassword(value: ResourceSshPassword) {
    this._sshPassword.internalValue = value;
  }
  public resetSshPassword() {
    this._sshPassword.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sshPasswordInput() {
    return this._sshPassword.internalValue;
  }

  // sybase - computed: false, optional: true, required: false
  private _sybase = new ResourceSybaseOutputReference(this, "sybase");
  public get sybase() {
    return this._sybase;
  }
  public putSybase(value: ResourceSybase) {
    this._sybase.internalValue = value;
  }
  public resetSybase() {
    this._sybase.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sybaseInput() {
    return this._sybase.internalValue;
  }

  // sybase_iq - computed: false, optional: true, required: false
  private _sybaseIq = new ResourceSybaseIqOutputReference(this, "sybase_iq");
  public get sybaseIq() {
    return this._sybaseIq;
  }
  public putSybaseIq(value: ResourceSybaseIq) {
    this._sybaseIq.internalValue = value;
  }
  public resetSybaseIq() {
    this._sybaseIq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sybaseIqInput() {
    return this._sybaseIq.internalValue;
  }

  // teradata - computed: false, optional: true, required: false
  private _teradata = new ResourceTeradataOutputReference(this, "teradata");
  public get teradata() {
    return this._teradata;
  }
  public putTeradata(value: ResourceTeradata) {
    this._teradata.internalValue = value;
  }
  public resetTeradata() {
    this._teradata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get teradataInput() {
    return this._teradata.internalValue;
  }

  // timeouts - computed: false, optional: true, required: false
  private _timeouts = new ResourceTimeoutsOutputReference(this, "timeouts");
  public get timeouts() {
    return this._timeouts;
  }
  public putTimeouts(value: ResourceTimeouts) {
    this._timeouts.internalValue = value;
  }
  public resetTimeouts() {
    this._timeouts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutsInput() {
    return this._timeouts.internalValue;
  }

  // trino - computed: false, optional: true, required: false
  private _trino = new ResourceTrinoOutputReference(this, "trino");
  public get trino() {
    return this._trino;
  }
  public putTrino(value: ResourceTrino) {
    this._trino.internalValue = value;
  }
  public resetTrino() {
    this._trino.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trinoInput() {
    return this._trino.internalValue;
  }

  // vertica - computed: false, optional: true, required: false
  private _vertica = new ResourceVerticaOutputReference(this, "vertica");
  public get vertica() {
    return this._vertica;
  }
  public putVertica(value: ResourceVertica) {
    this._vertica.internalValue = value;
  }
  public resetVertica() {
    this._vertica.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verticaInput() {
    return this._vertica.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      id: cdktf.stringToTerraform(this._id),
      aerospike: resourceAerospikeToTerraform(this._aerospike.internalValue),
      aks: resourceAksToTerraform(this._aks.internalValue),
      aks_basic_auth: resourceAksBasicAuthToTerraform(this._aksBasicAuth.internalValue),
      aks_service_account: resourceAksServiceAccountToTerraform(this._aksServiceAccount.internalValue),
      aks_service_account_user_impersonation: resourceAksServiceAccountUserImpersonationToTerraform(this._aksServiceAccountUserImpersonation.internalValue),
      aks_user_impersonation: resourceAksUserImpersonationToTerraform(this._aksUserImpersonation.internalValue),
      amazon_eks: resourceAmazonEksToTerraform(this._amazonEks.internalValue),
      amazon_eks_instance_profile: resourceAmazonEksInstanceProfileToTerraform(this._amazonEksInstanceProfile.internalValue),
      amazon_eks_instance_profile_user_impersonation: resourceAmazonEksInstanceProfileUserImpersonationToTerraform(this._amazonEksInstanceProfileUserImpersonation.internalValue),
      amazon_eks_user_impersonation: resourceAmazonEksUserImpersonationToTerraform(this._amazonEksUserImpersonation.internalValue),
      amazon_es: resourceAmazonEsToTerraform(this._amazonEs.internalValue),
      amazon_esiam: resourceAmazonEsiamToTerraform(this._amazonEsiam.internalValue),
      amazonmq_amqp: resourceAmazonmqAmqpToTerraform(this._amazonmqAmqp.internalValue),
      amazonmq_amqp_091: resourceAmazonmqAmqp091ToTerraform(this._amazonmqAmqp091.internalValue),
      athena: resourceAthenaToTerraform(this._athena.internalValue),
      athena_iam: resourceAthenaIamToTerraform(this._athenaIam.internalValue),
      aurora_mysql: resourceAuroraMysqlToTerraform(this._auroraMysql.internalValue),
      aurora_mysql_iam: resourceAuroraMysqlIamToTerraform(this._auroraMysqlIam.internalValue),
      aurora_postgres: resourceAuroraPostgresToTerraform(this._auroraPostgres.internalValue),
      aurora_postgres_iam: resourceAuroraPostgresIamToTerraform(this._auroraPostgresIam.internalValue),
      aws: resourceAwsToTerraform(this._aws.internalValue),
      aws_console: resourceAwsConsoleToTerraform(this._awsConsole.internalValue),
      aws_console_static_key_pair: resourceAwsConsoleStaticKeyPairToTerraform(this._awsConsoleStaticKeyPair.internalValue),
      aws_instance_profile: resourceAwsInstanceProfileToTerraform(this._awsInstanceProfile.internalValue),
      azure: resourceAzureToTerraform(this._azure.internalValue),
      azure_certificate: resourceAzureCertificateToTerraform(this._azureCertificate.internalValue),
      azure_mysql: resourceAzureMysqlToTerraform(this._azureMysql.internalValue),
      azure_mysql_managed_identity: resourceAzureMysqlManagedIdentityToTerraform(this._azureMysqlManagedIdentity.internalValue),
      azure_postgres: resourceAzurePostgresToTerraform(this._azurePostgres.internalValue),
      azure_postgres_managed_identity: resourceAzurePostgresManagedIdentityToTerraform(this._azurePostgresManagedIdentity.internalValue),
      big_query: resourceBigQueryToTerraform(this._bigQuery.internalValue),
      cassandra: resourceCassandraToTerraform(this._cassandra.internalValue),
      citus: resourceCitusToTerraform(this._citus.internalValue),
      click_house_http: resourceClickHouseHttpToTerraform(this._clickHouseHttp.internalValue),
      click_house_my_sql: resourceClickHouseMySqlToTerraform(this._clickHouseMySql.internalValue),
      click_house_tcp: resourceClickHouseTcpToTerraform(this._clickHouseTcp.internalValue),
      clustrix: resourceClustrixToTerraform(this._clustrix.internalValue),
      cockroach: resourceCockroachToTerraform(this._cockroach.internalValue),
      couchbase_database: resourceCouchbaseDatabaseToTerraform(this._couchbaseDatabase.internalValue),
      couchbase_web_ui: resourceCouchbaseWebUiToTerraform(this._couchbaseWebUi.internalValue),
      db_2_i: resourceDb2IToTerraform(this._db2I.internalValue),
      db_2_luw: resourceDb2LuwToTerraform(this._db2Luw.internalValue),
      document_db_host: resourceDocumentDbHostToTerraform(this._documentDbHost.internalValue),
      document_db_host_iam: resourceDocumentDbHostIamToTerraform(this._documentDbHostIam.internalValue),
      document_db_replica_set: resourceDocumentDbReplicaSetToTerraform(this._documentDbReplicaSet.internalValue),
      document_db_replica_set_iam: resourceDocumentDbReplicaSetIamToTerraform(this._documentDbReplicaSetIam.internalValue),
      druid: resourceDruidToTerraform(this._druid.internalValue),
      dynamo_db: resourceDynamoDbToTerraform(this._dynamoDb.internalValue),
      dynamo_dbiam: resourceDynamoDbiamToTerraform(this._dynamoDbiam.internalValue),
      elastic: resourceElasticToTerraform(this._elastic.internalValue),
      elasticache_redis: resourceElasticacheRedisToTerraform(this._elasticacheRedis.internalValue),
      elasticache_redis_iam: resourceElasticacheRedisIamToTerraform(this._elasticacheRedisIam.internalValue),
      entra_id: resourceEntraIdToTerraform(this._entraId.internalValue),
      gcp: resourceGcpToTerraform(this._gcp.internalValue),
      gcp_console: resourceGcpConsoleToTerraform(this._gcpConsole.internalValue),
      gcpwif: resourceGcpwifToTerraform(this._gcpwif.internalValue),
      google_gke: resourceGoogleGkeToTerraform(this._googleGke.internalValue),
      google_gke_user_impersonation: resourceGoogleGkeUserImpersonationToTerraform(this._googleGkeUserImpersonation.internalValue),
      greenplum: resourceGreenplumToTerraform(this._greenplum.internalValue),
      http_auth: resourceHttpAuthToTerraform(this._httpAuth.internalValue),
      http_basic_auth: resourceHttpBasicAuthToTerraform(this._httpBasicAuth.internalValue),
      http_no_auth: resourceHttpNoAuthToTerraform(this._httpNoAuth.internalValue),
      kubernetes: resourceKubernetesToTerraform(this._kubernetes.internalValue),
      kubernetes_basic_auth: resourceKubernetesBasicAuthToTerraform(this._kubernetesBasicAuth.internalValue),
      kubernetes_pod_identity: resourceKubernetesPodIdentityToTerraform(this._kubernetesPodIdentity.internalValue),
      kubernetes_service_account: resourceKubernetesServiceAccountToTerraform(this._kubernetesServiceAccount.internalValue),
      kubernetes_service_account_user_impersonation: resourceKubernetesServiceAccountUserImpersonationToTerraform(this._kubernetesServiceAccountUserImpersonation.internalValue),
      kubernetes_user_impersonation: resourceKubernetesUserImpersonationToTerraform(this._kubernetesUserImpersonation.internalValue),
      maria: resourceMariaToTerraform(this._maria.internalValue),
      mcp: resourceMcpToTerraform(this._mcp.internalValue),
      memcached: resourceMemcachedToTerraform(this._memcached.internalValue),
      memsql: resourceMemsqlToTerraform(this._memsql.internalValue),
      mongo_host: resourceMongoHostToTerraform(this._mongoHost.internalValue),
      mongo_legacy_host: resourceMongoLegacyHostToTerraform(this._mongoLegacyHost.internalValue),
      mongo_legacy_replicaset: resourceMongoLegacyReplicasetToTerraform(this._mongoLegacyReplicaset.internalValue),
      mongo_replica_set: resourceMongoReplicaSetToTerraform(this._mongoReplicaSet.internalValue),
      mongo_sharded_cluster: resourceMongoShardedClusterToTerraform(this._mongoShardedCluster.internalValue),
      mtls_mysql: resourceMtlsMysqlToTerraform(this._mtlsMysql.internalValue),
      mtls_postgres: resourceMtlsPostgresToTerraform(this._mtlsPostgres.internalValue),
      mysql: resourceMysqlToTerraform(this._mysql.internalValue),
      neptune: resourceNeptuneToTerraform(this._neptune.internalValue),
      neptune_iam: resourceNeptuneIamToTerraform(this._neptuneIam.internalValue),
      oracle: resourceOracleToTerraform(this._oracle.internalValue),
      oracle_nne: resourceOracleNneToTerraform(this._oracleNne.internalValue),
      postgres: resourcePostgresToTerraform(this._postgres.internalValue),
      presto: resourcePrestoToTerraform(this._presto.internalValue),
      rabbitmq_amqp_091: resourceRabbitmqAmqp091ToTerraform(this._rabbitmqAmqp091.internalValue),
      raw_tcp: resourceRawTcpToTerraform(this._rawTcp.internalValue),
      rdp: resourceRdpToTerraform(this._rdp.internalValue),
      rdp_cert: resourceRdpCertToTerraform(this._rdpCert.internalValue),
      rds_postgres_iam: resourceRdsPostgresIamToTerraform(this._rdsPostgresIam.internalValue),
      redis: resourceRedisToTerraform(this._redis.internalValue),
      redis_cluster: resourceRedisClusterToTerraform(this._redisCluster.internalValue),
      redshift: resourceRedshiftToTerraform(this._redshift.internalValue),
      redshift_iam: resourceRedshiftIamToTerraform(this._redshiftIam.internalValue),
      redshift_serverless_iam: resourceRedshiftServerlessIamToTerraform(this._redshiftServerlessIam.internalValue),
      single_store: resourceSingleStoreToTerraform(this._singleStore.internalValue),
      snowflake: resourceSnowflakeToTerraform(this._snowflake.internalValue),
      snowsight: resourceSnowsightToTerraform(this._snowsight.internalValue),
      sql_server: resourceSqlServerToTerraform(this._sqlServer.internalValue),
      sql_server_azure_ad: resourceSqlServerAzureAdToTerraform(this._sqlServerAzureAd.internalValue),
      sql_server_kerberos_ad: resourceSqlServerKerberosAdToTerraform(this._sqlServerKerberosAd.internalValue),
      ssh: resourceSshToTerraform(this._ssh.internalValue),
      ssh_cert: resourceSshCertToTerraform(this._sshCert.internalValue),
      ssh_customer_key: resourceSshCustomerKeyToTerraform(this._sshCustomerKey.internalValue),
      ssh_password: resourceSshPasswordToTerraform(this._sshPassword.internalValue),
      sybase: resourceSybaseToTerraform(this._sybase.internalValue),
      sybase_iq: resourceSybaseIqToTerraform(this._sybaseIq.internalValue),
      teradata: resourceTeradataToTerraform(this._teradata.internalValue),
      timeouts: resourceTimeoutsToTerraform(this._timeouts.internalValue),
      trino: resourceTrinoToTerraform(this._trino.internalValue),
      vertica: resourceVerticaToTerraform(this._vertica.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      id: {
        value: cdktf.stringToHclTerraform(this._id),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      aerospike: {
        value: resourceAerospikeToHclTerraform(this._aerospike.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAerospikeList",
      },
      aks: {
        value: resourceAksToHclTerraform(this._aks.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAksList",
      },
      aks_basic_auth: {
        value: resourceAksBasicAuthToHclTerraform(this._aksBasicAuth.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAksBasicAuthList",
      },
      aks_service_account: {
        value: resourceAksServiceAccountToHclTerraform(this._aksServiceAccount.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAksServiceAccountList",
      },
      aks_service_account_user_impersonation: {
        value: resourceAksServiceAccountUserImpersonationToHclTerraform(this._aksServiceAccountUserImpersonation.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAksServiceAccountUserImpersonationList",
      },
      aks_user_impersonation: {
        value: resourceAksUserImpersonationToHclTerraform(this._aksUserImpersonation.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAksUserImpersonationList",
      },
      amazon_eks: {
        value: resourceAmazonEksToHclTerraform(this._amazonEks.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAmazonEksList",
      },
      amazon_eks_instance_profile: {
        value: resourceAmazonEksInstanceProfileToHclTerraform(this._amazonEksInstanceProfile.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAmazonEksInstanceProfileList",
      },
      amazon_eks_instance_profile_user_impersonation: {
        value: resourceAmazonEksInstanceProfileUserImpersonationToHclTerraform(this._amazonEksInstanceProfileUserImpersonation.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAmazonEksInstanceProfileUserImpersonationList",
      },
      amazon_eks_user_impersonation: {
        value: resourceAmazonEksUserImpersonationToHclTerraform(this._amazonEksUserImpersonation.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAmazonEksUserImpersonationList",
      },
      amazon_es: {
        value: resourceAmazonEsToHclTerraform(this._amazonEs.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAmazonEsList",
      },
      amazon_esiam: {
        value: resourceAmazonEsiamToHclTerraform(this._amazonEsiam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAmazonEsiamList",
      },
      amazonmq_amqp: {
        value: resourceAmazonmqAmqpToHclTerraform(this._amazonmqAmqp.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAmazonmqAmqpList",
      },
      amazonmq_amqp_091: {
        value: resourceAmazonmqAmqp091ToHclTerraform(this._amazonmqAmqp091.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAmazonmqAmqp091List",
      },
      athena: {
        value: resourceAthenaToHclTerraform(this._athena.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAthenaList",
      },
      athena_iam: {
        value: resourceAthenaIamToHclTerraform(this._athenaIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAthenaIamList",
      },
      aurora_mysql: {
        value: resourceAuroraMysqlToHclTerraform(this._auroraMysql.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAuroraMysqlList",
      },
      aurora_mysql_iam: {
        value: resourceAuroraMysqlIamToHclTerraform(this._auroraMysqlIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAuroraMysqlIamList",
      },
      aurora_postgres: {
        value: resourceAuroraPostgresToHclTerraform(this._auroraPostgres.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAuroraPostgresList",
      },
      aurora_postgres_iam: {
        value: resourceAuroraPostgresIamToHclTerraform(this._auroraPostgresIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAuroraPostgresIamList",
      },
      aws: {
        value: resourceAwsToHclTerraform(this._aws.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAwsList",
      },
      aws_console: {
        value: resourceAwsConsoleToHclTerraform(this._awsConsole.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAwsConsoleList",
      },
      aws_console_static_key_pair: {
        value: resourceAwsConsoleStaticKeyPairToHclTerraform(this._awsConsoleStaticKeyPair.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAwsConsoleStaticKeyPairList",
      },
      aws_instance_profile: {
        value: resourceAwsInstanceProfileToHclTerraform(this._awsInstanceProfile.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAwsInstanceProfileList",
      },
      azure: {
        value: resourceAzureToHclTerraform(this._azure.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAzureList",
      },
      azure_certificate: {
        value: resourceAzureCertificateToHclTerraform(this._azureCertificate.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAzureCertificateList",
      },
      azure_mysql: {
        value: resourceAzureMysqlToHclTerraform(this._azureMysql.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAzureMysqlList",
      },
      azure_mysql_managed_identity: {
        value: resourceAzureMysqlManagedIdentityToHclTerraform(this._azureMysqlManagedIdentity.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAzureMysqlManagedIdentityList",
      },
      azure_postgres: {
        value: resourceAzurePostgresToHclTerraform(this._azurePostgres.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAzurePostgresList",
      },
      azure_postgres_managed_identity: {
        value: resourceAzurePostgresManagedIdentityToHclTerraform(this._azurePostgresManagedIdentity.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceAzurePostgresManagedIdentityList",
      },
      big_query: {
        value: resourceBigQueryToHclTerraform(this._bigQuery.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceBigQueryList",
      },
      cassandra: {
        value: resourceCassandraToHclTerraform(this._cassandra.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceCassandraList",
      },
      citus: {
        value: resourceCitusToHclTerraform(this._citus.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceCitusList",
      },
      click_house_http: {
        value: resourceClickHouseHttpToHclTerraform(this._clickHouseHttp.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceClickHouseHttpList",
      },
      click_house_my_sql: {
        value: resourceClickHouseMySqlToHclTerraform(this._clickHouseMySql.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceClickHouseMySqlList",
      },
      click_house_tcp: {
        value: resourceClickHouseTcpToHclTerraform(this._clickHouseTcp.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceClickHouseTcpList",
      },
      clustrix: {
        value: resourceClustrixToHclTerraform(this._clustrix.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceClustrixList",
      },
      cockroach: {
        value: resourceCockroachToHclTerraform(this._cockroach.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceCockroachList",
      },
      couchbase_database: {
        value: resourceCouchbaseDatabaseToHclTerraform(this._couchbaseDatabase.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceCouchbaseDatabaseList",
      },
      couchbase_web_ui: {
        value: resourceCouchbaseWebUiToHclTerraform(this._couchbaseWebUi.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceCouchbaseWebUiList",
      },
      db_2_i: {
        value: resourceDb2IToHclTerraform(this._db2I.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDb2IList",
      },
      db_2_luw: {
        value: resourceDb2LuwToHclTerraform(this._db2Luw.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDb2LuwList",
      },
      document_db_host: {
        value: resourceDocumentDbHostToHclTerraform(this._documentDbHost.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDocumentDbHostList",
      },
      document_db_host_iam: {
        value: resourceDocumentDbHostIamToHclTerraform(this._documentDbHostIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDocumentDbHostIamList",
      },
      document_db_replica_set: {
        value: resourceDocumentDbReplicaSetToHclTerraform(this._documentDbReplicaSet.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDocumentDbReplicaSetList",
      },
      document_db_replica_set_iam: {
        value: resourceDocumentDbReplicaSetIamToHclTerraform(this._documentDbReplicaSetIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDocumentDbReplicaSetIamList",
      },
      druid: {
        value: resourceDruidToHclTerraform(this._druid.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDruidList",
      },
      dynamo_db: {
        value: resourceDynamoDbToHclTerraform(this._dynamoDb.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDynamoDbList",
      },
      dynamo_dbiam: {
        value: resourceDynamoDbiamToHclTerraform(this._dynamoDbiam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceDynamoDbiamList",
      },
      elastic: {
        value: resourceElasticToHclTerraform(this._elastic.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceElasticList",
      },
      elasticache_redis: {
        value: resourceElasticacheRedisToHclTerraform(this._elasticacheRedis.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceElasticacheRedisList",
      },
      elasticache_redis_iam: {
        value: resourceElasticacheRedisIamToHclTerraform(this._elasticacheRedisIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceElasticacheRedisIamList",
      },
      entra_id: {
        value: resourceEntraIdToHclTerraform(this._entraId.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceEntraIdList",
      },
      gcp: {
        value: resourceGcpToHclTerraform(this._gcp.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceGcpList",
      },
      gcp_console: {
        value: resourceGcpConsoleToHclTerraform(this._gcpConsole.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceGcpConsoleList",
      },
      gcpwif: {
        value: resourceGcpwifToHclTerraform(this._gcpwif.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceGcpwifList",
      },
      google_gke: {
        value: resourceGoogleGkeToHclTerraform(this._googleGke.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceGoogleGkeList",
      },
      google_gke_user_impersonation: {
        value: resourceGoogleGkeUserImpersonationToHclTerraform(this._googleGkeUserImpersonation.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceGoogleGkeUserImpersonationList",
      },
      greenplum: {
        value: resourceGreenplumToHclTerraform(this._greenplum.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceGreenplumList",
      },
      http_auth: {
        value: resourceHttpAuthToHclTerraform(this._httpAuth.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceHttpAuthList",
      },
      http_basic_auth: {
        value: resourceHttpBasicAuthToHclTerraform(this._httpBasicAuth.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceHttpBasicAuthList",
      },
      http_no_auth: {
        value: resourceHttpNoAuthToHclTerraform(this._httpNoAuth.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceHttpNoAuthList",
      },
      kubernetes: {
        value: resourceKubernetesToHclTerraform(this._kubernetes.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceKubernetesList",
      },
      kubernetes_basic_auth: {
        value: resourceKubernetesBasicAuthToHclTerraform(this._kubernetesBasicAuth.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceKubernetesBasicAuthList",
      },
      kubernetes_pod_identity: {
        value: resourceKubernetesPodIdentityToHclTerraform(this._kubernetesPodIdentity.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceKubernetesPodIdentityList",
      },
      kubernetes_service_account: {
        value: resourceKubernetesServiceAccountToHclTerraform(this._kubernetesServiceAccount.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceKubernetesServiceAccountList",
      },
      kubernetes_service_account_user_impersonation: {
        value: resourceKubernetesServiceAccountUserImpersonationToHclTerraform(this._kubernetesServiceAccountUserImpersonation.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceKubernetesServiceAccountUserImpersonationList",
      },
      kubernetes_user_impersonation: {
        value: resourceKubernetesUserImpersonationToHclTerraform(this._kubernetesUserImpersonation.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceKubernetesUserImpersonationList",
      },
      maria: {
        value: resourceMariaToHclTerraform(this._maria.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMariaList",
      },
      mcp: {
        value: resourceMcpToHclTerraform(this._mcp.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMcpList",
      },
      memcached: {
        value: resourceMemcachedToHclTerraform(this._memcached.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMemcachedList",
      },
      memsql: {
        value: resourceMemsqlToHclTerraform(this._memsql.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMemsqlList",
      },
      mongo_host: {
        value: resourceMongoHostToHclTerraform(this._mongoHost.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMongoHostList",
      },
      mongo_legacy_host: {
        value: resourceMongoLegacyHostToHclTerraform(this._mongoLegacyHost.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMongoLegacyHostList",
      },
      mongo_legacy_replicaset: {
        value: resourceMongoLegacyReplicasetToHclTerraform(this._mongoLegacyReplicaset.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMongoLegacyReplicasetList",
      },
      mongo_replica_set: {
        value: resourceMongoReplicaSetToHclTerraform(this._mongoReplicaSet.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMongoReplicaSetList",
      },
      mongo_sharded_cluster: {
        value: resourceMongoShardedClusterToHclTerraform(this._mongoShardedCluster.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMongoShardedClusterList",
      },
      mtls_mysql: {
        value: resourceMtlsMysqlToHclTerraform(this._mtlsMysql.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMtlsMysqlList",
      },
      mtls_postgres: {
        value: resourceMtlsPostgresToHclTerraform(this._mtlsPostgres.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMtlsPostgresList",
      },
      mysql: {
        value: resourceMysqlToHclTerraform(this._mysql.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceMysqlList",
      },
      neptune: {
        value: resourceNeptuneToHclTerraform(this._neptune.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceNeptuneList",
      },
      neptune_iam: {
        value: resourceNeptuneIamToHclTerraform(this._neptuneIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceNeptuneIamList",
      },
      oracle: {
        value: resourceOracleToHclTerraform(this._oracle.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceOracleList",
      },
      oracle_nne: {
        value: resourceOracleNneToHclTerraform(this._oracleNne.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceOracleNneList",
      },
      postgres: {
        value: resourcePostgresToHclTerraform(this._postgres.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourcePostgresList",
      },
      presto: {
        value: resourcePrestoToHclTerraform(this._presto.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourcePrestoList",
      },
      rabbitmq_amqp_091: {
        value: resourceRabbitmqAmqp091ToHclTerraform(this._rabbitmqAmqp091.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRabbitmqAmqp091List",
      },
      raw_tcp: {
        value: resourceRawTcpToHclTerraform(this._rawTcp.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRawTcpList",
      },
      rdp: {
        value: resourceRdpToHclTerraform(this._rdp.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRdpList",
      },
      rdp_cert: {
        value: resourceRdpCertToHclTerraform(this._rdpCert.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRdpCertList",
      },
      rds_postgres_iam: {
        value: resourceRdsPostgresIamToHclTerraform(this._rdsPostgresIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRdsPostgresIamList",
      },
      redis: {
        value: resourceRedisToHclTerraform(this._redis.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRedisList",
      },
      redis_cluster: {
        value: resourceRedisClusterToHclTerraform(this._redisCluster.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRedisClusterList",
      },
      redshift: {
        value: resourceRedshiftToHclTerraform(this._redshift.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRedshiftList",
      },
      redshift_iam: {
        value: resourceRedshiftIamToHclTerraform(this._redshiftIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRedshiftIamList",
      },
      redshift_serverless_iam: {
        value: resourceRedshiftServerlessIamToHclTerraform(this._redshiftServerlessIam.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceRedshiftServerlessIamList",
      },
      single_store: {
        value: resourceSingleStoreToHclTerraform(this._singleStore.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSingleStoreList",
      },
      snowflake: {
        value: resourceSnowflakeToHclTerraform(this._snowflake.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSnowflakeList",
      },
      snowsight: {
        value: resourceSnowsightToHclTerraform(this._snowsight.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSnowsightList",
      },
      sql_server: {
        value: resourceSqlServerToHclTerraform(this._sqlServer.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSqlServerList",
      },
      sql_server_azure_ad: {
        value: resourceSqlServerAzureAdToHclTerraform(this._sqlServerAzureAd.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSqlServerAzureAdList",
      },
      sql_server_kerberos_ad: {
        value: resourceSqlServerKerberosAdToHclTerraform(this._sqlServerKerberosAd.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSqlServerKerberosAdList",
      },
      ssh: {
        value: resourceSshToHclTerraform(this._ssh.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSshList",
      },
      ssh_cert: {
        value: resourceSshCertToHclTerraform(this._sshCert.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSshCertList",
      },
      ssh_customer_key: {
        value: resourceSshCustomerKeyToHclTerraform(this._sshCustomerKey.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSshCustomerKeyList",
      },
      ssh_password: {
        value: resourceSshPasswordToHclTerraform(this._sshPassword.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSshPasswordList",
      },
      sybase: {
        value: resourceSybaseToHclTerraform(this._sybase.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSybaseList",
      },
      sybase_iq: {
        value: resourceSybaseIqToHclTerraform(this._sybaseIq.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceSybaseIqList",
      },
      teradata: {
        value: resourceTeradataToHclTerraform(this._teradata.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceTeradataList",
      },
      timeouts: {
        value: resourceTimeoutsToHclTerraform(this._timeouts.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "ResourceTimeouts",
      },
      trino: {
        value: resourceTrinoToHclTerraform(this._trino.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceTrinoList",
      },
      vertica: {
        value: resourceVerticaToHclTerraform(this._vertica.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "ResourceVerticaList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
