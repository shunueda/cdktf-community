import * as cdktf from 'cdktf';
export interface SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntities {
  /**
  * Entity description.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#entity_description SpIdpConnection#entity_description}
  */
  readonly entityDescription?: string;
  /**
  * Unique entity identifier.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#entity_id SpIdpConnection#entity_id}
  */
  readonly entityId?: string;
}

export function spIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesToTerraform(struct?: SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    entity_description: cdktf.stringToTerraform(struct!.entityDescription),
    entity_id: cdktf.stringToTerraform(struct!.entityId),
  }
}


export function spIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesToHclTerraform(struct?: SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntities | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    entity_description: {
      value: cdktf.stringToHclTerraform(struct!.entityDescription),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    entity_id: {
      value: cdktf.stringToHclTerraform(struct!.entityId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntities | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._entityDescription !== undefined) {
      hasAnyValues = true;
      internalValueResult.entityDescription = this._entityDescription;
    }
    if (this._entityId !== undefined) {
      hasAnyValues = true;
      internalValueResult.entityId = this._entityId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntities | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._entityDescription = undefined;
      this._entityId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._entityDescription = value.entityDescription;
      this._entityId = value.entityId;
    }
  }

  // entity_description - computed: true, optional: true, required: false
  private _entityDescription?: string; 
  public get entityDescription() {
    return this.getStringAttribute('entity_description');
  }
  public set entityDescription(value: string) {
    this._entityDescription = value;
  }
  public resetEntityDescription() {
    this._entityDescription = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entityDescriptionInput() {
    return this._entityDescription;
  }

  // entity_id - computed: true, optional: true, required: false
  private _entityId?: string; 
  public get entityId() {
    return this.getStringAttribute('entity_id');
  }
  public set entityId(value: string) {
    this._entityId = value;
  }
  public resetEntityId() {
    this._entityId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get entityIdInput() {
    return this._entityId;
  }
}

export class SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntities[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesOutputReference {
    return new SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionAdditionalAllowedEntitiesConfiguration {
  /**
  * An array of additional allowed entities or issuers to be accepted during entity or issuer validation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#additional_allowed_entities SpIdpConnection#additional_allowed_entities}
  */
  readonly additionalAllowedEntities?: SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntities[] | cdktf.IResolvable;
  /**
  * Set to true to configure additional entities or issuers to be accepted during entity or issuer validation. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#allow_additional_entities SpIdpConnection#allow_additional_entities}
  */
  readonly allowAdditionalEntities?: boolean | cdktf.IResolvable;
  /**
  * Set to true to accept any entity or issuer during entity or issuer validation. (Not Recommended). The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#allow_all_entities SpIdpConnection#allow_all_entities}
  */
  readonly allowAllEntities?: boolean | cdktf.IResolvable;
}

export function spIdpConnectionAdditionalAllowedEntitiesConfigurationToTerraform(struct?: SpIdpConnectionAdditionalAllowedEntitiesConfiguration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_allowed_entities: cdktf.listMapper(spIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesToTerraform, false)(struct!.additionalAllowedEntities),
    allow_additional_entities: cdktf.booleanToTerraform(struct!.allowAdditionalEntities),
    allow_all_entities: cdktf.booleanToTerraform(struct!.allowAllEntities),
  }
}


export function spIdpConnectionAdditionalAllowedEntitiesConfigurationToHclTerraform(struct?: SpIdpConnectionAdditionalAllowedEntitiesConfiguration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_allowed_entities: {
      value: cdktf.listMapperHcl(spIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesToHclTerraform, false)(struct!.additionalAllowedEntities),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesList",
    },
    allow_additional_entities: {
      value: cdktf.booleanToHclTerraform(struct!.allowAdditionalEntities),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_all_entities: {
      value: cdktf.booleanToHclTerraform(struct!.allowAllEntities),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionAdditionalAllowedEntitiesConfigurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionAdditionalAllowedEntitiesConfiguration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalAllowedEntities?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalAllowedEntities = this._additionalAllowedEntities?.internalValue;
    }
    if (this._allowAdditionalEntities !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowAdditionalEntities = this._allowAdditionalEntities;
    }
    if (this._allowAllEntities !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowAllEntities = this._allowAllEntities;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionAdditionalAllowedEntitiesConfiguration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalAllowedEntities.internalValue = undefined;
      this._allowAdditionalEntities = undefined;
      this._allowAllEntities = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalAllowedEntities.internalValue = value.additionalAllowedEntities;
      this._allowAdditionalEntities = value.allowAdditionalEntities;
      this._allowAllEntities = value.allowAllEntities;
    }
  }

  // additional_allowed_entities - computed: true, optional: true, required: false
  private _additionalAllowedEntities = new SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntitiesList(this, "additional_allowed_entities", true);
  public get additionalAllowedEntities() {
    return this._additionalAllowedEntities;
  }
  public putAdditionalAllowedEntities(value: SpIdpConnectionAdditionalAllowedEntitiesConfigurationAdditionalAllowedEntities[] | cdktf.IResolvable) {
    this._additionalAllowedEntities.internalValue = value;
  }
  public resetAdditionalAllowedEntities() {
    this._additionalAllowedEntities.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalAllowedEntitiesInput() {
    return this._additionalAllowedEntities.internalValue;
  }

  // allow_additional_entities - computed: true, optional: true, required: false
  private _allowAdditionalEntities?: boolean | cdktf.IResolvable; 
  public get allowAdditionalEntities() {
    return this.getBooleanAttribute('allow_additional_entities');
  }
  public set allowAdditionalEntities(value: boolean | cdktf.IResolvable) {
    this._allowAdditionalEntities = value;
  }
  public resetAllowAdditionalEntities() {
    this._allowAdditionalEntities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowAdditionalEntitiesInput() {
    return this._allowAdditionalEntities;
  }

  // allow_all_entities - computed: true, optional: true, required: false
  private _allowAllEntities?: boolean | cdktf.IResolvable; 
  public get allowAllEntities() {
    return this.getBooleanAttribute('allow_all_entities');
  }
  public set allowAllEntities(value: boolean | cdktf.IResolvable) {
    this._allowAllEntities = value;
  }
  public resetAllowAllEntities() {
    this._allowAllEntities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowAllEntitiesInput() {
    return this._allowAllEntities;
  }
}
export interface SpIdpConnectionAttributeQueryNameMappings {
  /**
  * The local attribute name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#local_name SpIdpConnection#local_name}
  */
  readonly localName: string;
  /**
  * The remote attribute name as defined by the attribute authority.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#remote_name SpIdpConnection#remote_name}
  */
  readonly remoteName: string;
}

export function spIdpConnectionAttributeQueryNameMappingsToTerraform(struct?: SpIdpConnectionAttributeQueryNameMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    local_name: cdktf.stringToTerraform(struct!.localName),
    remote_name: cdktf.stringToTerraform(struct!.remoteName),
  }
}


export function spIdpConnectionAttributeQueryNameMappingsToHclTerraform(struct?: SpIdpConnectionAttributeQueryNameMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    local_name: {
      value: cdktf.stringToHclTerraform(struct!.localName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remote_name: {
      value: cdktf.stringToHclTerraform(struct!.remoteName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionAttributeQueryNameMappingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionAttributeQueryNameMappings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._localName !== undefined) {
      hasAnyValues = true;
      internalValueResult.localName = this._localName;
    }
    if (this._remoteName !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteName = this._remoteName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionAttributeQueryNameMappings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._localName = undefined;
      this._remoteName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._localName = value.localName;
      this._remoteName = value.remoteName;
    }
  }

  // local_name - computed: false, optional: false, required: true
  private _localName?: string; 
  public get localName() {
    return this.getStringAttribute('local_name');
  }
  public set localName(value: string) {
    this._localName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get localNameInput() {
    return this._localName;
  }

  // remote_name - computed: false, optional: false, required: true
  private _remoteName?: string; 
  public get remoteName() {
    return this.getStringAttribute('remote_name');
  }
  public set remoteName(value: string) {
    this._remoteName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteNameInput() {
    return this._remoteName;
  }
}

export class SpIdpConnectionAttributeQueryNameMappingsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionAttributeQueryNameMappings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionAttributeQueryNameMappingsOutputReference {
    return new SpIdpConnectionAttributeQueryNameMappingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionAttributeQueryPolicy {
  /**
  * Encrypt the name identifier.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#encrypt_name_id SpIdpConnection#encrypt_name_id}
  */
  readonly encryptNameId?: boolean | cdktf.IResolvable;
  /**
  * Mask attributes in log files.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#mask_attribute_values SpIdpConnection#mask_attribute_values}
  */
  readonly maskAttributeValues?: boolean | cdktf.IResolvable;
  /**
  * Require encrypted assertion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#require_encrypted_assertion SpIdpConnection#require_encrypted_assertion}
  */
  readonly requireEncryptedAssertion?: boolean | cdktf.IResolvable;
  /**
  * Require signed assertion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#require_signed_assertion SpIdpConnection#require_signed_assertion}
  */
  readonly requireSignedAssertion?: boolean | cdktf.IResolvable;
  /**
  * Require signed r.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#require_signed_response SpIdpConnection#require_signed_response}
  */
  readonly requireSignedResponse?: boolean | cdktf.IResolvable;
  /**
  * Sign the attribute query.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#sign_attribute_query SpIdpConnection#sign_attribute_query}
  */
  readonly signAttributeQuery?: boolean | cdktf.IResolvable;
}

export function spIdpConnectionAttributeQueryPolicyToTerraform(struct?: SpIdpConnectionAttributeQueryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    encrypt_name_id: cdktf.booleanToTerraform(struct!.encryptNameId),
    mask_attribute_values: cdktf.booleanToTerraform(struct!.maskAttributeValues),
    require_encrypted_assertion: cdktf.booleanToTerraform(struct!.requireEncryptedAssertion),
    require_signed_assertion: cdktf.booleanToTerraform(struct!.requireSignedAssertion),
    require_signed_response: cdktf.booleanToTerraform(struct!.requireSignedResponse),
    sign_attribute_query: cdktf.booleanToTerraform(struct!.signAttributeQuery),
  }
}


export function spIdpConnectionAttributeQueryPolicyToHclTerraform(struct?: SpIdpConnectionAttributeQueryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    encrypt_name_id: {
      value: cdktf.booleanToHclTerraform(struct!.encryptNameId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mask_attribute_values: {
      value: cdktf.booleanToHclTerraform(struct!.maskAttributeValues),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    require_encrypted_assertion: {
      value: cdktf.booleanToHclTerraform(struct!.requireEncryptedAssertion),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    require_signed_assertion: {
      value: cdktf.booleanToHclTerraform(struct!.requireSignedAssertion),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    require_signed_response: {
      value: cdktf.booleanToHclTerraform(struct!.requireSignedResponse),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    sign_attribute_query: {
      value: cdktf.booleanToHclTerraform(struct!.signAttributeQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionAttributeQueryPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionAttributeQueryPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._encryptNameId !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptNameId = this._encryptNameId;
    }
    if (this._maskAttributeValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskAttributeValues = this._maskAttributeValues;
    }
    if (this._requireEncryptedAssertion !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireEncryptedAssertion = this._requireEncryptedAssertion;
    }
    if (this._requireSignedAssertion !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireSignedAssertion = this._requireSignedAssertion;
    }
    if (this._requireSignedResponse !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireSignedResponse = this._requireSignedResponse;
    }
    if (this._signAttributeQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.signAttributeQuery = this._signAttributeQuery;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionAttributeQueryPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._encryptNameId = undefined;
      this._maskAttributeValues = undefined;
      this._requireEncryptedAssertion = undefined;
      this._requireSignedAssertion = undefined;
      this._requireSignedResponse = undefined;
      this._signAttributeQuery = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._encryptNameId = value.encryptNameId;
      this._maskAttributeValues = value.maskAttributeValues;
      this._requireEncryptedAssertion = value.requireEncryptedAssertion;
      this._requireSignedAssertion = value.requireSignedAssertion;
      this._requireSignedResponse = value.requireSignedResponse;
      this._signAttributeQuery = value.signAttributeQuery;
    }
  }

  // encrypt_name_id - computed: false, optional: true, required: false
  private _encryptNameId?: boolean | cdktf.IResolvable; 
  public get encryptNameId() {
    return this.getBooleanAttribute('encrypt_name_id');
  }
  public set encryptNameId(value: boolean | cdktf.IResolvable) {
    this._encryptNameId = value;
  }
  public resetEncryptNameId() {
    this._encryptNameId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptNameIdInput() {
    return this._encryptNameId;
  }

  // mask_attribute_values - computed: false, optional: true, required: false
  private _maskAttributeValues?: boolean | cdktf.IResolvable; 
  public get maskAttributeValues() {
    return this.getBooleanAttribute('mask_attribute_values');
  }
  public set maskAttributeValues(value: boolean | cdktf.IResolvable) {
    this._maskAttributeValues = value;
  }
  public resetMaskAttributeValues() {
    this._maskAttributeValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskAttributeValuesInput() {
    return this._maskAttributeValues;
  }

  // require_encrypted_assertion - computed: false, optional: true, required: false
  private _requireEncryptedAssertion?: boolean | cdktf.IResolvable; 
  public get requireEncryptedAssertion() {
    return this.getBooleanAttribute('require_encrypted_assertion');
  }
  public set requireEncryptedAssertion(value: boolean | cdktf.IResolvable) {
    this._requireEncryptedAssertion = value;
  }
  public resetRequireEncryptedAssertion() {
    this._requireEncryptedAssertion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireEncryptedAssertionInput() {
    return this._requireEncryptedAssertion;
  }

  // require_signed_assertion - computed: false, optional: true, required: false
  private _requireSignedAssertion?: boolean | cdktf.IResolvable; 
  public get requireSignedAssertion() {
    return this.getBooleanAttribute('require_signed_assertion');
  }
  public set requireSignedAssertion(value: boolean | cdktf.IResolvable) {
    this._requireSignedAssertion = value;
  }
  public resetRequireSignedAssertion() {
    this._requireSignedAssertion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireSignedAssertionInput() {
    return this._requireSignedAssertion;
  }

  // require_signed_response - computed: false, optional: true, required: false
  private _requireSignedResponse?: boolean | cdktf.IResolvable; 
  public get requireSignedResponse() {
    return this.getBooleanAttribute('require_signed_response');
  }
  public set requireSignedResponse(value: boolean | cdktf.IResolvable) {
    this._requireSignedResponse = value;
  }
  public resetRequireSignedResponse() {
    this._requireSignedResponse = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireSignedResponseInput() {
    return this._requireSignedResponse;
  }

  // sign_attribute_query - computed: false, optional: true, required: false
  private _signAttributeQuery?: boolean | cdktf.IResolvable; 
  public get signAttributeQuery() {
    return this.getBooleanAttribute('sign_attribute_query');
  }
  public set signAttributeQuery(value: boolean | cdktf.IResolvable) {
    this._signAttributeQuery = value;
  }
  public resetSignAttributeQuery() {
    this._signAttributeQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signAttributeQueryInput() {
    return this._signAttributeQuery;
  }
}
export interface SpIdpConnectionAttributeQuery {
  /**
  * The attribute name mappings between the SP and the IdP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name_mappings SpIdpConnection#name_mappings}
  */
  readonly nameMappings?: SpIdpConnectionAttributeQueryNameMappings[] | cdktf.IResolvable;
  /**
  * The attribute query profile's security policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#policy SpIdpConnection#policy}
  */
  readonly policy?: SpIdpConnectionAttributeQueryPolicy;
  /**
  * The URL at your IdP partner's site where attribute queries are to be sent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#url SpIdpConnection#url}
  */
  readonly url: string;
}

export function spIdpConnectionAttributeQueryToTerraform(struct?: SpIdpConnectionAttributeQuery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name_mappings: cdktf.listMapper(spIdpConnectionAttributeQueryNameMappingsToTerraform, false)(struct!.nameMappings),
    policy: spIdpConnectionAttributeQueryPolicyToTerraform(struct!.policy),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function spIdpConnectionAttributeQueryToHclTerraform(struct?: SpIdpConnectionAttributeQuery | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name_mappings: {
      value: cdktf.listMapperHcl(spIdpConnectionAttributeQueryNameMappingsToHclTerraform, false)(struct!.nameMappings),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionAttributeQueryNameMappingsList",
    },
    policy: {
      value: spIdpConnectionAttributeQueryPolicyToHclTerraform(struct!.policy),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionAttributeQueryPolicy",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionAttributeQueryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionAttributeQuery | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nameMappings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameMappings = this._nameMappings?.internalValue;
    }
    if (this._policy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.policy = this._policy?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionAttributeQuery | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nameMappings.internalValue = undefined;
      this._policy.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nameMappings.internalValue = value.nameMappings;
      this._policy.internalValue = value.policy;
      this._url = value.url;
    }
  }

  // name_mappings - computed: false, optional: true, required: false
  private _nameMappings = new SpIdpConnectionAttributeQueryNameMappingsList(this, "name_mappings", true);
  public get nameMappings() {
    return this._nameMappings;
  }
  public putNameMappings(value: SpIdpConnectionAttributeQueryNameMappings[] | cdktf.IResolvable) {
    this._nameMappings.internalValue = value;
  }
  public resetNameMappings() {
    this._nameMappings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameMappingsInput() {
    return this._nameMappings.internalValue;
  }

  // policy - computed: false, optional: true, required: false
  private _policy = new SpIdpConnectionAttributeQueryPolicyOutputReference(this, "policy");
  public get policy() {
    return this._policy;
  }
  public putPolicy(value: SpIdpConnectionAttributeQueryPolicy) {
    this._policy.internalValue = value;
  }
  public resetPolicy() {
    this._policy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get policyInput() {
    return this._policy.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface SpIdpConnectionContactInfo {
  /**
  * Company name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#company SpIdpConnection#company}
  */
  readonly company?: string;
  /**
  * Contact email address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#email SpIdpConnection#email}
  */
  readonly email?: string;
  /**
  * Contact first name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#first_name SpIdpConnection#first_name}
  */
  readonly firstName?: string;
  /**
  * Contact last name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#last_name SpIdpConnection#last_name}
  */
  readonly lastName?: string;
  /**
  * Contact phone number.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#phone SpIdpConnection#phone}
  */
  readonly phone?: string;
}

export function spIdpConnectionContactInfoToTerraform(struct?: SpIdpConnectionContactInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    company: cdktf.stringToTerraform(struct!.company),
    email: cdktf.stringToTerraform(struct!.email),
    first_name: cdktf.stringToTerraform(struct!.firstName),
    last_name: cdktf.stringToTerraform(struct!.lastName),
    phone: cdktf.stringToTerraform(struct!.phone),
  }
}


export function spIdpConnectionContactInfoToHclTerraform(struct?: SpIdpConnectionContactInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    company: {
      value: cdktf.stringToHclTerraform(struct!.company),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    email: {
      value: cdktf.stringToHclTerraform(struct!.email),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    first_name: {
      value: cdktf.stringToHclTerraform(struct!.firstName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    last_name: {
      value: cdktf.stringToHclTerraform(struct!.lastName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    phone: {
      value: cdktf.stringToHclTerraform(struct!.phone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionContactInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionContactInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._company !== undefined) {
      hasAnyValues = true;
      internalValueResult.company = this._company;
    }
    if (this._email !== undefined) {
      hasAnyValues = true;
      internalValueResult.email = this._email;
    }
    if (this._firstName !== undefined) {
      hasAnyValues = true;
      internalValueResult.firstName = this._firstName;
    }
    if (this._lastName !== undefined) {
      hasAnyValues = true;
      internalValueResult.lastName = this._lastName;
    }
    if (this._phone !== undefined) {
      hasAnyValues = true;
      internalValueResult.phone = this._phone;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionContactInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._company = undefined;
      this._email = undefined;
      this._firstName = undefined;
      this._lastName = undefined;
      this._phone = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._company = value.company;
      this._email = value.email;
      this._firstName = value.firstName;
      this._lastName = value.lastName;
      this._phone = value.phone;
    }
  }

  // company - computed: false, optional: true, required: false
  private _company?: string; 
  public get company() {
    return this.getStringAttribute('company');
  }
  public set company(value: string) {
    this._company = value;
  }
  public resetCompany() {
    this._company = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get companyInput() {
    return this._company;
  }

  // email - computed: false, optional: true, required: false
  private _email?: string; 
  public get email() {
    return this.getStringAttribute('email');
  }
  public set email(value: string) {
    this._email = value;
  }
  public resetEmail() {
    this._email = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emailInput() {
    return this._email;
  }

  // first_name - computed: false, optional: true, required: false
  private _firstName?: string; 
  public get firstName() {
    return this.getStringAttribute('first_name');
  }
  public set firstName(value: string) {
    this._firstName = value;
  }
  public resetFirstName() {
    this._firstName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get firstNameInput() {
    return this._firstName;
  }

  // last_name - computed: false, optional: true, required: false
  private _lastName?: string; 
  public get lastName() {
    return this.getStringAttribute('last_name');
  }
  public set lastName(value: string) {
    this._lastName = value;
  }
  public resetLastName() {
    this._lastName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lastNameInput() {
    return this._lastName;
  }

  // phone - computed: false, optional: true, required: false
  private _phone?: string; 
  public get phone() {
    return this.getStringAttribute('phone');
  }
  public set phone(value: string) {
    this._phone = value;
  }
  public resetPhone() {
    this._phone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get phoneInput() {
    return this._phone;
  }
}
export interface SpIdpConnectionCredentialsCertsCertView {
}

export function spIdpConnectionCredentialsCertsCertViewToTerraform(struct?: SpIdpConnectionCredentialsCertsCertView): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function spIdpConnectionCredentialsCertsCertViewToHclTerraform(struct?: SpIdpConnectionCredentialsCertsCertView): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class SpIdpConnectionCredentialsCertsCertViewOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsCertsCertView | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsCertsCertView | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // crypto_provider - computed: true, optional: false, required: false
  public get cryptoProvider() {
    return this.getStringAttribute('crypto_provider');
  }

  // expires - computed: true, optional: false, required: false
  public get expires() {
    return this.getStringAttribute('expires');
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // issuer_dn - computed: true, optional: false, required: false
  public get issuerDn() {
    return this.getStringAttribute('issuer_dn');
  }

  // key_algorithm - computed: true, optional: false, required: false
  public get keyAlgorithm() {
    return this.getStringAttribute('key_algorithm');
  }

  // key_size - computed: true, optional: false, required: false
  public get keySize() {
    return this.getNumberAttribute('key_size');
  }

  // serial_number - computed: true, optional: false, required: false
  public get serialNumber() {
    return this.getStringAttribute('serial_number');
  }

  // sha1_fingerprint - computed: true, optional: false, required: false
  public get sha1Fingerprint() {
    return this.getStringAttribute('sha1_fingerprint');
  }

  // sha256_fingerprint - computed: true, optional: false, required: false
  public get sha256Fingerprint() {
    return this.getStringAttribute('sha256_fingerprint');
  }

  // signature_algorithm - computed: true, optional: false, required: false
  public get signatureAlgorithm() {
    return this.getStringAttribute('signature_algorithm');
  }

  // status - computed: true, optional: false, required: false
  public get status() {
    return this.getStringAttribute('status');
  }

  // subject_alternative_names - computed: true, optional: false, required: false
  public get subjectAlternativeNames() {
    return cdktf.Fn.tolist(this.getListAttribute('subject_alternative_names'));
  }

  // subject_dn - computed: true, optional: false, required: false
  public get subjectDn() {
    return this.getStringAttribute('subject_dn');
  }

  // valid_from - computed: true, optional: false, required: false
  public get validFrom() {
    return this.getStringAttribute('valid_from');
  }

  // version - computed: true, optional: false, required: false
  public get version() {
    return this.getNumberAttribute('version');
  }
}
export interface SpIdpConnectionCredentialsCertsX509File {
  /**
  * Cryptographic Provider. This is only applicable if Hybrid HSM mode is true. Optional values are `HSM` and `LOCAL`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#crypto_provider SpIdpConnection#crypto_provider}
  */
  readonly cryptoProvider?: string;
  /**
  * The certificate data in PEM format. New line characters should be omitted or encoded in this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#file_data SpIdpConnection#file_data}
  */
  readonly fileData: string;
  /**
  * The persistent, unique ID for the certificate. It can be any combination of `[a-z0-9._-]`. This property is system-assigned if not specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
}

export function spIdpConnectionCredentialsCertsX509FileToTerraform(struct?: SpIdpConnectionCredentialsCertsX509File): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    crypto_provider: cdktf.stringToTerraform(struct!.cryptoProvider),
    file_data: cdktf.stringToTerraform(struct!.fileData),
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionCredentialsCertsX509FileToHclTerraform(struct?: SpIdpConnectionCredentialsCertsX509File): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    crypto_provider: {
      value: cdktf.stringToHclTerraform(struct!.cryptoProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_data: {
      value: cdktf.stringToHclTerraform(struct!.fileData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsCertsX509FileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsCertsX509File | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cryptoProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.cryptoProvider = this._cryptoProvider;
    }
    if (this._fileData !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileData = this._fileData;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsCertsX509File | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._cryptoProvider = undefined;
      this._fileData = undefined;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._cryptoProvider = value.cryptoProvider;
      this._fileData = value.fileData;
      this._id = value.id;
    }
  }

  // crypto_provider - computed: true, optional: true, required: false
  private _cryptoProvider?: string; 
  public get cryptoProvider() {
    return this.getStringAttribute('crypto_provider');
  }
  public set cryptoProvider(value: string) {
    this._cryptoProvider = value;
  }
  public resetCryptoProvider() {
    this._cryptoProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cryptoProviderInput() {
    return this._cryptoProvider;
  }

  // file_data - computed: true, optional: false, required: true
  private _fileData?: string; 
  public get fileData() {
    return this.getStringAttribute('file_data');
  }
  public set fileData(value: string) {
    this._fileData = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileDataInput() {
    return this._fileData;
  }

  // formatted_file_data - computed: true, optional: false, required: false
  public get formattedFileData() {
    return this.getStringAttribute('formatted_file_data');
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionCredentialsCerts {
  /**
  * Indicates whether this is an active signature verification certificate. Default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#active_verification_cert SpIdpConnection#active_verification_cert}
  */
  readonly activeVerificationCert?: boolean | cdktf.IResolvable;
  /**
  * Indicates whether to use this cert to encrypt outgoing assertions. Only one certificate in the collection can have this flag set. Default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#encryption_cert SpIdpConnection#encryption_cert}
  */
  readonly encryptionCert?: boolean | cdktf.IResolvable;
  /**
  * Indicates whether this is the primary signature verification certificate. Only one certificate in the collection can have this flag set. Default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#primary_verification_cert SpIdpConnection#primary_verification_cert}
  */
  readonly primaryVerificationCert?: boolean | cdktf.IResolvable;
  /**
  * Indicates whether this is the secondary signature verification certificate. Only one certificate in the collection can have this flag set. Default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#secondary_verification_cert SpIdpConnection#secondary_verification_cert}
  */
  readonly secondaryVerificationCert?: boolean | cdktf.IResolvable;
  /**
  * Encoded certificate data.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#x509_file SpIdpConnection#x509_file}
  */
  readonly x509File: SpIdpConnectionCredentialsCertsX509File;
}

export function spIdpConnectionCredentialsCertsToTerraform(struct?: SpIdpConnectionCredentialsCerts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    active_verification_cert: cdktf.booleanToTerraform(struct!.activeVerificationCert),
    encryption_cert: cdktf.booleanToTerraform(struct!.encryptionCert),
    primary_verification_cert: cdktf.booleanToTerraform(struct!.primaryVerificationCert),
    secondary_verification_cert: cdktf.booleanToTerraform(struct!.secondaryVerificationCert),
    x509_file: spIdpConnectionCredentialsCertsX509FileToTerraform(struct!.x509File),
  }
}


export function spIdpConnectionCredentialsCertsToHclTerraform(struct?: SpIdpConnectionCredentialsCerts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    active_verification_cert: {
      value: cdktf.booleanToHclTerraform(struct!.activeVerificationCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encryption_cert: {
      value: cdktf.booleanToHclTerraform(struct!.encryptionCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    primary_verification_cert: {
      value: cdktf.booleanToHclTerraform(struct!.primaryVerificationCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secondary_verification_cert: {
      value: cdktf.booleanToHclTerraform(struct!.secondaryVerificationCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    x509_file: {
      value: spIdpConnectionCredentialsCertsX509FileToHclTerraform(struct!.x509File),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsCertsX509File",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsCertsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionCredentialsCerts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activeVerificationCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.activeVerificationCert = this._activeVerificationCert;
    }
    if (this._encryptionCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptionCert = this._encryptionCert;
    }
    if (this._primaryVerificationCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.primaryVerificationCert = this._primaryVerificationCert;
    }
    if (this._secondaryVerificationCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryVerificationCert = this._secondaryVerificationCert;
    }
    if (this._x509File?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.x509File = this._x509File?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsCerts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activeVerificationCert = undefined;
      this._encryptionCert = undefined;
      this._primaryVerificationCert = undefined;
      this._secondaryVerificationCert = undefined;
      this._x509File.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activeVerificationCert = value.activeVerificationCert;
      this._encryptionCert = value.encryptionCert;
      this._primaryVerificationCert = value.primaryVerificationCert;
      this._secondaryVerificationCert = value.secondaryVerificationCert;
      this._x509File.internalValue = value.x509File;
    }
  }

  // active_verification_cert - computed: true, optional: true, required: false
  private _activeVerificationCert?: boolean | cdktf.IResolvable; 
  public get activeVerificationCert() {
    return this.getBooleanAttribute('active_verification_cert');
  }
  public set activeVerificationCert(value: boolean | cdktf.IResolvable) {
    this._activeVerificationCert = value;
  }
  public resetActiveVerificationCert() {
    this._activeVerificationCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activeVerificationCertInput() {
    return this._activeVerificationCert;
  }

  // cert_view - computed: true, optional: false, required: false
  private _certView = new SpIdpConnectionCredentialsCertsCertViewOutputReference(this, "cert_view");
  public get certView() {
    return this._certView;
  }

  // encryption_cert - computed: true, optional: true, required: false
  private _encryptionCert?: boolean | cdktf.IResolvable; 
  public get encryptionCert() {
    return this.getBooleanAttribute('encryption_cert');
  }
  public set encryptionCert(value: boolean | cdktf.IResolvable) {
    this._encryptionCert = value;
  }
  public resetEncryptionCert() {
    this._encryptionCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionCertInput() {
    return this._encryptionCert;
  }

  // primary_verification_cert - computed: true, optional: true, required: false
  private _primaryVerificationCert?: boolean | cdktf.IResolvable; 
  public get primaryVerificationCert() {
    return this.getBooleanAttribute('primary_verification_cert');
  }
  public set primaryVerificationCert(value: boolean | cdktf.IResolvable) {
    this._primaryVerificationCert = value;
  }
  public resetPrimaryVerificationCert() {
    this._primaryVerificationCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get primaryVerificationCertInput() {
    return this._primaryVerificationCert;
  }

  // secondary_verification_cert - computed: true, optional: true, required: false
  private _secondaryVerificationCert?: boolean | cdktf.IResolvable; 
  public get secondaryVerificationCert() {
    return this.getBooleanAttribute('secondary_verification_cert');
  }
  public set secondaryVerificationCert(value: boolean | cdktf.IResolvable) {
    this._secondaryVerificationCert = value;
  }
  public resetSecondaryVerificationCert() {
    this._secondaryVerificationCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryVerificationCertInput() {
    return this._secondaryVerificationCert;
  }

  // x509_file - computed: true, optional: false, required: true
  private _x509File = new SpIdpConnectionCredentialsCertsX509FileOutputReference(this, "x509_file");
  public get x509File() {
    return this._x509File;
  }
  public putX509File(value: SpIdpConnectionCredentialsCertsX509File) {
    this._x509File.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get x509FileInput() {
    return this._x509File.internalValue;
  }
}

export class SpIdpConnectionCredentialsCertsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionCredentialsCerts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionCredentialsCertsOutputReference {
    return new SpIdpConnectionCredentialsCertsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionCredentialsDecryptionKeyPairRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionCredentialsDecryptionKeyPairRefToTerraform(struct?: SpIdpConnectionCredentialsDecryptionKeyPairRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionCredentialsDecryptionKeyPairRefToHclTerraform(struct?: SpIdpConnectionCredentialsDecryptionKeyPairRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsDecryptionKeyPairRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsDecryptionKeyPairRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsDecryptionKeyPairRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionCredentialsInboundBackChannelAuthCertsCertView {
}

export function spIdpConnectionCredentialsInboundBackChannelAuthCertsCertViewToTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuthCertsCertView): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function spIdpConnectionCredentialsInboundBackChannelAuthCertsCertViewToHclTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuthCertsCertView): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class SpIdpConnectionCredentialsInboundBackChannelAuthCertsCertViewOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsInboundBackChannelAuthCertsCertView | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsInboundBackChannelAuthCertsCertView | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // crypto_provider - computed: true, optional: false, required: false
  public get cryptoProvider() {
    return this.getStringAttribute('crypto_provider');
  }

  // expires - computed: true, optional: false, required: false
  public get expires() {
    return this.getStringAttribute('expires');
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // issuer_dn - computed: true, optional: false, required: false
  public get issuerDn() {
    return this.getStringAttribute('issuer_dn');
  }

  // key_algorithm - computed: true, optional: false, required: false
  public get keyAlgorithm() {
    return this.getStringAttribute('key_algorithm');
  }

  // key_size - computed: true, optional: false, required: false
  public get keySize() {
    return this.getNumberAttribute('key_size');
  }

  // serial_number - computed: true, optional: false, required: false
  public get serialNumber() {
    return this.getStringAttribute('serial_number');
  }

  // sha1_fingerprint - computed: true, optional: false, required: false
  public get sha1Fingerprint() {
    return this.getStringAttribute('sha1_fingerprint');
  }

  // sha256_fingerprint - computed: true, optional: false, required: false
  public get sha256Fingerprint() {
    return this.getStringAttribute('sha256_fingerprint');
  }

  // signature_algorithm - computed: true, optional: false, required: false
  public get signatureAlgorithm() {
    return this.getStringAttribute('signature_algorithm');
  }

  // status - computed: true, optional: false, required: false
  public get status() {
    return this.getStringAttribute('status');
  }

  // subject_alternative_names - computed: true, optional: false, required: false
  public get subjectAlternativeNames() {
    return cdktf.Fn.tolist(this.getListAttribute('subject_alternative_names'));
  }

  // subject_dn - computed: true, optional: false, required: false
  public get subjectDn() {
    return this.getStringAttribute('subject_dn');
  }

  // valid_from - computed: true, optional: false, required: false
  public get validFrom() {
    return this.getStringAttribute('valid_from');
  }

  // version - computed: true, optional: false, required: false
  public get version() {
    return this.getNumberAttribute('version');
  }
}
export interface SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509File {
  /**
  * Cryptographic Provider. This is only applicable if Hybrid HSM mode is true. Optional values are `HSM` and `LOCAL`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#crypto_provider SpIdpConnection#crypto_provider}
  */
  readonly cryptoProvider?: string;
  /**
  * The certificate data in PEM format. New line characters should be omitted or encoded in this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#file_data SpIdpConnection#file_data}
  */
  readonly fileData: string;
  /**
  * The persistent, unique ID for the certificate. It can be any combination of `[a-z0-9._-]`. This property is system-assigned if not specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
}

export function spIdpConnectionCredentialsInboundBackChannelAuthCertsX509FileToTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509File | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    crypto_provider: cdktf.stringToTerraform(struct!.cryptoProvider),
    file_data: cdktf.stringToTerraform(struct!.fileData),
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionCredentialsInboundBackChannelAuthCertsX509FileToHclTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509File | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    crypto_provider: {
      value: cdktf.stringToHclTerraform(struct!.cryptoProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_data: {
      value: cdktf.stringToHclTerraform(struct!.fileData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509FileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509File | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cryptoProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.cryptoProvider = this._cryptoProvider;
    }
    if (this._fileData !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileData = this._fileData;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509File | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cryptoProvider = undefined;
      this._fileData = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cryptoProvider = value.cryptoProvider;
      this._fileData = value.fileData;
      this._id = value.id;
    }
  }

  // crypto_provider - computed: false, optional: true, required: false
  private _cryptoProvider?: string; 
  public get cryptoProvider() {
    return this.getStringAttribute('crypto_provider');
  }
  public set cryptoProvider(value: string) {
    this._cryptoProvider = value;
  }
  public resetCryptoProvider() {
    this._cryptoProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cryptoProviderInput() {
    return this._cryptoProvider;
  }

  // file_data - computed: false, optional: false, required: true
  private _fileData?: string; 
  public get fileData() {
    return this.getStringAttribute('file_data');
  }
  public set fileData(value: string) {
    this._fileData = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fileDataInput() {
    return this._fileData;
  }

  // formatted_file_data - computed: true, optional: false, required: false
  public get formattedFileData() {
    return this.getStringAttribute('formatted_file_data');
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionCredentialsInboundBackChannelAuthCerts {
  /**
  * Indicates whether this is an active signature verification certificate. Default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#active_verification_cert SpIdpConnection#active_verification_cert}
  */
  readonly activeVerificationCert?: boolean | cdktf.IResolvable;
  /**
  * Indicates whether to use this cert to encrypt outgoing assertions. Only one certificate in the collection can have this flag set. Default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#encryption_cert SpIdpConnection#encryption_cert}
  */
  readonly encryptionCert?: boolean | cdktf.IResolvable;
  /**
  * Indicates whether this is the primary signature verification certificate. Only one certificate in the collection can have this flag set. Default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#primary_verification_cert SpIdpConnection#primary_verification_cert}
  */
  readonly primaryVerificationCert?: boolean | cdktf.IResolvable;
  /**
  * Indicates whether this is the secondary signature verification certificate. Only one certificate in the collection can have this flag set. Default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#secondary_verification_cert SpIdpConnection#secondary_verification_cert}
  */
  readonly secondaryVerificationCert?: boolean | cdktf.IResolvable;
  /**
  * Encoded certificate data.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#x509_file SpIdpConnection#x509_file}
  */
  readonly x509File: SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509File;
}

export function spIdpConnectionCredentialsInboundBackChannelAuthCertsToTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuthCerts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    active_verification_cert: cdktf.booleanToTerraform(struct!.activeVerificationCert),
    encryption_cert: cdktf.booleanToTerraform(struct!.encryptionCert),
    primary_verification_cert: cdktf.booleanToTerraform(struct!.primaryVerificationCert),
    secondary_verification_cert: cdktf.booleanToTerraform(struct!.secondaryVerificationCert),
    x509_file: spIdpConnectionCredentialsInboundBackChannelAuthCertsX509FileToTerraform(struct!.x509File),
  }
}


export function spIdpConnectionCredentialsInboundBackChannelAuthCertsToHclTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuthCerts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    active_verification_cert: {
      value: cdktf.booleanToHclTerraform(struct!.activeVerificationCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    encryption_cert: {
      value: cdktf.booleanToHclTerraform(struct!.encryptionCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    primary_verification_cert: {
      value: cdktf.booleanToHclTerraform(struct!.primaryVerificationCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secondary_verification_cert: {
      value: cdktf.booleanToHclTerraform(struct!.secondaryVerificationCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    x509_file: {
      value: spIdpConnectionCredentialsInboundBackChannelAuthCertsX509FileToHclTerraform(struct!.x509File),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509File",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsInboundBackChannelAuthCertsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionCredentialsInboundBackChannelAuthCerts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activeVerificationCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.activeVerificationCert = this._activeVerificationCert;
    }
    if (this._encryptionCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptionCert = this._encryptionCert;
    }
    if (this._primaryVerificationCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.primaryVerificationCert = this._primaryVerificationCert;
    }
    if (this._secondaryVerificationCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryVerificationCert = this._secondaryVerificationCert;
    }
    if (this._x509File?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.x509File = this._x509File?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsInboundBackChannelAuthCerts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activeVerificationCert = undefined;
      this._encryptionCert = undefined;
      this._primaryVerificationCert = undefined;
      this._secondaryVerificationCert = undefined;
      this._x509File.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activeVerificationCert = value.activeVerificationCert;
      this._encryptionCert = value.encryptionCert;
      this._primaryVerificationCert = value.primaryVerificationCert;
      this._secondaryVerificationCert = value.secondaryVerificationCert;
      this._x509File.internalValue = value.x509File;
    }
  }

  // active_verification_cert - computed: true, optional: true, required: false
  private _activeVerificationCert?: boolean | cdktf.IResolvable; 
  public get activeVerificationCert() {
    return this.getBooleanAttribute('active_verification_cert');
  }
  public set activeVerificationCert(value: boolean | cdktf.IResolvable) {
    this._activeVerificationCert = value;
  }
  public resetActiveVerificationCert() {
    this._activeVerificationCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activeVerificationCertInput() {
    return this._activeVerificationCert;
  }

  // cert_view - computed: true, optional: false, required: false
  private _certView = new SpIdpConnectionCredentialsInboundBackChannelAuthCertsCertViewOutputReference(this, "cert_view");
  public get certView() {
    return this._certView;
  }

  // encryption_cert - computed: true, optional: true, required: false
  private _encryptionCert?: boolean | cdktf.IResolvable; 
  public get encryptionCert() {
    return this.getBooleanAttribute('encryption_cert');
  }
  public set encryptionCert(value: boolean | cdktf.IResolvable) {
    this._encryptionCert = value;
  }
  public resetEncryptionCert() {
    this._encryptionCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionCertInput() {
    return this._encryptionCert;
  }

  // primary_verification_cert - computed: true, optional: true, required: false
  private _primaryVerificationCert?: boolean | cdktf.IResolvable; 
  public get primaryVerificationCert() {
    return this.getBooleanAttribute('primary_verification_cert');
  }
  public set primaryVerificationCert(value: boolean | cdktf.IResolvable) {
    this._primaryVerificationCert = value;
  }
  public resetPrimaryVerificationCert() {
    this._primaryVerificationCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get primaryVerificationCertInput() {
    return this._primaryVerificationCert;
  }

  // secondary_verification_cert - computed: true, optional: true, required: false
  private _secondaryVerificationCert?: boolean | cdktf.IResolvable; 
  public get secondaryVerificationCert() {
    return this.getBooleanAttribute('secondary_verification_cert');
  }
  public set secondaryVerificationCert(value: boolean | cdktf.IResolvable) {
    this._secondaryVerificationCert = value;
  }
  public resetSecondaryVerificationCert() {
    this._secondaryVerificationCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryVerificationCertInput() {
    return this._secondaryVerificationCert;
  }

  // x509_file - computed: false, optional: false, required: true
  private _x509File = new SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509FileOutputReference(this, "x509_file");
  public get x509File() {
    return this._x509File;
  }
  public putX509File(value: SpIdpConnectionCredentialsInboundBackChannelAuthCertsX509File) {
    this._x509File.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get x509FileInput() {
    return this._x509File.internalValue;
  }
}

export class SpIdpConnectionCredentialsInboundBackChannelAuthCertsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionCredentialsInboundBackChannelAuthCerts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionCredentialsInboundBackChannelAuthCertsOutputReference {
    return new SpIdpConnectionCredentialsInboundBackChannelAuthCertsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentials {
  /**
  * Encrypted user password. Either this attribute or `password` must be specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#encrypted_password SpIdpConnection#encrypted_password}
  */
  readonly encryptedPassword?: string;
  /**
  * User password. Either this attribute or `encrypted_password` must be specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#password SpIdpConnection#password}
  */
  readonly password?: string;
  /**
  * The username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#username SpIdpConnection#username}
  */
  readonly username?: string;
}

export function spIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentialsToTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    encrypted_password: cdktf.stringToTerraform(struct!.encryptedPassword),
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function spIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentialsToHclTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    encrypted_password: {
      value: cdktf.stringToHclTerraform(struct!.encryptedPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._encryptedPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptedPassword = this._encryptedPassword;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._encryptedPassword = undefined;
      this._password = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._encryptedPassword = value.encryptedPassword;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // encrypted_password - computed: true, optional: true, required: false
  private _encryptedPassword?: string; 
  public get encryptedPassword() {
    return this.getStringAttribute('encrypted_password');
  }
  public set encryptedPassword(value: string) {
    this._encryptedPassword = value;
  }
  public resetEncryptedPassword() {
    this._encryptedPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptedPasswordInput() {
    return this._encryptedPassword;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface SpIdpConnectionCredentialsInboundBackChannelAuth {
  /**
  * The certificates used for signature verification and XML encryption.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#certs SpIdpConnection#certs}
  */
  readonly certs?: SpIdpConnectionCredentialsInboundBackChannelAuthCerts[] | cdktf.IResolvable;
  /**
  * If incoming or outgoing messages must be signed. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#digital_signature SpIdpConnection#digital_signature}
  */
  readonly digitalSignature?: boolean | cdktf.IResolvable;
  /**
  * Username and password credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#http_basic_credentials SpIdpConnection#http_basic_credentials}
  */
  readonly httpBasicCredentials?: SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentials;
  /**
  * Incoming HTTP transmissions must use a secure channel. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#require_ssl SpIdpConnection#require_ssl}
  */
  readonly requireSsl?: boolean | cdktf.IResolvable;
  /**
  * If `verification_subject_dn` is provided, you can optionally restrict the issuer to a specific trusted CA by specifying its DN in this field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#verification_issuer_dn SpIdpConnection#verification_issuer_dn}
  */
  readonly verificationIssuerDn?: string;
  /**
  * If this property is set, the verification trust model is Anchored. The verification certificate must be signed by a trusted CA and included in the incoming message, and the subject DN of the expected certificate is specified in this property. If this property is not set, then a primary verification certificate must be specified in the `certs` array.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#verification_subject_dn SpIdpConnection#verification_subject_dn}
  */
  readonly verificationSubjectDn?: string;
}

export function spIdpConnectionCredentialsInboundBackChannelAuthToTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certs: cdktf.listMapper(spIdpConnectionCredentialsInboundBackChannelAuthCertsToTerraform, false)(struct!.certs),
    digital_signature: cdktf.booleanToTerraform(struct!.digitalSignature),
    http_basic_credentials: spIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentialsToTerraform(struct!.httpBasicCredentials),
    require_ssl: cdktf.booleanToTerraform(struct!.requireSsl),
    verification_issuer_dn: cdktf.stringToTerraform(struct!.verificationIssuerDn),
    verification_subject_dn: cdktf.stringToTerraform(struct!.verificationSubjectDn),
  }
}


export function spIdpConnectionCredentialsInboundBackChannelAuthToHclTerraform(struct?: SpIdpConnectionCredentialsInboundBackChannelAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certs: {
      value: cdktf.listMapperHcl(spIdpConnectionCredentialsInboundBackChannelAuthCertsToHclTerraform, false)(struct!.certs),
      isBlock: true,
      type: "list",
      storageClassType: "SpIdpConnectionCredentialsInboundBackChannelAuthCertsList",
    },
    digital_signature: {
      value: cdktf.booleanToHclTerraform(struct!.digitalSignature),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    http_basic_credentials: {
      value: spIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentialsToHclTerraform(struct!.httpBasicCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentials",
    },
    require_ssl: {
      value: cdktf.booleanToHclTerraform(struct!.requireSsl),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    verification_issuer_dn: {
      value: cdktf.stringToHclTerraform(struct!.verificationIssuerDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verification_subject_dn: {
      value: cdktf.stringToHclTerraform(struct!.verificationSubjectDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsInboundBackChannelAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsInboundBackChannelAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certs = this._certs?.internalValue;
    }
    if (this._digitalSignature !== undefined) {
      hasAnyValues = true;
      internalValueResult.digitalSignature = this._digitalSignature;
    }
    if (this._httpBasicCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpBasicCredentials = this._httpBasicCredentials?.internalValue;
    }
    if (this._requireSsl !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireSsl = this._requireSsl;
    }
    if (this._verificationIssuerDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.verificationIssuerDn = this._verificationIssuerDn;
    }
    if (this._verificationSubjectDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.verificationSubjectDn = this._verificationSubjectDn;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsInboundBackChannelAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certs.internalValue = undefined;
      this._digitalSignature = undefined;
      this._httpBasicCredentials.internalValue = undefined;
      this._requireSsl = undefined;
      this._verificationIssuerDn = undefined;
      this._verificationSubjectDn = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certs.internalValue = value.certs;
      this._digitalSignature = value.digitalSignature;
      this._httpBasicCredentials.internalValue = value.httpBasicCredentials;
      this._requireSsl = value.requireSsl;
      this._verificationIssuerDn = value.verificationIssuerDn;
      this._verificationSubjectDn = value.verificationSubjectDn;
    }
  }

  // certs - computed: false, optional: true, required: false
  private _certs = new SpIdpConnectionCredentialsInboundBackChannelAuthCertsList(this, "certs", false);
  public get certs() {
    return this._certs;
  }
  public putCerts(value: SpIdpConnectionCredentialsInboundBackChannelAuthCerts[] | cdktf.IResolvable) {
    this._certs.internalValue = value;
  }
  public resetCerts() {
    this._certs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certsInput() {
    return this._certs.internalValue;
  }

  // digital_signature - computed: true, optional: true, required: false
  private _digitalSignature?: boolean | cdktf.IResolvable; 
  public get digitalSignature() {
    return this.getBooleanAttribute('digital_signature');
  }
  public set digitalSignature(value: boolean | cdktf.IResolvable) {
    this._digitalSignature = value;
  }
  public resetDigitalSignature() {
    this._digitalSignature = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get digitalSignatureInput() {
    return this._digitalSignature;
  }

  // http_basic_credentials - computed: false, optional: true, required: false
  private _httpBasicCredentials = new SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentialsOutputReference(this, "http_basic_credentials");
  public get httpBasicCredentials() {
    return this._httpBasicCredentials;
  }
  public putHttpBasicCredentials(value: SpIdpConnectionCredentialsInboundBackChannelAuthHttpBasicCredentials) {
    this._httpBasicCredentials.internalValue = value;
  }
  public resetHttpBasicCredentials() {
    this._httpBasicCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpBasicCredentialsInput() {
    return this._httpBasicCredentials.internalValue;
  }

  // require_ssl - computed: true, optional: true, required: false
  private _requireSsl?: boolean | cdktf.IResolvable; 
  public get requireSsl() {
    return this.getBooleanAttribute('require_ssl');
  }
  public set requireSsl(value: boolean | cdktf.IResolvable) {
    this._requireSsl = value;
  }
  public resetRequireSsl() {
    this._requireSsl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireSslInput() {
    return this._requireSsl;
  }

  // verification_issuer_dn - computed: false, optional: true, required: false
  private _verificationIssuerDn?: string; 
  public get verificationIssuerDn() {
    return this.getStringAttribute('verification_issuer_dn');
  }
  public set verificationIssuerDn(value: string) {
    this._verificationIssuerDn = value;
  }
  public resetVerificationIssuerDn() {
    this._verificationIssuerDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verificationIssuerDnInput() {
    return this._verificationIssuerDn;
  }

  // verification_subject_dn - computed: false, optional: true, required: false
  private _verificationSubjectDn?: string; 
  public get verificationSubjectDn() {
    return this.getStringAttribute('verification_subject_dn');
  }
  public set verificationSubjectDn(value: string) {
    this._verificationSubjectDn = value;
  }
  public resetVerificationSubjectDn() {
    this._verificationSubjectDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verificationSubjectDnInput() {
    return this._verificationSubjectDn;
  }
}
export interface SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentials {
  /**
  * Encrypted user password. Either this attribute or `password` must be specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#encrypted_password SpIdpConnection#encrypted_password}
  */
  readonly encryptedPassword?: string;
  /**
  * User password. Either this attribute or `encrypted_password` must be specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#password SpIdpConnection#password}
  */
  readonly password?: string;
  /**
  * The username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#username SpIdpConnection#username}
  */
  readonly username?: string;
}

export function spIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentialsToTerraform(struct?: SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    encrypted_password: cdktf.stringToTerraform(struct!.encryptedPassword),
    password: cdktf.stringToTerraform(struct!.password),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function spIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentialsToHclTerraform(struct?: SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    encrypted_password: {
      value: cdktf.stringToHclTerraform(struct!.encryptedPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._encryptedPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptedPassword = this._encryptedPassword;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._encryptedPassword = undefined;
      this._password = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._encryptedPassword = value.encryptedPassword;
      this._password = value.password;
      this._username = value.username;
    }
  }

  // encrypted_password - computed: true, optional: true, required: false
  private _encryptedPassword?: string; 
  public get encryptedPassword() {
    return this.getStringAttribute('encrypted_password');
  }
  public set encryptedPassword(value: string) {
    this._encryptedPassword = value;
  }
  public resetEncryptedPassword() {
    this._encryptedPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptedPasswordInput() {
    return this._encryptedPassword;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRefToTerraform(struct?: SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRefToHclTerraform(struct?: SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionCredentialsOutboundBackChannelAuth {
  /**
  * If incoming or outgoing messages must be signed. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#digital_signature SpIdpConnection#digital_signature}
  */
  readonly digitalSignature?: boolean | cdktf.IResolvable;
  /**
  * Username and password credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#http_basic_credentials SpIdpConnection#http_basic_credentials}
  */
  readonly httpBasicCredentials?: SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentials;
  /**
  * A reference to a resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#ssl_auth_key_pair_ref SpIdpConnection#ssl_auth_key_pair_ref}
  */
  readonly sslAuthKeyPairRef?: SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRef;
  /**
  * Validate the partner server certificate. Default is `true`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#validate_partner_cert SpIdpConnection#validate_partner_cert}
  */
  readonly validatePartnerCert?: boolean | cdktf.IResolvable;
}

export function spIdpConnectionCredentialsOutboundBackChannelAuthToTerraform(struct?: SpIdpConnectionCredentialsOutboundBackChannelAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    digital_signature: cdktf.booleanToTerraform(struct!.digitalSignature),
    http_basic_credentials: spIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentialsToTerraform(struct!.httpBasicCredentials),
    ssl_auth_key_pair_ref: spIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRefToTerraform(struct!.sslAuthKeyPairRef),
    validate_partner_cert: cdktf.booleanToTerraform(struct!.validatePartnerCert),
  }
}


export function spIdpConnectionCredentialsOutboundBackChannelAuthToHclTerraform(struct?: SpIdpConnectionCredentialsOutboundBackChannelAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    digital_signature: {
      value: cdktf.booleanToHclTerraform(struct!.digitalSignature),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    http_basic_credentials: {
      value: spIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentialsToHclTerraform(struct!.httpBasicCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentials",
    },
    ssl_auth_key_pair_ref: {
      value: spIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRefToHclTerraform(struct!.sslAuthKeyPairRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRef",
    },
    validate_partner_cert: {
      value: cdktf.booleanToHclTerraform(struct!.validatePartnerCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsOutboundBackChannelAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsOutboundBackChannelAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._digitalSignature !== undefined) {
      hasAnyValues = true;
      internalValueResult.digitalSignature = this._digitalSignature;
    }
    if (this._httpBasicCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpBasicCredentials = this._httpBasicCredentials?.internalValue;
    }
    if (this._sslAuthKeyPairRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslAuthKeyPairRef = this._sslAuthKeyPairRef?.internalValue;
    }
    if (this._validatePartnerCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.validatePartnerCert = this._validatePartnerCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsOutboundBackChannelAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._digitalSignature = undefined;
      this._httpBasicCredentials.internalValue = undefined;
      this._sslAuthKeyPairRef.internalValue = undefined;
      this._validatePartnerCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._digitalSignature = value.digitalSignature;
      this._httpBasicCredentials.internalValue = value.httpBasicCredentials;
      this._sslAuthKeyPairRef.internalValue = value.sslAuthKeyPairRef;
      this._validatePartnerCert = value.validatePartnerCert;
    }
  }

  // digital_signature - computed: true, optional: true, required: false
  private _digitalSignature?: boolean | cdktf.IResolvable; 
  public get digitalSignature() {
    return this.getBooleanAttribute('digital_signature');
  }
  public set digitalSignature(value: boolean | cdktf.IResolvable) {
    this._digitalSignature = value;
  }
  public resetDigitalSignature() {
    this._digitalSignature = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get digitalSignatureInput() {
    return this._digitalSignature;
  }

  // http_basic_credentials - computed: false, optional: true, required: false
  private _httpBasicCredentials = new SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentialsOutputReference(this, "http_basic_credentials");
  public get httpBasicCredentials() {
    return this._httpBasicCredentials;
  }
  public putHttpBasicCredentials(value: SpIdpConnectionCredentialsOutboundBackChannelAuthHttpBasicCredentials) {
    this._httpBasicCredentials.internalValue = value;
  }
  public resetHttpBasicCredentials() {
    this._httpBasicCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpBasicCredentialsInput() {
    return this._httpBasicCredentials.internalValue;
  }

  // ssl_auth_key_pair_ref - computed: false, optional: true, required: false
  private _sslAuthKeyPairRef = new SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRefOutputReference(this, "ssl_auth_key_pair_ref");
  public get sslAuthKeyPairRef() {
    return this._sslAuthKeyPairRef;
  }
  public putSslAuthKeyPairRef(value: SpIdpConnectionCredentialsOutboundBackChannelAuthSslAuthKeyPairRef) {
    this._sslAuthKeyPairRef.internalValue = value;
  }
  public resetSslAuthKeyPairRef() {
    this._sslAuthKeyPairRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslAuthKeyPairRefInput() {
    return this._sslAuthKeyPairRef.internalValue;
  }

  // validate_partner_cert - computed: true, optional: true, required: false
  private _validatePartnerCert?: boolean | cdktf.IResolvable; 
  public get validatePartnerCert() {
    return this.getBooleanAttribute('validate_partner_cert');
  }
  public set validatePartnerCert(value: boolean | cdktf.IResolvable) {
    this._validatePartnerCert = value;
  }
  public resetValidatePartnerCert() {
    this._validatePartnerCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validatePartnerCertInput() {
    return this._validatePartnerCert;
  }
}
export interface SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionCredentialsSecondaryDecryptionKeyPairRefToTerraform(struct?: SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionCredentialsSecondaryDecryptionKeyPairRefToHclTerraform(struct?: SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefs {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsToTerraform(struct?: SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsToHclTerraform(struct?: SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}

export class SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsOutputReference {
    return new SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionCredentialsSigningSettingsSigningKeyPairRefToTerraform(struct?: SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionCredentialsSigningSettingsSigningKeyPairRefToHclTerraform(struct?: SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionCredentialsSigningSettings {
  /**
  * The algorithm used to sign messages sent to this partner. The default is `SHA1withDSA` for DSA certs, `SHA256withRSA` for RSA certs, and `SHA256withECDSA` for EC certs. For RSA certs, `SHA1withRSA`, `SHA384withRSA`, `SHA512withRSA`, `SHA256withRSAandMGF1`, `SHA384withRSAandMGF1` and `SHA512withRSAandMGF1` are also supported. For EC certs, `SHA384withECDSA` and `SHA512withECDSA` are also supported. If the connection is WS-Federation with JWT token type, then the possible values are RSA SHA256, RSA SHA384, RSA SHA512, RSASSA-PSS SHA256, RSASSA-PSS SHA384, RSASSA-PSS SHA512, ECDSA SHA256, ECDSA SHA384, ECDSA SHA512
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#algorithm SpIdpConnection#algorithm}
  */
  readonly algorithm?: string;
  /**
  * The list of IDs of alternative key pairs used to sign messages sent to this partner. The ID of the key pair is also known as the alias and can be found by viewing the corresponding certificate under 'Signing & Decryption Keys & Certificates' in the PingFederate admin console.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#alternative_signing_key_pair_refs SpIdpConnection#alternative_signing_key_pair_refs}
  */
  readonly alternativeSigningKeyPairRefs?: SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefs[] | cdktf.IResolvable;
  /**
  * Determines whether the signing certificate is included in the signature <KeyInfo> element. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#include_cert_in_signature SpIdpConnection#include_cert_in_signature}
  */
  readonly includeCertInSignature?: boolean | cdktf.IResolvable;
  /**
  * Determines whether the <KeyValue> element with the raw public key is included in the signature <KeyInfo> element.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#include_raw_key_in_signature SpIdpConnection#include_raw_key_in_signature}
  */
  readonly includeRawKeyInSignature?: boolean | cdktf.IResolvable;
  /**
  * A reference to a signing key pair.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#signing_key_pair_ref SpIdpConnection#signing_key_pair_ref}
  */
  readonly signingKeyPairRef?: SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRef;
}

export function spIdpConnectionCredentialsSigningSettingsToTerraform(struct?: SpIdpConnectionCredentialsSigningSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    algorithm: cdktf.stringToTerraform(struct!.algorithm),
    alternative_signing_key_pair_refs: cdktf.listMapper(spIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsToTerraform, false)(struct!.alternativeSigningKeyPairRefs),
    include_cert_in_signature: cdktf.booleanToTerraform(struct!.includeCertInSignature),
    include_raw_key_in_signature: cdktf.booleanToTerraform(struct!.includeRawKeyInSignature),
    signing_key_pair_ref: spIdpConnectionCredentialsSigningSettingsSigningKeyPairRefToTerraform(struct!.signingKeyPairRef),
  }
}


export function spIdpConnectionCredentialsSigningSettingsToHclTerraform(struct?: SpIdpConnectionCredentialsSigningSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    algorithm: {
      value: cdktf.stringToHclTerraform(struct!.algorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    alternative_signing_key_pair_refs: {
      value: cdktf.listMapperHcl(spIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsToHclTerraform, false)(struct!.alternativeSigningKeyPairRefs),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsList",
    },
    include_cert_in_signature: {
      value: cdktf.booleanToHclTerraform(struct!.includeCertInSignature),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    include_raw_key_in_signature: {
      value: cdktf.booleanToHclTerraform(struct!.includeRawKeyInSignature),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signing_key_pair_ref: {
      value: spIdpConnectionCredentialsSigningSettingsSigningKeyPairRefToHclTerraform(struct!.signingKeyPairRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsSigningSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentialsSigningSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._algorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.algorithm = this._algorithm;
    }
    if (this._alternativeSigningKeyPairRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alternativeSigningKeyPairRefs = this._alternativeSigningKeyPairRefs?.internalValue;
    }
    if (this._includeCertInSignature !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeCertInSignature = this._includeCertInSignature;
    }
    if (this._includeRawKeyInSignature !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeRawKeyInSignature = this._includeRawKeyInSignature;
    }
    if (this._signingKeyPairRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.signingKeyPairRef = this._signingKeyPairRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentialsSigningSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._algorithm = undefined;
      this._alternativeSigningKeyPairRefs.internalValue = undefined;
      this._includeCertInSignature = undefined;
      this._includeRawKeyInSignature = undefined;
      this._signingKeyPairRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._algorithm = value.algorithm;
      this._alternativeSigningKeyPairRefs.internalValue = value.alternativeSigningKeyPairRefs;
      this._includeCertInSignature = value.includeCertInSignature;
      this._includeRawKeyInSignature = value.includeRawKeyInSignature;
      this._signingKeyPairRef.internalValue = value.signingKeyPairRef;
    }
  }

  // algorithm - computed: false, optional: true, required: false
  private _algorithm?: string; 
  public get algorithm() {
    return this.getStringAttribute('algorithm');
  }
  public set algorithm(value: string) {
    this._algorithm = value;
  }
  public resetAlgorithm() {
    this._algorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get algorithmInput() {
    return this._algorithm;
  }

  // alternative_signing_key_pair_refs - computed: false, optional: true, required: false
  private _alternativeSigningKeyPairRefs = new SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefsList(this, "alternative_signing_key_pair_refs", true);
  public get alternativeSigningKeyPairRefs() {
    return this._alternativeSigningKeyPairRefs;
  }
  public putAlternativeSigningKeyPairRefs(value: SpIdpConnectionCredentialsSigningSettingsAlternativeSigningKeyPairRefs[] | cdktf.IResolvable) {
    this._alternativeSigningKeyPairRefs.internalValue = value;
  }
  public resetAlternativeSigningKeyPairRefs() {
    this._alternativeSigningKeyPairRefs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alternativeSigningKeyPairRefsInput() {
    return this._alternativeSigningKeyPairRefs.internalValue;
  }

  // include_cert_in_signature - computed: false, optional: true, required: false
  private _includeCertInSignature?: boolean | cdktf.IResolvable; 
  public get includeCertInSignature() {
    return this.getBooleanAttribute('include_cert_in_signature');
  }
  public set includeCertInSignature(value: boolean | cdktf.IResolvable) {
    this._includeCertInSignature = value;
  }
  public resetIncludeCertInSignature() {
    this._includeCertInSignature = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeCertInSignatureInput() {
    return this._includeCertInSignature;
  }

  // include_raw_key_in_signature - computed: false, optional: true, required: false
  private _includeRawKeyInSignature?: boolean | cdktf.IResolvable; 
  public get includeRawKeyInSignature() {
    return this.getBooleanAttribute('include_raw_key_in_signature');
  }
  public set includeRawKeyInSignature(value: boolean | cdktf.IResolvable) {
    this._includeRawKeyInSignature = value;
  }
  public resetIncludeRawKeyInSignature() {
    this._includeRawKeyInSignature = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeRawKeyInSignatureInput() {
    return this._includeRawKeyInSignature;
  }

  // signing_key_pair_ref - computed: false, optional: true, required: false
  private _signingKeyPairRef = new SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRefOutputReference(this, "signing_key_pair_ref");
  public get signingKeyPairRef() {
    return this._signingKeyPairRef;
  }
  public putSigningKeyPairRef(value: SpIdpConnectionCredentialsSigningSettingsSigningKeyPairRef) {
    this._signingKeyPairRef.internalValue = value;
  }
  public resetSigningKeyPairRef() {
    this._signingKeyPairRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signingKeyPairRefInput() {
    return this._signingKeyPairRef.internalValue;
  }
}
export interface SpIdpConnectionCredentials {
  /**
  * The algorithm used to encrypt assertions sent to this partner. Options are `AES_128`, `AES_256`, `AES_128_GCM`, `AES_192_GCM`, `AES_256_GCM`, `Triple_DES`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#block_encryption_algorithm SpIdpConnection#block_encryption_algorithm}
  */
  readonly blockEncryptionAlgorithm?: string;
  /**
  * The certificates used for signature verification and XML encryption.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#certs SpIdpConnection#certs}
  */
  readonly certs?: SpIdpConnectionCredentialsCerts[] | cdktf.IResolvable;
  /**
  * A reference to a resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#decryption_key_pair_ref SpIdpConnection#decryption_key_pair_ref}
  */
  readonly decryptionKeyPairRef?: SpIdpConnectionCredentialsDecryptionKeyPairRef;
  /**
  * The SOAP authentication methods when sending or receiving a message using SOAP back channel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#inbound_back_channel_auth SpIdpConnection#inbound_back_channel_auth}
  */
  readonly inboundBackChannelAuth?: SpIdpConnectionCredentialsInboundBackChannelAuth;
  /**
  * The algorithm used to transport keys to this partner. Options are `RSA_OAEP`, `RSA_OAEP_256`, `RSA_v15`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#key_transport_algorithm SpIdpConnection#key_transport_algorithm}
  */
  readonly keyTransportAlgorithm?: string;
  /**
  * The SOAP authentication methods when sending or receiving a message using SOAP back channel.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#outbound_back_channel_auth SpIdpConnection#outbound_back_channel_auth}
  */
  readonly outboundBackChannelAuth?: SpIdpConnectionCredentialsOutboundBackChannelAuth;
  /**
  * A reference to a resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#secondary_decryption_key_pair_ref SpIdpConnection#secondary_decryption_key_pair_ref}
  */
  readonly secondaryDecryptionKeyPairRef?: SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRef;
  /**
  * Settings related to signing messages sent to this partner.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#signing_settings SpIdpConnection#signing_settings}
  */
  readonly signingSettings?: SpIdpConnectionCredentialsSigningSettings;
  /**
  * If `verification_subject_dn` is provided, you can optionally restrict the issuer to a specific trusted CA by specifying its DN in this field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#verification_issuer_dn SpIdpConnection#verification_issuer_dn}
  */
  readonly verificationIssuerDn?: string;
  /**
  * If this property is set, the verification trust model is Anchored. The verification certificate must be signed by a trusted CA and included in the incoming message, and the subject DN of the expected certificate is specified in this property. If this property is not set, then a primary verification certificate must be specified in the `certs` array.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#verification_subject_dn SpIdpConnection#verification_subject_dn}
  */
  readonly verificationSubjectDn?: string;
}

export function spIdpConnectionCredentialsToTerraform(struct?: SpIdpConnectionCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    block_encryption_algorithm: cdktf.stringToTerraform(struct!.blockEncryptionAlgorithm),
    certs: cdktf.listMapper(spIdpConnectionCredentialsCertsToTerraform, false)(struct!.certs),
    decryption_key_pair_ref: spIdpConnectionCredentialsDecryptionKeyPairRefToTerraform(struct!.decryptionKeyPairRef),
    inbound_back_channel_auth: spIdpConnectionCredentialsInboundBackChannelAuthToTerraform(struct!.inboundBackChannelAuth),
    key_transport_algorithm: cdktf.stringToTerraform(struct!.keyTransportAlgorithm),
    outbound_back_channel_auth: spIdpConnectionCredentialsOutboundBackChannelAuthToTerraform(struct!.outboundBackChannelAuth),
    secondary_decryption_key_pair_ref: spIdpConnectionCredentialsSecondaryDecryptionKeyPairRefToTerraform(struct!.secondaryDecryptionKeyPairRef),
    signing_settings: spIdpConnectionCredentialsSigningSettingsToTerraform(struct!.signingSettings),
    verification_issuer_dn: cdktf.stringToTerraform(struct!.verificationIssuerDn),
    verification_subject_dn: cdktf.stringToTerraform(struct!.verificationSubjectDn),
  }
}


export function spIdpConnectionCredentialsToHclTerraform(struct?: SpIdpConnectionCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    block_encryption_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.blockEncryptionAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certs: {
      value: cdktf.listMapperHcl(spIdpConnectionCredentialsCertsToHclTerraform, false)(struct!.certs),
      isBlock: true,
      type: "list",
      storageClassType: "SpIdpConnectionCredentialsCertsList",
    },
    decryption_key_pair_ref: {
      value: spIdpConnectionCredentialsDecryptionKeyPairRefToHclTerraform(struct!.decryptionKeyPairRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsDecryptionKeyPairRef",
    },
    inbound_back_channel_auth: {
      value: spIdpConnectionCredentialsInboundBackChannelAuthToHclTerraform(struct!.inboundBackChannelAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsInboundBackChannelAuth",
    },
    key_transport_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.keyTransportAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    outbound_back_channel_auth: {
      value: spIdpConnectionCredentialsOutboundBackChannelAuthToHclTerraform(struct!.outboundBackChannelAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsOutboundBackChannelAuth",
    },
    secondary_decryption_key_pair_ref: {
      value: spIdpConnectionCredentialsSecondaryDecryptionKeyPairRefToHclTerraform(struct!.secondaryDecryptionKeyPairRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRef",
    },
    signing_settings: {
      value: spIdpConnectionCredentialsSigningSettingsToHclTerraform(struct!.signingSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionCredentialsSigningSettings",
    },
    verification_issuer_dn: {
      value: cdktf.stringToHclTerraform(struct!.verificationIssuerDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verification_subject_dn: {
      value: cdktf.stringToHclTerraform(struct!.verificationSubjectDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._blockEncryptionAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.blockEncryptionAlgorithm = this._blockEncryptionAlgorithm;
    }
    if (this._certs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certs = this._certs?.internalValue;
    }
    if (this._decryptionKeyPairRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.decryptionKeyPairRef = this._decryptionKeyPairRef?.internalValue;
    }
    if (this._inboundBackChannelAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inboundBackChannelAuth = this._inboundBackChannelAuth?.internalValue;
    }
    if (this._keyTransportAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyTransportAlgorithm = this._keyTransportAlgorithm;
    }
    if (this._outboundBackChannelAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outboundBackChannelAuth = this._outboundBackChannelAuth?.internalValue;
    }
    if (this._secondaryDecryptionKeyPairRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondaryDecryptionKeyPairRef = this._secondaryDecryptionKeyPairRef?.internalValue;
    }
    if (this._signingSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.signingSettings = this._signingSettings?.internalValue;
    }
    if (this._verificationIssuerDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.verificationIssuerDn = this._verificationIssuerDn;
    }
    if (this._verificationSubjectDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.verificationSubjectDn = this._verificationSubjectDn;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._blockEncryptionAlgorithm = undefined;
      this._certs.internalValue = undefined;
      this._decryptionKeyPairRef.internalValue = undefined;
      this._inboundBackChannelAuth.internalValue = undefined;
      this._keyTransportAlgorithm = undefined;
      this._outboundBackChannelAuth.internalValue = undefined;
      this._secondaryDecryptionKeyPairRef.internalValue = undefined;
      this._signingSettings.internalValue = undefined;
      this._verificationIssuerDn = undefined;
      this._verificationSubjectDn = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._blockEncryptionAlgorithm = value.blockEncryptionAlgorithm;
      this._certs.internalValue = value.certs;
      this._decryptionKeyPairRef.internalValue = value.decryptionKeyPairRef;
      this._inboundBackChannelAuth.internalValue = value.inboundBackChannelAuth;
      this._keyTransportAlgorithm = value.keyTransportAlgorithm;
      this._outboundBackChannelAuth.internalValue = value.outboundBackChannelAuth;
      this._secondaryDecryptionKeyPairRef.internalValue = value.secondaryDecryptionKeyPairRef;
      this._signingSettings.internalValue = value.signingSettings;
      this._verificationIssuerDn = value.verificationIssuerDn;
      this._verificationSubjectDn = value.verificationSubjectDn;
    }
  }

  // block_encryption_algorithm - computed: false, optional: true, required: false
  private _blockEncryptionAlgorithm?: string; 
  public get blockEncryptionAlgorithm() {
    return this.getStringAttribute('block_encryption_algorithm');
  }
  public set blockEncryptionAlgorithm(value: string) {
    this._blockEncryptionAlgorithm = value;
  }
  public resetBlockEncryptionAlgorithm() {
    this._blockEncryptionAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockEncryptionAlgorithmInput() {
    return this._blockEncryptionAlgorithm;
  }

  // certs - computed: true, optional: true, required: false
  private _certs = new SpIdpConnectionCredentialsCertsList(this, "certs", false);
  public get certs() {
    return this._certs;
  }
  public putCerts(value: SpIdpConnectionCredentialsCerts[] | cdktf.IResolvable) {
    this._certs.internalValue = value;
  }
  public resetCerts() {
    this._certs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certsInput() {
    return this._certs.internalValue;
  }

  // decryption_key_pair_ref - computed: false, optional: true, required: false
  private _decryptionKeyPairRef = new SpIdpConnectionCredentialsDecryptionKeyPairRefOutputReference(this, "decryption_key_pair_ref");
  public get decryptionKeyPairRef() {
    return this._decryptionKeyPairRef;
  }
  public putDecryptionKeyPairRef(value: SpIdpConnectionCredentialsDecryptionKeyPairRef) {
    this._decryptionKeyPairRef.internalValue = value;
  }
  public resetDecryptionKeyPairRef() {
    this._decryptionKeyPairRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get decryptionKeyPairRefInput() {
    return this._decryptionKeyPairRef.internalValue;
  }

  // inbound_back_channel_auth - computed: false, optional: true, required: false
  private _inboundBackChannelAuth = new SpIdpConnectionCredentialsInboundBackChannelAuthOutputReference(this, "inbound_back_channel_auth");
  public get inboundBackChannelAuth() {
    return this._inboundBackChannelAuth;
  }
  public putInboundBackChannelAuth(value: SpIdpConnectionCredentialsInboundBackChannelAuth) {
    this._inboundBackChannelAuth.internalValue = value;
  }
  public resetInboundBackChannelAuth() {
    this._inboundBackChannelAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inboundBackChannelAuthInput() {
    return this._inboundBackChannelAuth.internalValue;
  }

  // key_transport_algorithm - computed: false, optional: true, required: false
  private _keyTransportAlgorithm?: string; 
  public get keyTransportAlgorithm() {
    return this.getStringAttribute('key_transport_algorithm');
  }
  public set keyTransportAlgorithm(value: string) {
    this._keyTransportAlgorithm = value;
  }
  public resetKeyTransportAlgorithm() {
    this._keyTransportAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyTransportAlgorithmInput() {
    return this._keyTransportAlgorithm;
  }

  // outbound_back_channel_auth - computed: false, optional: true, required: false
  private _outboundBackChannelAuth = new SpIdpConnectionCredentialsOutboundBackChannelAuthOutputReference(this, "outbound_back_channel_auth");
  public get outboundBackChannelAuth() {
    return this._outboundBackChannelAuth;
  }
  public putOutboundBackChannelAuth(value: SpIdpConnectionCredentialsOutboundBackChannelAuth) {
    this._outboundBackChannelAuth.internalValue = value;
  }
  public resetOutboundBackChannelAuth() {
    this._outboundBackChannelAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outboundBackChannelAuthInput() {
    return this._outboundBackChannelAuth.internalValue;
  }

  // secondary_decryption_key_pair_ref - computed: false, optional: true, required: false
  private _secondaryDecryptionKeyPairRef = new SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRefOutputReference(this, "secondary_decryption_key_pair_ref");
  public get secondaryDecryptionKeyPairRef() {
    return this._secondaryDecryptionKeyPairRef;
  }
  public putSecondaryDecryptionKeyPairRef(value: SpIdpConnectionCredentialsSecondaryDecryptionKeyPairRef) {
    this._secondaryDecryptionKeyPairRef.internalValue = value;
  }
  public resetSecondaryDecryptionKeyPairRef() {
    this._secondaryDecryptionKeyPairRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondaryDecryptionKeyPairRefInput() {
    return this._secondaryDecryptionKeyPairRef.internalValue;
  }

  // signing_settings - computed: false, optional: true, required: false
  private _signingSettings = new SpIdpConnectionCredentialsSigningSettingsOutputReference(this, "signing_settings");
  public get signingSettings() {
    return this._signingSettings;
  }
  public putSigningSettings(value: SpIdpConnectionCredentialsSigningSettings) {
    this._signingSettings.internalValue = value;
  }
  public resetSigningSettings() {
    this._signingSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signingSettingsInput() {
    return this._signingSettings.internalValue;
  }

  // verification_issuer_dn - computed: false, optional: true, required: false
  private _verificationIssuerDn?: string; 
  public get verificationIssuerDn() {
    return this.getStringAttribute('verification_issuer_dn');
  }
  public set verificationIssuerDn(value: string) {
    this._verificationIssuerDn = value;
  }
  public resetVerificationIssuerDn() {
    this._verificationIssuerDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verificationIssuerDnInput() {
    return this._verificationIssuerDn;
  }

  // verification_subject_dn - computed: false, optional: true, required: false
  private _verificationSubjectDn?: string; 
  public get verificationSubjectDn() {
    return this.getStringAttribute('verification_subject_dn');
  }
  public set verificationSubjectDn(value: string) {
    this._verificationSubjectDn = value;
  }
  public resetVerificationSubjectDn() {
    this._verificationSubjectDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verificationSubjectDnInput() {
    return this._verificationSubjectDn;
  }
}
export interface SpIdpConnectionExtendedProperties {
  /**
  * A Set of values
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#values SpIdpConnection#values}
  */
  readonly values?: string[];
}

export function spIdpConnectionExtendedPropertiesToTerraform(struct?: SpIdpConnectionExtendedProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function spIdpConnectionExtendedPropertiesToHclTerraform(struct?: SpIdpConnectionExtendedProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionExtendedPropertiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionExtendedProperties | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionExtendedProperties | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._values = value.values;
    }
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return cdktf.Fn.tolist(this.getListAttribute('values'));
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class SpIdpConnectionExtendedPropertiesMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionExtendedProperties } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionExtendedPropertiesOutputReference {
    return new SpIdpConnectionExtendedPropertiesOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributes {
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributes): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributes): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributes | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributes | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributesList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributes {
  /**
  * The name of this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContract {
  /**
  * A list of additional attributes that can be returned by the SP adapter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#extended_attributes SpIdpConnection#extended_attributes}
  */
  readonly extendedAttributes?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributes[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContract | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    extended_attributes: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesToTerraform, false)(struct!.extendedAttributes),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContract | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    extended_attributes: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesToHclTerraform, false)(struct!.extendedAttributes),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContract | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._extendedAttributes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedAttributes = this._extendedAttributes?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContract | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._extendedAttributes.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._extendedAttributes.internalValue = value.extendedAttributes;
    }
  }

  // core_attributes - computed: true, optional: false, required: false
  private _coreAttributes = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractCoreAttributesList(this, "core_attributes", true);
  public get coreAttributes() {
    return this._coreAttributes;
  }

  // extended_attributes - computed: false, optional: true, required: false
  private _extendedAttributes = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributesList(this, "extended_attributes", true);
  public get extendedAttributes() {
    return this._extendedAttributes;
  }
  public putExtendedAttributes(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractExtendedAttributes[] | cdktf.IResolvable) {
    this._extendedAttributes.internalValue = value;
  }
  public resetExtendedAttributes() {
    this._extendedAttributes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedAttributesInput() {
    return this._extendedAttributes.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFields {
  /**
  * The name of the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The value for the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAll {
  /**
  * The name of the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The value for the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAllToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAll): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAllToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAll): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAll | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAll | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAllList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAllOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFields {
  /**
  * For encrypted or hashed fields, this attribute contains the encrypted representation of the field's value, if a value is defined. Either this attribute or `value` must be specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#encrypted_value SpIdpConnection#encrypted_value}
  */
  readonly encryptedValue?: string;
  /**
  * The name of the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The sensitive value for the configuration field. Either this attribute or `encrypted_value` must be specified`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    encrypted_value: cdktf.stringToTerraform(struct!.encryptedValue),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    encrypted_value: {
      value: cdktf.stringToHclTerraform(struct!.encryptedValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._encryptedValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptedValue = this._encryptedValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._encryptedValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._encryptedValue = value.encryptedValue;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // encrypted_value - computed: true, optional: true, required: false
  private _encryptedValue?: string; 
  public get encryptedValue() {
    return this.getStringAttribute('encrypted_value');
  }
  public set encryptedValue(value: string) {
    this._encryptedValue = value;
  }
  public resetEncryptedValue() {
    this._encryptedValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptedValueInput() {
    return this._encryptedValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFields {
  /**
  * The name of the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The value for the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFields {
  /**
  * For encrypted or hashed fields, this attribute contains the encrypted representation of the field's value, if a value is defined. Either this attribute or `value` must be specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#encrypted_value SpIdpConnection#encrypted_value}
  */
  readonly encryptedValue?: string;
  /**
  * The name of the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The sensitive value for the configuration field. Either this attribute or `encrypted_value` must be specified`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    encrypted_value: cdktf.stringToTerraform(struct!.encryptedValue),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    encrypted_value: {
      value: cdktf.stringToHclTerraform(struct!.encryptedValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._encryptedValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptedValue = this._encryptedValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._encryptedValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._encryptedValue = value.encryptedValue;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // encrypted_value - computed: true, optional: true, required: false
  private _encryptedValue?: string; 
  public get encryptedValue() {
    return this.getStringAttribute('encrypted_value');
  }
  public set encryptedValue(value: string) {
    this._encryptedValue = value;
  }
  public resetEncryptedValue() {
    this._encryptedValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptedValueInput() {
    return this._encryptedValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRows {
  /**
  * Whether this row is the default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#default_row SpIdpConnection#default_row}
  */
  readonly defaultRow?: boolean | cdktf.IResolvable;
  /**
  * The configuration fields in the row.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#fields SpIdpConnection#fields}
  */
  readonly fields?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFields[] | cdktf.IResolvable;
  /**
  * The sensitive configuration fields in the row.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#sensitive_fields SpIdpConnection#sensitive_fields}
  */
  readonly sensitiveFields?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFields[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRows | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_row: cdktf.booleanToTerraform(struct!.defaultRow),
    fields: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsToTerraform, false)(struct!.fields),
    sensitive_fields: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsToTerraform, false)(struct!.sensitiveFields),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRows | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_row: {
      value: cdktf.booleanToHclTerraform(struct!.defaultRow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    fields: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsToHclTerraform, false)(struct!.fields),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsList",
    },
    sensitive_fields: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsToHclTerraform, false)(struct!.sensitiveFields),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRows | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultRow !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultRow = this._defaultRow;
    }
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._sensitiveFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sensitiveFields = this._sensitiveFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRows | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultRow = undefined;
      this._fields.internalValue = undefined;
      this._sensitiveFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultRow = value.defaultRow;
      this._fields.internalValue = value.fields;
      this._sensitiveFields.internalValue = value.sensitiveFields;
    }
  }

  // default_row - computed: true, optional: true, required: false
  private _defaultRow?: boolean | cdktf.IResolvable; 
  public get defaultRow() {
    return this.getBooleanAttribute('default_row');
  }
  public set defaultRow(value: boolean | cdktf.IResolvable) {
    this._defaultRow = value;
  }
  public resetDefaultRow() {
    this._defaultRow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultRowInput() {
    return this._defaultRow;
  }

  // fields - computed: true, optional: true, required: false
  private _fields = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFieldsList(this, "fields", true);
  public get fields() {
    return this._fields;
  }
  public putFields(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsFields[] | cdktf.IResolvable) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // sensitive_fields - computed: true, optional: true, required: false
  private _sensitiveFields = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFieldsList(this, "sensitive_fields", true);
  public get sensitiveFields() {
    return this._sensitiveFields;
  }
  public putSensitiveFields(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsSensitiveFields[] | cdktf.IResolvable) {
    this._sensitiveFields.internalValue = value;
  }
  public resetSensitiveFields() {
    this._sensitiveFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sensitiveFieldsInput() {
    return this._sensitiveFields.internalValue;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRows[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTables {
  /**
  * The name of the table.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * List of table rows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#rows SpIdpConnection#rows}
  */
  readonly rows?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRows[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    rows: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsToTerraform, false)(struct!.rows),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rows: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsToHclTerraform, false)(struct!.rows),
      isBlock: true,
      type: "list",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTables | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._rows?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rows = this._rows?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTables | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._rows.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._rows.internalValue = value.rows;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // rows - computed: true, optional: true, required: false
  private _rows = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRowsList(this, "rows", false);
  public get rows() {
    return this._rows;
  }
  public putRows(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesRows[] | cdktf.IResolvable) {
    this._rows.internalValue = value;
  }
  public resetRows() {
    this._rows.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rowsInput() {
    return this._rows.internalValue;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTables[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFields {
  /**
  * The name of the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The value for the configuration field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRows {
  /**
  * Whether this row is the default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#default_row SpIdpConnection#default_row}
  */
  readonly defaultRow?: boolean | cdktf.IResolvable;
  /**
  * The configuration fields in the row.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#fields SpIdpConnection#fields}
  */
  readonly fields?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFields[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRows | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_row: cdktf.booleanToTerraform(struct!.defaultRow),
    fields: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsToTerraform, false)(struct!.fields),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRows | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_row: {
      value: cdktf.booleanToHclTerraform(struct!.defaultRow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    fields: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsToHclTerraform, false)(struct!.fields),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRows | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultRow !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultRow = this._defaultRow;
    }
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRows | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultRow = undefined;
      this._fields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultRow = value.defaultRow;
      this._fields.internalValue = value.fields;
    }
  }

  // default_row - computed: true, optional: true, required: false
  private _defaultRow?: boolean | cdktf.IResolvable; 
  public get defaultRow() {
    return this.getBooleanAttribute('default_row');
  }
  public set defaultRow(value: boolean | cdktf.IResolvable) {
    this._defaultRow = value;
  }
  public resetDefaultRow() {
    this._defaultRow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultRowInput() {
    return this._defaultRow;
  }

  // fields - computed: true, optional: true, required: false
  private _fields = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFieldsList(this, "fields", true);
  public get fields() {
    return this._fields;
  }
  public putFields(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsFields[] | cdktf.IResolvable) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRows[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAll {
  /**
  * The name of the table.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * List of table rows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#rows SpIdpConnection#rows}
  */
  readonly rows?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRows[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAll): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    rows: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsToTerraform, false)(struct!.rows),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAll): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rows: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsToHclTerraform, false)(struct!.rows),
      isBlock: true,
      type: "list",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAll | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._rows?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rows = this._rows?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAll | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
      this._rows.internalValue = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
      this._rows.internalValue = value.rows;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // rows - computed: true, optional: true, required: false
  private _rows = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRowsList(this, "rows", false);
  public get rows() {
    return this._rows;
  }
  public putRows(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllRows[] | cdktf.IResolvable) {
    this._rows.internalValue = value;
  }
  public resetRows() {
    this._rows.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rowsInput() {
    return this._rows.internalValue;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAll[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfiguration {
  /**
  * List of configuration fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#fields SpIdpConnection#fields}
  */
  readonly fields?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFields[] | cdktf.IResolvable;
  /**
  * List of sensitive configuration fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#sensitive_fields SpIdpConnection#sensitive_fields}
  */
  readonly sensitiveFields?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFields[] | cdktf.IResolvable;
  /**
  * List of configuration tables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#tables SpIdpConnection#tables}
  */
  readonly tables?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTables[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfiguration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsToTerraform, false)(struct!.fields),
    sensitive_fields: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsToTerraform, false)(struct!.sensitiveFields),
    tables: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesToTerraform, false)(struct!.tables),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfiguration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsToHclTerraform, false)(struct!.fields),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsList",
    },
    sensitive_fields: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsToHclTerraform, false)(struct!.sensitiveFields),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsList",
    },
    tables: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesToHclTerraform, false)(struct!.tables),
      isBlock: true,
      type: "list",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfiguration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._sensitiveFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sensitiveFields = this._sensitiveFields?.internalValue;
    }
    if (this._tables?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tables = this._tables?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfiguration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields.internalValue = undefined;
      this._sensitiveFields.internalValue = undefined;
      this._tables.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields.internalValue = value.fields;
      this._sensitiveFields.internalValue = value.sensitiveFields;
      this._tables.internalValue = value.tables;
    }
  }

  // fields - computed: true, optional: true, required: false
  private _fields = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsList(this, "fields", true);
  public get fields() {
    return this._fields;
  }
  public putFields(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFields[] | cdktf.IResolvable) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // fields_all - computed: true, optional: false, required: false
  private _fieldsAll = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationFieldsAllList(this, "fields_all", true);
  public get fieldsAll() {
    return this._fieldsAll;
  }

  // sensitive_fields - computed: true, optional: true, required: false
  private _sensitiveFields = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFieldsList(this, "sensitive_fields", true);
  public get sensitiveFields() {
    return this._sensitiveFields;
  }
  public putSensitiveFields(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationSensitiveFields[] | cdktf.IResolvable) {
    this._sensitiveFields.internalValue = value;
  }
  public resetSensitiveFields() {
    this._sensitiveFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sensitiveFieldsInput() {
    return this._sensitiveFields.internalValue;
  }

  // tables - computed: true, optional: true, required: false
  private _tables = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesList(this, "tables", false);
  public get tables() {
    return this._tables;
  }
  public putTables(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTables[] | cdktf.IResolvable) {
    this._tables.internalValue = value;
  }
  public resetTables() {
    this._tables.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tablesInput() {
    return this._tables.internalValue;
  }

  // tables_all - computed: true, optional: false, required: false
  private _tablesAll = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationTablesAllList(this, "tables_all", false);
  public get tablesAll() {
    return this._tablesAll;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfo {
  /**
  * The application icon URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#application_icon_url SpIdpConnection#application_icon_url}
  */
  readonly applicationIconUrl?: string;
  /**
  * The application name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#application_name SpIdpConnection#application_name}
  */
  readonly applicationName?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfoToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    application_icon_url: cdktf.stringToTerraform(struct!.applicationIconUrl),
    application_name: cdktf.stringToTerraform(struct!.applicationName),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfoToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    application_icon_url: {
      value: cdktf.stringToHclTerraform(struct!.applicationIconUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    application_name: {
      value: cdktf.stringToHclTerraform(struct!.applicationName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._applicationIconUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.applicationIconUrl = this._applicationIconUrl;
    }
    if (this._applicationName !== undefined) {
      hasAnyValues = true;
      internalValueResult.applicationName = this._applicationName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._applicationIconUrl = undefined;
      this._applicationName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._applicationIconUrl = value.applicationIconUrl;
      this._applicationName = value.applicationName;
    }
  }

  // application_icon_url - computed: true, optional: true, required: false
  private _applicationIconUrl?: string; 
  public get applicationIconUrl() {
    return this.getStringAttribute('application_icon_url');
  }
  public set applicationIconUrl(value: string) {
    this._applicationIconUrl = value;
  }
  public resetApplicationIconUrl() {
    this._applicationIconUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applicationIconUrlInput() {
    return this._applicationIconUrl;
  }

  // application_name - computed: true, optional: true, required: false
  private _applicationName?: string; 
  public get applicationName() {
    return this.getStringAttribute('application_name');
  }
  public set applicationName(value: string) {
    this._applicationName = value;
  }
  public resetApplicationName() {
    this._applicationName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applicationNameInput() {
    return this._applicationName;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract SpIdpConnection#attribute_contract}
  */
  readonly attributeContract?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContract;
  /**
  * Plugin instance configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#configuration SpIdpConnection#configuration}
  */
  readonly configuration: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfiguration;
  /**
  * The ID of the plugin instance. The ID cannot be modified once the instance is created.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * The plugin instance name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name?: string;
  /**
  * The reference to this plugin's parent instance. The parent reference is only accepted if the plugin type supports parent instances.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#parent_ref SpIdpConnection#parent_ref}
  */
  readonly parentRef?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRef;
  /**
  * Reference to the plugin descriptor for this instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#plugin_descriptor_ref SpIdpConnection#plugin_descriptor_ref}
  */
  readonly pluginDescriptorRef?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#target_application_info SpIdpConnection#target_application_info}
  */
  readonly targetApplicationInfo?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfo;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractToTerraform(struct!.attributeContract),
    configuration: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationToTerraform(struct!.configuration),
    id: cdktf.stringToTerraform(struct!.id),
    name: cdktf.stringToTerraform(struct!.name),
    parent_ref: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRefToTerraform(struct!.parentRef),
    plugin_descriptor_ref: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRefToTerraform(struct!.pluginDescriptorRef),
    target_application_info: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfoToTerraform(struct!.targetApplicationInfo),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractToHclTerraform(struct!.attributeContract),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContract",
    },
    configuration: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationToHclTerraform(struct!.configuration),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfiguration",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parent_ref: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRefToHclTerraform(struct!.parentRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRef",
    },
    plugin_descriptor_ref: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRefToHclTerraform(struct!.pluginDescriptorRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRef",
    },
    target_application_info: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfoToHclTerraform(struct!.targetApplicationInfo),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfo",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContract?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContract = this._attributeContract?.internalValue;
    }
    if (this._configuration?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configuration = this._configuration?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._parentRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.parentRef = this._parentRef?.internalValue;
    }
    if (this._pluginDescriptorRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginDescriptorRef = this._pluginDescriptorRef?.internalValue;
    }
    if (this._targetApplicationInfo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetApplicationInfo = this._targetApplicationInfo?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContract.internalValue = undefined;
      this._configuration.internalValue = undefined;
      this._id = undefined;
      this._name = undefined;
      this._parentRef.internalValue = undefined;
      this._pluginDescriptorRef.internalValue = undefined;
      this._targetApplicationInfo.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContract.internalValue = value.attributeContract;
      this._configuration.internalValue = value.configuration;
      this._id = value.id;
      this._name = value.name;
      this._parentRef.internalValue = value.parentRef;
      this._pluginDescriptorRef.internalValue = value.pluginDescriptorRef;
      this._targetApplicationInfo.internalValue = value.targetApplicationInfo;
    }
  }

  // attribute_contract - computed: false, optional: true, required: false
  private _attributeContract = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContractOutputReference(this, "attribute_contract");
  public get attributeContract() {
    return this._attributeContract;
  }
  public putAttributeContract(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsAttributeContract) {
    this._attributeContract.internalValue = value;
  }
  public resetAttributeContract() {
    this._attributeContract.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractInput() {
    return this._attributeContract.internalValue;
  }

  // configuration - computed: false, optional: false, required: true
  private _configuration = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfigurationOutputReference(this, "configuration");
  public get configuration() {
    return this._configuration;
  }
  public putConfiguration(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsConfiguration) {
    this._configuration.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get configurationInput() {
    return this._configuration.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // parent_ref - computed: false, optional: true, required: false
  private _parentRef = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRefOutputReference(this, "parent_ref");
  public get parentRef() {
    return this._parentRef;
  }
  public putParentRef(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsParentRef) {
    this._parentRef.internalValue = value;
  }
  public resetParentRef() {
    this._parentRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parentRefInput() {
    return this._parentRef.internalValue;
  }

  // plugin_descriptor_ref - computed: false, optional: true, required: false
  private _pluginDescriptorRef = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRefOutputReference(this, "plugin_descriptor_ref");
  public get pluginDescriptorRef() {
    return this._pluginDescriptorRef;
  }
  public putPluginDescriptorRef(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsPluginDescriptorRef) {
    this._pluginDescriptorRef.internalValue = value;
  }
  public resetPluginDescriptorRef() {
    this._pluginDescriptorRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginDescriptorRefInput() {
    return this._pluginDescriptorRef.internalValue;
  }

  // target_application_info - computed: true, optional: true, required: false
  private _targetApplicationInfo = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfoOutputReference(this, "target_application_info");
  public get targetApplicationInfo() {
    return this._targetApplicationInfo;
  }
  public putTargetApplicationInfo(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsTargetApplicationInfo) {
    this._targetApplicationInfo.internalValue = value;
  }
  public resetTargetApplicationInfo() {
    this._targetApplicationInfo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetApplicationInfoInput() {
    return this._targetApplicationInfo.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: false, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFields {
  /**
  * The name of this field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The value of this field. Whether or not the value is required will be determined by plugin validation checks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * The list of fields that can be used to filter a request to the custom data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#filter_fields SpIdpConnection#filter_fields}
  */
  readonly filterFields?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    data_store_ref: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    filter_fields: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsToTerraform, false)(struct!.filterFields),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter_fields: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsToHclTerraform, false)(struct!.filterFields),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filterFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterFields = this._filterFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._filterFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._filterFields.internalValue = value.filterFields;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter_fields - computed: true, optional: true, required: false
  private _filterFields = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFieldsList(this, "filter_fields", true);
  public get filterFields() {
    return this._filterFields;
  }
  public putFilterFields(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable) {
    this._filterFields.internalValue = value;
  }
  public resetFilterFields() {
    this._filterFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterFieldsInput() {
    return this._filterFields.internalValue;
  }

  // type - computed: true, optional: false, required: false
  public get type() {
    return this.getStringAttribute('type');
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * A list of column names used to construct the SQL query to retrieve data from the specified table in the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#column_names SpIdpConnection#column_names}
  */
  readonly columnNames?: string[];
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * The JDBC WHERE clause used to query your data store to locate a user record.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#filter SpIdpConnection#filter}
  */
  readonly filter: string;
  /**
  * Lists the table structure that stores information within a database. Some databases, such as Oracle, require a schema for a JDBC query. Other databases, such as MySQL, do not require a schema.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#schema SpIdpConnection#schema}
  */
  readonly schema?: string;
  /**
  * The name of the database table. The name is used to construct the SQL query to retrieve data from the data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#table SpIdpConnection#table}
  */
  readonly table: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    column_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.columnNames),
    data_store_ref: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
    schema: cdktf.stringToTerraform(struct!.schema),
    table: cdktf.stringToTerraform(struct!.table),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap",
    },
    column_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.columnNames),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    table: {
      value: cdktf.stringToHclTerraform(struct!.table),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._columnNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnNames = this._columnNames;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._table !== undefined) {
      hasAnyValues = true;
      internalValueResult.table = this._table;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._columnNames = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._filter = undefined;
      this._schema = undefined;
      this._table = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._columnNames = value.columnNames;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._filter = value.filter;
      this._schema = value.schema;
      this._table = value.table;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // column_names - computed: true, optional: true, required: false
  private _columnNames?: string[]; 
  public get columnNames() {
    return cdktf.Fn.tolist(this.getListAttribute('column_names'));
  }
  public set columnNames(value: string[]) {
    this._columnNames = value;
  }
  public resetColumnNames() {
    this._columnNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnNamesInput() {
    return this._columnNames;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: true, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // schema - computed: true, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // table - computed: true, optional: false, required: true
  private _table?: string; 
  public get table() {
    return this.getStringAttribute('table');
  }
  public set table(value: string) {
    this._table = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tableInput() {
    return this._table;
  }

  // type - computed: true, optional: false, required: false
  public get type() {
    return this.getStringAttribute('type');
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings {
  /**
  * Get the encoding type for this attribute. If not specified, the default is BASE64.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#binary_encoding SpIdpConnection#binary_encoding}
  */
  readonly binaryEncoding?: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    binary_encoding: cdktf.stringToTerraform(struct!.binaryEncoding),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    binary_encoding: {
      value: cdktf.stringToHclTerraform(struct!.binaryEncoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._binaryEncoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.binaryEncoding = this._binaryEncoding;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._binaryEncoding = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._binaryEncoding = value.binaryEncoding;
    }
  }

  // binary_encoding - computed: true, optional: true, required: false
  private _binaryEncoding?: string; 
  public get binaryEncoding() {
    return this.getStringAttribute('binary_encoding');
  }
  public set binaryEncoding(value: string) {
    this._binaryEncoding = value;
  }
  public resetBinaryEncoding() {
    this._binaryEncoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get binaryEncodingInput() {
    return this._binaryEncoding;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * The base DN to search from. If not specified, the search will start at the LDAP's root.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#base_dn SpIdpConnection#base_dn}
  */
  readonly baseDn?: string;
  /**
  * The advanced settings for binary LDAP attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#binary_attribute_settings SpIdpConnection#binary_attribute_settings}
  */
  readonly binaryAttributeSettings?: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable;
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * Set this to true to return transitive group memberships for the 'memberOf' attribute.  This only applies for Active Directory data sources.  All other data sources will be set to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#member_of_nested_group SpIdpConnection#member_of_nested_group}
  */
  readonly memberOfNestedGroup?: boolean | cdktf.IResolvable;
  /**
  * A list of LDAP attributes returned from search and available for mapping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_attributes SpIdpConnection#search_attributes}
  */
  readonly searchAttributes?: string[];
  /**
  * The LDAP filter that will be used to lookup the objects from the directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_filter SpIdpConnection#search_filter}
  */
  readonly searchFilter: string;
  /**
  * Determines the node depth of the query.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_scope SpIdpConnection#search_scope}
  */
  readonly searchScope: string;
  /**
  * The data store type of this attribute source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    base_dn: cdktf.stringToTerraform(struct!.baseDn),
    binary_attribute_settings: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToTerraform)(struct!.binaryAttributeSettings),
    data_store_ref: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    member_of_nested_group: cdktf.booleanToTerraform(struct!.memberOfNestedGroup),
    search_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.searchAttributes),
    search_filter: cdktf.stringToTerraform(struct!.searchFilter),
    search_scope: cdktf.stringToTerraform(struct!.searchScope),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap",
    },
    base_dn: {
      value: cdktf.stringToHclTerraform(struct!.baseDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    binary_attribute_settings: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToHclTerraform)(struct!.binaryAttributeSettings),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    member_of_nested_group: {
      value: cdktf.booleanToHclTerraform(struct!.memberOfNestedGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    search_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.searchAttributes),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    search_filter: {
      value: cdktf.stringToHclTerraform(struct!.searchFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_scope: {
      value: cdktf.stringToHclTerraform(struct!.searchScope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._baseDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseDn = this._baseDn;
    }
    if (this._binaryAttributeSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.binaryAttributeSettings = this._binaryAttributeSettings?.internalValue;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._memberOfNestedGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.memberOfNestedGroup = this._memberOfNestedGroup;
    }
    if (this._searchAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchAttributes = this._searchAttributes;
    }
    if (this._searchFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchFilter = this._searchFilter;
    }
    if (this._searchScope !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchScope = this._searchScope;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._baseDn = undefined;
      this._binaryAttributeSettings.internalValue = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._memberOfNestedGroup = undefined;
      this._searchAttributes = undefined;
      this._searchFilter = undefined;
      this._searchScope = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._baseDn = value.baseDn;
      this._binaryAttributeSettings.internalValue = value.binaryAttributeSettings;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._memberOfNestedGroup = value.memberOfNestedGroup;
      this._searchAttributes = value.searchAttributes;
      this._searchFilter = value.searchFilter;
      this._searchScope = value.searchScope;
      this._type = value.type;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // base_dn - computed: true, optional: true, required: false
  private _baseDn?: string; 
  public get baseDn() {
    return this.getStringAttribute('base_dn');
  }
  public set baseDn(value: string) {
    this._baseDn = value;
  }
  public resetBaseDn() {
    this._baseDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseDnInput() {
    return this._baseDn;
  }

  // binary_attribute_settings - computed: true, optional: true, required: false
  private _binaryAttributeSettings = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap(this, "binary_attribute_settings");
  public get binaryAttributeSettings() {
    return this._binaryAttributeSettings;
  }
  public putBinaryAttributeSettings(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable) {
    this._binaryAttributeSettings.internalValue = value;
  }
  public resetBinaryAttributeSettings() {
    this._binaryAttributeSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get binaryAttributeSettingsInput() {
    return this._binaryAttributeSettings.internalValue;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // member_of_nested_group - computed: true, optional: true, required: false
  private _memberOfNestedGroup?: boolean | cdktf.IResolvable; 
  public get memberOfNestedGroup() {
    return this.getBooleanAttribute('member_of_nested_group');
  }
  public set memberOfNestedGroup(value: boolean | cdktf.IResolvable) {
    this._memberOfNestedGroup = value;
  }
  public resetMemberOfNestedGroup() {
    this._memberOfNestedGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memberOfNestedGroupInput() {
    return this._memberOfNestedGroup;
  }

  // search_attributes - computed: true, optional: true, required: false
  private _searchAttributes?: string[]; 
  public get searchAttributes() {
    return cdktf.Fn.tolist(this.getListAttribute('search_attributes'));
  }
  public set searchAttributes(value: string[]) {
    this._searchAttributes = value;
  }
  public resetSearchAttributes() {
    this._searchAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchAttributesInput() {
    return this._searchAttributes;
  }

  // search_filter - computed: true, optional: false, required: true
  private _searchFilter?: string; 
  public get searchFilter() {
    return this.getStringAttribute('search_filter');
  }
  public set searchFilter(value: string) {
    this._searchFilter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get searchFilterInput() {
    return this._searchFilter;
  }

  // search_scope - computed: true, optional: false, required: true
  private _searchScope?: string; 
  public get searchScope() {
    return this.getStringAttribute('search_scope');
  }
  public set searchScope(value: string) {
    this._searchScope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get searchScopeInput() {
    return this._searchScope;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSources {
  /**
  * The configured settings used to look up attributes from a custom data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#custom_attribute_source SpIdpConnection#custom_attribute_source}
  */
  readonly customAttributeSource?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSource;
  /**
  * The configured settings used to look up attributes from a JDBC data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#jdbc_attribute_source SpIdpConnection#jdbc_attribute_source}
  */
  readonly jdbcAttributeSource?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSource;
  /**
  * The configured settings used to look up attributes from a LDAP data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#ldap_attribute_source SpIdpConnection#ldap_attribute_source}
  */
  readonly ldapAttributeSource?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSource;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_attribute_source: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceToTerraform(struct!.customAttributeSource),
    jdbc_attribute_source: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceToTerraform(struct!.jdbcAttributeSource),
    ldap_attribute_source: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceToTerraform(struct!.ldapAttributeSource),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceToHclTerraform(struct!.customAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSource",
    },
    jdbc_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceToHclTerraform(struct!.jdbcAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSource",
    },
    ldap_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceToHclTerraform(struct!.ldapAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAttributeSource = this._customAttributeSource?.internalValue;
    }
    if (this._jdbcAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jdbcAttributeSource = this._jdbcAttributeSource?.internalValue;
    }
    if (this._ldapAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldapAttributeSource = this._ldapAttributeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customAttributeSource.internalValue = undefined;
      this._jdbcAttributeSource.internalValue = undefined;
      this._ldapAttributeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customAttributeSource.internalValue = value.customAttributeSource;
      this._jdbcAttributeSource.internalValue = value.jdbcAttributeSource;
      this._ldapAttributeSource.internalValue = value.ldapAttributeSource;
    }
  }

  // custom_attribute_source - computed: true, optional: true, required: false
  private _customAttributeSource = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSourceOutputReference(this, "custom_attribute_source");
  public get customAttributeSource() {
    return this._customAttributeSource;
  }
  public putCustomAttributeSource(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesCustomAttributeSource) {
    this._customAttributeSource.internalValue = value;
  }
  public resetCustomAttributeSource() {
    this._customAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customAttributeSourceInput() {
    return this._customAttributeSource.internalValue;
  }

  // jdbc_attribute_source - computed: true, optional: true, required: false
  private _jdbcAttributeSource = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSourceOutputReference(this, "jdbc_attribute_source");
  public get jdbcAttributeSource() {
    return this._jdbcAttributeSource;
  }
  public putJdbcAttributeSource(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesJdbcAttributeSource) {
    this._jdbcAttributeSource.internalValue = value;
  }
  public resetJdbcAttributeSource() {
    this._jdbcAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jdbcAttributeSourceInput() {
    return this._jdbcAttributeSource.internalValue;
  }

  // ldap_attribute_source - computed: true, optional: true, required: false
  private _ldapAttributeSource = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSourceOutputReference(this, "ldap_attribute_source");
  public get ldapAttributeSource() {
    return this._ldapAttributeSource;
  }
  public putLdapAttributeSource(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesLdapAttributeSource) {
    this._ldapAttributeSource.internalValue = value;
  }
  public resetLdapAttributeSource() {
    this._ldapAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapAttributeSourceInput() {
    return this._ldapAttributeSource.internalValue;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSources[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteria {
  /**
  * The name of the attribute to use in this issuance criterion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_name SpIdpConnection#attribute_name}
  */
  readonly attributeName: string;
  /**
  * The condition that will be applied to the source attribute's value and the expected value. Options are `EQUALS`, `EQUALS_CASE_INSENSITIVE`, `EQUALS_DN`, `NOT_EQUAL`, `NOT_EQUAL_CASE_INSENSITIVE`, `NOT_EQUAL_DN`, `MULTIVALUE_CONTAINS`, `MULTIVALUE_CONTAINS_CASE_INSENSITIVE`, `MULTIVALUE_CONTAINS_DN`, `MULTIVALUE_DOES_NOT_CONTAIN`, `MULTIVALUE_DOES_NOT_CONTAIN_CASE_INSENSITIVE`, `MULTIVALUE_DOES_NOT_CONTAIN_DN`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#condition SpIdpConnection#condition}
  */
  readonly condition: string;
  /**
  * The error result to return if this issuance criterion fails. This error result will show up in the PingFederate server logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#error_result SpIdpConnection#error_result}
  */
  readonly errorResult?: string;
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSource;
  /**
  * The expected value of this issuance criterion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_name: cdktf.stringToTerraform(struct!.attributeName),
    condition: cdktf.stringToTerraform(struct!.condition),
    error_result: cdktf.stringToTerraform(struct!.errorResult),
    source: spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.attributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    condition: {
      value: cdktf.stringToHclTerraform(struct!.condition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    error_result: {
      value: cdktf.stringToHclTerraform(struct!.errorResult),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeName = this._attributeName;
    }
    if (this._condition !== undefined) {
      hasAnyValues = true;
      internalValueResult.condition = this._condition;
    }
    if (this._errorResult !== undefined) {
      hasAnyValues = true;
      internalValueResult.errorResult = this._errorResult;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeName = undefined;
      this._condition = undefined;
      this._errorResult = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeName = value.attributeName;
      this._condition = value.condition;
      this._errorResult = value.errorResult;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // attribute_name - computed: true, optional: false, required: true
  private _attributeName?: string; 
  public get attributeName() {
    return this.getStringAttribute('attribute_name');
  }
  public set attributeName(value: string) {
    this._attributeName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeNameInput() {
    return this._attributeName;
  }

  // condition - computed: true, optional: false, required: true
  private _condition?: string; 
  public get condition() {
    return this.getStringAttribute('condition');
  }
  public set condition(value: string) {
    this._condition = value;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionInput() {
    return this._condition;
  }

  // error_result - computed: true, optional: true, required: false
  private _errorResult?: string; 
  public get errorResult() {
    return this.getStringAttribute('error_result');
  }
  public set errorResult(value: string) {
    this._errorResult = value;
  }
  public resetErrorResult() {
    this._errorResult = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorResultInput() {
    return this._errorResult;
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteria {
  /**
  * The error result to return if this issuance criterion fails. This error result will show up in the PingFederate server logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#error_result SpIdpConnection#error_result}
  */
  readonly errorResult?: string;
  /**
  * The OGNL expression to evaluate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#expression SpIdpConnection#expression}
  */
  readonly expression: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    error_result: cdktf.stringToTerraform(struct!.errorResult),
    expression: cdktf.stringToTerraform(struct!.expression),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    error_result: {
      value: cdktf.stringToHclTerraform(struct!.errorResult),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expression: {
      value: cdktf.stringToHclTerraform(struct!.expression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._errorResult !== undefined) {
      hasAnyValues = true;
      internalValueResult.errorResult = this._errorResult;
    }
    if (this._expression !== undefined) {
      hasAnyValues = true;
      internalValueResult.expression = this._expression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._errorResult = undefined;
      this._expression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._errorResult = value.errorResult;
      this._expression = value.expression;
    }
  }

  // error_result - computed: true, optional: true, required: false
  private _errorResult?: string; 
  public get errorResult() {
    return this.getStringAttribute('error_result');
  }
  public set errorResult(value: string) {
    this._errorResult = value;
  }
  public resetErrorResult() {
    this._errorResult = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorResultInput() {
    return this._errorResult;
  }

  // expression - computed: true, optional: false, required: true
  private _expression?: string; 
  public get expression() {
    return this.getStringAttribute('expression');
  }
  public set expression(value: string) {
    this._expression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionInput() {
    return this._expression;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteria {
  /**
  * A list of conditional issuance criteria where existing attributes must satisfy their conditions against expected values in order for the transaction to continue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#conditional_criteria SpIdpConnection#conditional_criteria}
  */
  readonly conditionalCriteria?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable;
  /**
  * A list of expression issuance criteria where the OGNL expressions must evaluate to true in order for the transaction to continue. Expressions must be enabled in PingFederate to use expression criteria.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#expression_criteria SpIdpConnection#expression_criteria}
  */
  readonly expressionCriteria?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    conditional_criteria: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaToTerraform, false)(struct!.conditionalCriteria),
    expression_criteria: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaToTerraform, false)(struct!.expressionCriteria),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    conditional_criteria: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaToHclTerraform, false)(struct!.conditionalCriteria),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaList",
    },
    expression_criteria: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaToHclTerraform, false)(struct!.expressionCriteria),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._conditionalCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.conditionalCriteria = this._conditionalCriteria?.internalValue;
    }
    if (this._expressionCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expressionCriteria = this._expressionCriteria?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._conditionalCriteria.internalValue = undefined;
      this._expressionCriteria.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._conditionalCriteria.internalValue = value.conditionalCriteria;
      this._expressionCriteria.internalValue = value.expressionCriteria;
    }
  }

  // conditional_criteria - computed: true, optional: true, required: false
  private _conditionalCriteria = new SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteriaList(this, "conditional_criteria", true);
  public get conditionalCriteria() {
    return this._conditionalCriteria;
  }
  public putConditionalCriteria(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable) {
    this._conditionalCriteria.internalValue = value;
  }
  public resetConditionalCriteria() {
    this._conditionalCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionalCriteriaInput() {
    return this._conditionalCriteria.internalValue;
  }

  // expression_criteria - computed: true, optional: true, required: false
  private _expressionCriteria = new SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteriaList(this, "expression_criteria", true);
  public get expressionCriteria() {
    return this._expressionCriteria;
  }
  public putExpressionCriteria(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable) {
    this._expressionCriteria.internalValue = value;
  }
  public resetExpressionCriteria() {
    this._expressionCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionCriteriaInput() {
    return this._expressionCriteria.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAdapterMappings {
  /**
  * An SP adapter instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#adapter_override_settings SpIdpConnection#adapter_override_settings}
  */
  readonly adapterOverrideSettings?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettings;
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * A list of configured data stores to look up attributes from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_sources SpIdpConnection#attribute_sources}
  */
  readonly attributeSources?: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSources[] | cdktf.IResolvable;
  /**
  * The issuance criteria that this transaction must meet before the corresponding attribute contract is fulfilled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#issuance_criteria SpIdpConnection#issuance_criteria}
  */
  readonly issuanceCriteria?: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteria;
  /**
  * Restricts this mapping to specific virtual entity IDs. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#restrict_virtual_entity_ids SpIdpConnection#restrict_virtual_entity_ids}
  */
  readonly restrictVirtualEntityIds?: boolean | cdktf.IResolvable;
  /**
  * The list of virtual server IDs that this mapping is restricted to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#restricted_virtual_entity_ids SpIdpConnection#restricted_virtual_entity_ids}
  */
  readonly restrictedVirtualEntityIds?: string[];
  /**
  * A reference to a resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#sp_adapter_ref SpIdpConnection#sp_adapter_ref}
  */
  readonly spAdapterRef?: SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRef;
}

export function spIdpConnectionIdpBrowserSsoAdapterMappingsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    adapter_override_settings: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsToTerraform(struct!.adapterOverrideSettings),
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    attribute_sources: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesToTerraform, false)(struct!.attributeSources),
    issuance_criteria: spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaToTerraform(struct!.issuanceCriteria),
    restrict_virtual_entity_ids: cdktf.booleanToTerraform(struct!.restrictVirtualEntityIds),
    restricted_virtual_entity_ids: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.restrictedVirtualEntityIds),
    sp_adapter_ref: spIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRefToTerraform(struct!.spAdapterRef),
  }
}


export function spIdpConnectionIdpBrowserSsoAdapterMappingsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAdapterMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    adapter_override_settings: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsToHclTerraform(struct!.adapterOverrideSettings),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettings",
    },
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentMap",
    },
    attribute_sources: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesToHclTerraform, false)(struct!.attributeSources),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesList",
    },
    issuance_criteria: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaToHclTerraform(struct!.issuanceCriteria),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteria",
    },
    restrict_virtual_entity_ids: {
      value: cdktf.booleanToHclTerraform(struct!.restrictVirtualEntityIds),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    restricted_virtual_entity_ids: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.restrictedVirtualEntityIds),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    sp_adapter_ref: {
      value: spIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRefToHclTerraform(struct!.spAdapterRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAdapterMappings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._adapterOverrideSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.adapterOverrideSettings = this._adapterOverrideSettings?.internalValue;
    }
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._attributeSources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeSources = this._attributeSources?.internalValue;
    }
    if (this._issuanceCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuanceCriteria = this._issuanceCriteria?.internalValue;
    }
    if (this._restrictVirtualEntityIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.restrictVirtualEntityIds = this._restrictVirtualEntityIds;
    }
    if (this._restrictedVirtualEntityIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.restrictedVirtualEntityIds = this._restrictedVirtualEntityIds;
    }
    if (this._spAdapterRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spAdapterRef = this._spAdapterRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAdapterMappings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._adapterOverrideSettings.internalValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._attributeSources.internalValue = undefined;
      this._issuanceCriteria.internalValue = undefined;
      this._restrictVirtualEntityIds = undefined;
      this._restrictedVirtualEntityIds = undefined;
      this._spAdapterRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._adapterOverrideSettings.internalValue = value.adapterOverrideSettings;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._attributeSources.internalValue = value.attributeSources;
      this._issuanceCriteria.internalValue = value.issuanceCriteria;
      this._restrictVirtualEntityIds = value.restrictVirtualEntityIds;
      this._restrictedVirtualEntityIds = value.restrictedVirtualEntityIds;
      this._spAdapterRef.internalValue = value.spAdapterRef;
    }
  }

  // adapter_override_settings - computed: false, optional: true, required: false
  private _adapterOverrideSettings = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettingsOutputReference(this, "adapter_override_settings");
  public get adapterOverrideSettings() {
    return this._adapterOverrideSettings;
  }
  public putAdapterOverrideSettings(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAdapterOverrideSettings) {
    this._adapterOverrideSettings.internalValue = value;
  }
  public resetAdapterOverrideSettings() {
    this._adapterOverrideSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adapterOverrideSettingsInput() {
    return this._adapterOverrideSettings.internalValue;
  }

  // attribute_contract_fulfillment - computed: false, optional: false, required: true
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // attribute_sources - computed: true, optional: true, required: false
  private _attributeSources = new SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSourcesList(this, "attribute_sources", true);
  public get attributeSources() {
    return this._attributeSources;
  }
  public putAttributeSources(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsAttributeSources[] | cdktf.IResolvable) {
    this._attributeSources.internalValue = value;
  }
  public resetAttributeSources() {
    this._attributeSources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeSourcesInput() {
    return this._attributeSources.internalValue;
  }

  // issuance_criteria - computed: true, optional: true, required: false
  private _issuanceCriteria = new SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteriaOutputReference(this, "issuance_criteria");
  public get issuanceCriteria() {
    return this._issuanceCriteria;
  }
  public putIssuanceCriteria(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsIssuanceCriteria) {
    this._issuanceCriteria.internalValue = value;
  }
  public resetIssuanceCriteria() {
    this._issuanceCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuanceCriteriaInput() {
    return this._issuanceCriteria.internalValue;
  }

  // restrict_virtual_entity_ids - computed: true, optional: true, required: false
  private _restrictVirtualEntityIds?: boolean | cdktf.IResolvable; 
  public get restrictVirtualEntityIds() {
    return this.getBooleanAttribute('restrict_virtual_entity_ids');
  }
  public set restrictVirtualEntityIds(value: boolean | cdktf.IResolvable) {
    this._restrictVirtualEntityIds = value;
  }
  public resetRestrictVirtualEntityIds() {
    this._restrictVirtualEntityIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restrictVirtualEntityIdsInput() {
    return this._restrictVirtualEntityIds;
  }

  // restricted_virtual_entity_ids - computed: true, optional: true, required: false
  private _restrictedVirtualEntityIds?: string[]; 
  public get restrictedVirtualEntityIds() {
    return cdktf.Fn.tolist(this.getListAttribute('restricted_virtual_entity_ids'));
  }
  public set restrictedVirtualEntityIds(value: string[]) {
    this._restrictedVirtualEntityIds = value;
  }
  public resetRestrictedVirtualEntityIds() {
    this._restrictedVirtualEntityIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restrictedVirtualEntityIdsInput() {
    return this._restrictedVirtualEntityIds;
  }

  // sp_adapter_ref - computed: false, optional: true, required: false
  private _spAdapterRef = new SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRefOutputReference(this, "sp_adapter_ref");
  public get spAdapterRef() {
    return this._spAdapterRef;
  }
  public putSpAdapterRef(value: SpIdpConnectionIdpBrowserSsoAdapterMappingsSpAdapterRef) {
    this._spAdapterRef.internalValue = value;
  }
  public resetSpAdapterRef() {
    this._spAdapterRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spAdapterRefInput() {
    return this._spAdapterRef.internalValue;
  }
}

export class SpIdpConnectionIdpBrowserSsoAdapterMappingsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAdapterMappings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAdapterMappingsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAdapterMappingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoArtifactResolverLocations {
  /**
  * The priority of the endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#index SpIdpConnection#index}
  */
  readonly index: number;
  /**
  * Remote party URLs that you will use to resolve/translate the artifact and get the actual protocol message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#url SpIdpConnection#url}
  */
  readonly url: string;
}

export function spIdpConnectionIdpBrowserSsoArtifactResolverLocationsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoArtifactResolverLocations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    index: cdktf.numberToTerraform(struct!.index),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function spIdpConnectionIdpBrowserSsoArtifactResolverLocationsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoArtifactResolverLocations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    index: {
      value: cdktf.numberToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoArtifactResolverLocationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoArtifactResolverLocations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoArtifactResolverLocations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._index = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._index = value.index;
      this._url = value.url;
    }
  }

  // index - computed: false, optional: false, required: true
  private _index?: number; 
  public get index() {
    return this.getNumberAttribute('index');
  }
  public set index(value: number) {
    this._index = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}

export class SpIdpConnectionIdpBrowserSsoArtifactResolverLocationsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoArtifactResolverLocations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoArtifactResolverLocationsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoArtifactResolverLocationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoArtifact {
  /**
  * The lifetime of the artifact in seconds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#lifetime SpIdpConnection#lifetime}
  */
  readonly lifetime?: number;
  /**
  * Remote party URLs that you will use to resolve/translate the artifact and get the actual protocol message
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#resolver_locations SpIdpConnection#resolver_locations}
  */
  readonly resolverLocations: SpIdpConnectionIdpBrowserSsoArtifactResolverLocations[] | cdktf.IResolvable;
  /**
  * Source ID for SAML1.x connections
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source_id SpIdpConnection#source_id}
  */
  readonly sourceId?: string;
}

export function spIdpConnectionIdpBrowserSsoArtifactToTerraform(struct?: SpIdpConnectionIdpBrowserSsoArtifact | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    lifetime: cdktf.numberToTerraform(struct!.lifetime),
    resolver_locations: cdktf.listMapper(spIdpConnectionIdpBrowserSsoArtifactResolverLocationsToTerraform, false)(struct!.resolverLocations),
    source_id: cdktf.stringToTerraform(struct!.sourceId),
  }
}


export function spIdpConnectionIdpBrowserSsoArtifactToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoArtifact | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    lifetime: {
      value: cdktf.numberToHclTerraform(struct!.lifetime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resolver_locations: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoArtifactResolverLocationsToHclTerraform, false)(struct!.resolverLocations),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoArtifactResolverLocationsList",
    },
    source_id: {
      value: cdktf.stringToHclTerraform(struct!.sourceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoArtifactOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoArtifact | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._lifetime !== undefined) {
      hasAnyValues = true;
      internalValueResult.lifetime = this._lifetime;
    }
    if (this._resolverLocations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resolverLocations = this._resolverLocations?.internalValue;
    }
    if (this._sourceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceId = this._sourceId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoArtifact | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._lifetime = undefined;
      this._resolverLocations.internalValue = undefined;
      this._sourceId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._lifetime = value.lifetime;
      this._resolverLocations.internalValue = value.resolverLocations;
      this._sourceId = value.sourceId;
    }
  }

  // lifetime - computed: false, optional: true, required: false
  private _lifetime?: number; 
  public get lifetime() {
    return this.getNumberAttribute('lifetime');
  }
  public set lifetime(value: number) {
    this._lifetime = value;
  }
  public resetLifetime() {
    this._lifetime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lifetimeInput() {
    return this._lifetime;
  }

  // resolver_locations - computed: false, optional: false, required: true
  private _resolverLocations = new SpIdpConnectionIdpBrowserSsoArtifactResolverLocationsList(this, "resolver_locations", true);
  public get resolverLocations() {
    return this._resolverLocations;
  }
  public putResolverLocations(value: SpIdpConnectionIdpBrowserSsoArtifactResolverLocations[] | cdktf.IResolvable) {
    this._resolverLocations.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resolverLocationsInput() {
    return this._resolverLocations.internalValue;
  }

  // source_id - computed: false, optional: true, required: false
  private _sourceId?: string; 
  public get sourceId() {
    return this.getStringAttribute('source_id');
  }
  public set sourceId(value: string) {
    this._sourceId = value;
  }
  public resetSourceId() {
    this._sourceId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceIdInput() {
    return this._sourceId;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributes {
  /**
  * The name of this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name?: string;
}

export function spIdpConnectionIdpBrowserSsoAttributeContractCoreAttributesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributes): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function spIdpConnectionIdpBrowserSsoAttributeContractCoreAttributesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributes): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributes | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributes | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._name = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._name = value.name;
    }
  }

  // masked - computed: true, optional: false, required: false
  public get masked() {
    return this.getBooleanAttribute('masked');
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributes {
  /**
  * Specifies whether this attribute is masked in PingFederate logs. Defaults to `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#masked SpIdpConnection#masked}
  */
  readonly masked?: boolean | cdktf.IResolvable;
  /**
  * The name of this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
}

export function spIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    masked: cdktf.booleanToTerraform(struct!.masked),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function spIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    masked: {
      value: cdktf.booleanToHclTerraform(struct!.masked),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._masked !== undefined) {
      hasAnyValues = true;
      internalValueResult.masked = this._masked;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._masked = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._masked = value.masked;
      this._name = value.name;
    }
  }

  // masked - computed: true, optional: true, required: false
  private _masked?: boolean | cdktf.IResolvable; 
  public get masked() {
    return this.getBooleanAttribute('masked');
  }
  public set masked(value: boolean | cdktf.IResolvable) {
    this._masked = value;
  }
  public resetMasked() {
    this._masked = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskedInput() {
    return this._masked;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAttributeContract {
  /**
  * A list of additional attributes that are present in the incoming assertion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#extended_attributes SpIdpConnection#extended_attributes}
  */
  readonly extendedAttributes?: SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributes[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAttributeContractToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAttributeContract | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    extended_attributes: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesToTerraform, false)(struct!.extendedAttributes),
  }
}


export function spIdpConnectionIdpBrowserSsoAttributeContractToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAttributeContract | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    extended_attributes: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesToHclTerraform, false)(struct!.extendedAttributes),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAttributeContractOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAttributeContract | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._extendedAttributes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extendedAttributes = this._extendedAttributes?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAttributeContract | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._extendedAttributes.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._extendedAttributes.internalValue = value.extendedAttributes;
    }
  }

  // core_attributes - computed: true, optional: false, required: false
  private _coreAttributes = new SpIdpConnectionIdpBrowserSsoAttributeContractCoreAttributesList(this, "core_attributes", true);
  public get coreAttributes() {
    return this._coreAttributes;
  }

  // extended_attributes - computed: true, optional: true, required: false
  private _extendedAttributes = new SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributesList(this, "extended_attributes", true);
  public get extendedAttributes() {
    return this._extendedAttributes;
  }
  public putExtendedAttributes(value: SpIdpConnectionIdpBrowserSsoAttributeContractExtendedAttributes[] | cdktf.IResolvable) {
    this._extendedAttributes.internalValue = value;
  }
  public resetExtendedAttributes() {
    this._extendedAttributes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extendedAttributesInput() {
    return this._extendedAttributes.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillment): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillment): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillment | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillment | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFields {
  /**
  * The name of this field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The value of this field. Whether or not the value is required will be determined by plugin validation checks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * The list of fields that can be used to filter a request to the custom data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#filter_fields SpIdpConnection#filter_fields}
  */
  readonly filterFields?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable;
  /**
  * The ID that defines this attribute source. Only alphanumeric characters allowed. Note: Required for OpenID Connect policy attribute sources, OAuth IdP adapter mappings, OAuth access token mappings and APC-to-SP Adapter Mappings. IdP Connections will ignore this property since it only allows one attribute source to be defined per mapping. IdP-to-SP Adapter Mappings can contain multiple attribute sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    data_store_ref: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    filter_fields: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsToTerraform, false)(struct!.filterFields),
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter_fields: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsToHclTerraform, false)(struct!.filterFields),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filterFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterFields = this._filterFields?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._filterFields.internalValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._filterFields.internalValue = value.filterFields;
      this._id = value.id;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter_fields - computed: true, optional: true, required: false
  private _filterFields = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFieldsList(this, "filter_fields", true);
  public get filterFields() {
    return this._filterFields;
  }
  public putFilterFields(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable) {
    this._filterFields.internalValue = value;
  }
  public resetFilterFields() {
    this._filterFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterFieldsInput() {
    return this._filterFields.internalValue;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: false
  public get type() {
    return this.getStringAttribute('type');
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * A list of column names used to construct the SQL query to retrieve data from the specified table in the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#column_names SpIdpConnection#column_names}
  */
  readonly columnNames?: string[];
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * The JDBC WHERE clause used to query your data store to locate a user record.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#filter SpIdpConnection#filter}
  */
  readonly filter: string;
  /**
  * The ID that defines this attribute source. Only alphanumeric characters allowed. Note: Required for OpenID Connect policy attribute sources, OAuth IdP adapter mappings, OAuth access token mappings and APC-to-SP Adapter Mappings. IdP Connections will ignore this property since it only allows one attribute source to be defined per mapping. IdP-to-SP Adapter Mappings can contain multiple attribute sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Lists the table structure that stores information within a database. Some databases, such as Oracle, require a schema for a JDBC query. Other databases, such as MySQL, do not require a schema.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#schema SpIdpConnection#schema}
  */
  readonly schema?: string;
  /**
  * The name of the database table. The name is used to construct the SQL query to retrieve data from the data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#table SpIdpConnection#table}
  */
  readonly table: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    column_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.columnNames),
    data_store_ref: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
    id: cdktf.stringToTerraform(struct!.id),
    schema: cdktf.stringToTerraform(struct!.schema),
    table: cdktf.stringToTerraform(struct!.table),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap",
    },
    column_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.columnNames),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    table: {
      value: cdktf.stringToHclTerraform(struct!.table),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._columnNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnNames = this._columnNames;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._table !== undefined) {
      hasAnyValues = true;
      internalValueResult.table = this._table;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._columnNames = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._filter = undefined;
      this._id = undefined;
      this._schema = undefined;
      this._table = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._columnNames = value.columnNames;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._filter = value.filter;
      this._id = value.id;
      this._schema = value.schema;
      this._table = value.table;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // column_names - computed: true, optional: true, required: false
  private _columnNames?: string[]; 
  public get columnNames() {
    return cdktf.Fn.tolist(this.getListAttribute('column_names'));
  }
  public set columnNames(value: string[]) {
    this._columnNames = value;
  }
  public resetColumnNames() {
    this._columnNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnNamesInput() {
    return this._columnNames;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: true, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // schema - computed: true, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // table - computed: true, optional: false, required: true
  private _table?: string; 
  public get table() {
    return this.getStringAttribute('table');
  }
  public set table(value: string) {
    this._table = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tableInput() {
    return this._table;
  }

  // type - computed: true, optional: false, required: false
  public get type() {
    return this.getStringAttribute('type');
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings {
  /**
  * Get the encoding type for this attribute. If not specified, the default is BASE64.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#binary_encoding SpIdpConnection#binary_encoding}
  */
  readonly binaryEncoding?: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    binary_encoding: cdktf.stringToTerraform(struct!.binaryEncoding),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    binary_encoding: {
      value: cdktf.stringToHclTerraform(struct!.binaryEncoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._binaryEncoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.binaryEncoding = this._binaryEncoding;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._binaryEncoding = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._binaryEncoding = value.binaryEncoding;
    }
  }

  // binary_encoding - computed: true, optional: true, required: false
  private _binaryEncoding?: string; 
  public get binaryEncoding() {
    return this.getStringAttribute('binary_encoding');
  }
  public set binaryEncoding(value: string) {
    this._binaryEncoding = value;
  }
  public resetBinaryEncoding() {
    this._binaryEncoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get binaryEncodingInput() {
    return this._binaryEncoding;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * The base DN to search from. If not specified, the search will start at the LDAP's root.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#base_dn SpIdpConnection#base_dn}
  */
  readonly baseDn?: string;
  /**
  * The advanced settings for binary LDAP attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#binary_attribute_settings SpIdpConnection#binary_attribute_settings}
  */
  readonly binaryAttributeSettings?: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable;
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * The ID that defines this attribute source. Only alphanumeric characters allowed. Note: Required for OpenID Connect policy attribute sources, OAuth IdP adapter mappings, OAuth access token mappings and APC-to-SP Adapter Mappings. IdP Connections will ignore this property since it only allows one attribute source to be defined per mapping. IdP-to-SP Adapter Mappings can contain multiple attribute sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Set this to true to return transitive group memberships for the 'memberOf' attribute.  This only applies for Active Directory data sources.  All other data sources will be set to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#member_of_nested_group SpIdpConnection#member_of_nested_group}
  */
  readonly memberOfNestedGroup?: boolean | cdktf.IResolvable;
  /**
  * A list of LDAP attributes returned from search and available for mapping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_attributes SpIdpConnection#search_attributes}
  */
  readonly searchAttributes?: string[];
  /**
  * The LDAP filter that will be used to lookup the objects from the directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_filter SpIdpConnection#search_filter}
  */
  readonly searchFilter: string;
  /**
  * Determines the node depth of the query.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_scope SpIdpConnection#search_scope}
  */
  readonly searchScope: string;
  /**
  * The data store type of this attribute source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    base_dn: cdktf.stringToTerraform(struct!.baseDn),
    binary_attribute_settings: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToTerraform)(struct!.binaryAttributeSettings),
    data_store_ref: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    id: cdktf.stringToTerraform(struct!.id),
    member_of_nested_group: cdktf.booleanToTerraform(struct!.memberOfNestedGroup),
    search_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.searchAttributes),
    search_filter: cdktf.stringToTerraform(struct!.searchFilter),
    search_scope: cdktf.stringToTerraform(struct!.searchScope),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap",
    },
    base_dn: {
      value: cdktf.stringToHclTerraform(struct!.baseDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    binary_attribute_settings: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToHclTerraform)(struct!.binaryAttributeSettings),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    member_of_nested_group: {
      value: cdktf.booleanToHclTerraform(struct!.memberOfNestedGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    search_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.searchAttributes),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    search_filter: {
      value: cdktf.stringToHclTerraform(struct!.searchFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_scope: {
      value: cdktf.stringToHclTerraform(struct!.searchScope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._baseDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseDn = this._baseDn;
    }
    if (this._binaryAttributeSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.binaryAttributeSettings = this._binaryAttributeSettings?.internalValue;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._memberOfNestedGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.memberOfNestedGroup = this._memberOfNestedGroup;
    }
    if (this._searchAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchAttributes = this._searchAttributes;
    }
    if (this._searchFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchFilter = this._searchFilter;
    }
    if (this._searchScope !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchScope = this._searchScope;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._baseDn = undefined;
      this._binaryAttributeSettings.internalValue = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._id = undefined;
      this._memberOfNestedGroup = undefined;
      this._searchAttributes = undefined;
      this._searchFilter = undefined;
      this._searchScope = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._baseDn = value.baseDn;
      this._binaryAttributeSettings.internalValue = value.binaryAttributeSettings;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._id = value.id;
      this._memberOfNestedGroup = value.memberOfNestedGroup;
      this._searchAttributes = value.searchAttributes;
      this._searchFilter = value.searchFilter;
      this._searchScope = value.searchScope;
      this._type = value.type;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // base_dn - computed: true, optional: true, required: false
  private _baseDn?: string; 
  public get baseDn() {
    return this.getStringAttribute('base_dn');
  }
  public set baseDn(value: string) {
    this._baseDn = value;
  }
  public resetBaseDn() {
    this._baseDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseDnInput() {
    return this._baseDn;
  }

  // binary_attribute_settings - computed: true, optional: true, required: false
  private _binaryAttributeSettings = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap(this, "binary_attribute_settings");
  public get binaryAttributeSettings() {
    return this._binaryAttributeSettings;
  }
  public putBinaryAttributeSettings(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable) {
    this._binaryAttributeSettings.internalValue = value;
  }
  public resetBinaryAttributeSettings() {
    this._binaryAttributeSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get binaryAttributeSettingsInput() {
    return this._binaryAttributeSettings.internalValue;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // member_of_nested_group - computed: true, optional: true, required: false
  private _memberOfNestedGroup?: boolean | cdktf.IResolvable; 
  public get memberOfNestedGroup() {
    return this.getBooleanAttribute('member_of_nested_group');
  }
  public set memberOfNestedGroup(value: boolean | cdktf.IResolvable) {
    this._memberOfNestedGroup = value;
  }
  public resetMemberOfNestedGroup() {
    this._memberOfNestedGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memberOfNestedGroupInput() {
    return this._memberOfNestedGroup;
  }

  // search_attributes - computed: true, optional: true, required: false
  private _searchAttributes?: string[]; 
  public get searchAttributes() {
    return cdktf.Fn.tolist(this.getListAttribute('search_attributes'));
  }
  public set searchAttributes(value: string[]) {
    this._searchAttributes = value;
  }
  public resetSearchAttributes() {
    this._searchAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchAttributesInput() {
    return this._searchAttributes;
  }

  // search_filter - computed: true, optional: false, required: true
  private _searchFilter?: string; 
  public get searchFilter() {
    return this.getStringAttribute('search_filter');
  }
  public set searchFilter(value: string) {
    this._searchFilter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get searchFilterInput() {
    return this._searchFilter;
  }

  // search_scope - computed: true, optional: false, required: true
  private _searchScope?: string; 
  public get searchScope() {
    return this.getStringAttribute('search_scope');
  }
  public set searchScope(value: string) {
    this._searchScope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get searchScopeInput() {
    return this._searchScope;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSources {
  /**
  * The configured settings used to look up attributes from a custom data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#custom_attribute_source SpIdpConnection#custom_attribute_source}
  */
  readonly customAttributeSource?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSource;
  /**
  * The configured settings used to look up attributes from a JDBC data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#jdbc_attribute_source SpIdpConnection#jdbc_attribute_source}
  */
  readonly jdbcAttributeSource?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSource;
  /**
  * The configured settings used to look up attributes from a LDAP data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#ldap_attribute_source SpIdpConnection#ldap_attribute_source}
  */
  readonly ldapAttributeSource?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSource;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_attribute_source: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceToTerraform(struct!.customAttributeSource),
    jdbc_attribute_source: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceToTerraform(struct!.jdbcAttributeSource),
    ldap_attribute_source: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceToTerraform(struct!.ldapAttributeSource),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceToHclTerraform(struct!.customAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSource",
    },
    jdbc_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceToHclTerraform(struct!.jdbcAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSource",
    },
    ldap_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceToHclTerraform(struct!.ldapAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAttributeSource = this._customAttributeSource?.internalValue;
    }
    if (this._jdbcAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jdbcAttributeSource = this._jdbcAttributeSource?.internalValue;
    }
    if (this._ldapAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldapAttributeSource = this._ldapAttributeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customAttributeSource.internalValue = undefined;
      this._jdbcAttributeSource.internalValue = undefined;
      this._ldapAttributeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customAttributeSource.internalValue = value.customAttributeSource;
      this._jdbcAttributeSource.internalValue = value.jdbcAttributeSource;
      this._ldapAttributeSource.internalValue = value.ldapAttributeSource;
    }
  }

  // custom_attribute_source - computed: true, optional: true, required: false
  private _customAttributeSource = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSourceOutputReference(this, "custom_attribute_source");
  public get customAttributeSource() {
    return this._customAttributeSource;
  }
  public putCustomAttributeSource(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesCustomAttributeSource) {
    this._customAttributeSource.internalValue = value;
  }
  public resetCustomAttributeSource() {
    this._customAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customAttributeSourceInput() {
    return this._customAttributeSource.internalValue;
  }

  // jdbc_attribute_source - computed: true, optional: true, required: false
  private _jdbcAttributeSource = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSourceOutputReference(this, "jdbc_attribute_source");
  public get jdbcAttributeSource() {
    return this._jdbcAttributeSource;
  }
  public putJdbcAttributeSource(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesJdbcAttributeSource) {
    this._jdbcAttributeSource.internalValue = value;
  }
  public resetJdbcAttributeSource() {
    this._jdbcAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jdbcAttributeSourceInput() {
    return this._jdbcAttributeSource.internalValue;
  }

  // ldap_attribute_source - computed: true, optional: true, required: false
  private _ldapAttributeSource = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSourceOutputReference(this, "ldap_attribute_source");
  public get ldapAttributeSource() {
    return this._ldapAttributeSource;
  }
  public putLdapAttributeSource(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesLdapAttributeSource) {
    this._ldapAttributeSource.internalValue = value;
  }
  public resetLdapAttributeSource() {
    this._ldapAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapAttributeSourceInput() {
    return this._ldapAttributeSource.internalValue;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSources[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteria {
  /**
  * The name of the attribute to use in this issuance criterion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_name SpIdpConnection#attribute_name}
  */
  readonly attributeName: string;
  /**
  * The condition that will be applied to the source attribute's value and the expected value. Options are `EQUALS`, `EQUALS_CASE_INSENSITIVE`, `EQUALS_DN`, `NOT_EQUAL`, `NOT_EQUAL_CASE_INSENSITIVE`, `NOT_EQUAL_DN`, `MULTIVALUE_CONTAINS`, `MULTIVALUE_CONTAINS_CASE_INSENSITIVE`, `MULTIVALUE_CONTAINS_DN`, `MULTIVALUE_DOES_NOT_CONTAIN`, `MULTIVALUE_DOES_NOT_CONTAIN_CASE_INSENSITIVE`, `MULTIVALUE_DOES_NOT_CONTAIN_DN`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#condition SpIdpConnection#condition}
  */
  readonly condition: string;
  /**
  * The error result to return if this issuance criterion fails. This error result will show up in the PingFederate server logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#error_result SpIdpConnection#error_result}
  */
  readonly errorResult?: string;
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSource;
  /**
  * The expected value of this issuance criterion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_name: cdktf.stringToTerraform(struct!.attributeName),
    condition: cdktf.stringToTerraform(struct!.condition),
    error_result: cdktf.stringToTerraform(struct!.errorResult),
    source: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.attributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    condition: {
      value: cdktf.stringToHclTerraform(struct!.condition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    error_result: {
      value: cdktf.stringToHclTerraform(struct!.errorResult),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeName = this._attributeName;
    }
    if (this._condition !== undefined) {
      hasAnyValues = true;
      internalValueResult.condition = this._condition;
    }
    if (this._errorResult !== undefined) {
      hasAnyValues = true;
      internalValueResult.errorResult = this._errorResult;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeName = undefined;
      this._condition = undefined;
      this._errorResult = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeName = value.attributeName;
      this._condition = value.condition;
      this._errorResult = value.errorResult;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // attribute_name - computed: true, optional: false, required: true
  private _attributeName?: string; 
  public get attributeName() {
    return this.getStringAttribute('attribute_name');
  }
  public set attributeName(value: string) {
    this._attributeName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeNameInput() {
    return this._attributeName;
  }

  // condition - computed: true, optional: false, required: true
  private _condition?: string; 
  public get condition() {
    return this.getStringAttribute('condition');
  }
  public set condition(value: string) {
    this._condition = value;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionInput() {
    return this._condition;
  }

  // error_result - computed: true, optional: true, required: false
  private _errorResult?: string; 
  public get errorResult() {
    return this.getStringAttribute('error_result');
  }
  public set errorResult(value: string) {
    this._errorResult = value;
  }
  public resetErrorResult() {
    this._errorResult = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorResultInput() {
    return this._errorResult;
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteria {
  /**
  * The error result to return if this issuance criterion fails. This error result will show up in the PingFederate server logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#error_result SpIdpConnection#error_result}
  */
  readonly errorResult?: string;
  /**
  * The OGNL expression to evaluate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#expression SpIdpConnection#expression}
  */
  readonly expression: string;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    error_result: cdktf.stringToTerraform(struct!.errorResult),
    expression: cdktf.stringToTerraform(struct!.expression),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    error_result: {
      value: cdktf.stringToHclTerraform(struct!.errorResult),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expression: {
      value: cdktf.stringToHclTerraform(struct!.expression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._errorResult !== undefined) {
      hasAnyValues = true;
      internalValueResult.errorResult = this._errorResult;
    }
    if (this._expression !== undefined) {
      hasAnyValues = true;
      internalValueResult.expression = this._expression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._errorResult = undefined;
      this._expression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._errorResult = value.errorResult;
      this._expression = value.expression;
    }
  }

  // error_result - computed: true, optional: true, required: false
  private _errorResult?: string; 
  public get errorResult() {
    return this.getStringAttribute('error_result');
  }
  public set errorResult(value: string) {
    this._errorResult = value;
  }
  public resetErrorResult() {
    this._errorResult = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorResultInput() {
    return this._errorResult;
  }

  // expression - computed: true, optional: false, required: true
  private _expression?: string; 
  public get expression() {
    return this.getStringAttribute('expression');
  }
  public set expression(value: string) {
    this._expression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionInput() {
    return this._expression;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteria {
  /**
  * A list of conditional issuance criteria where existing attributes must satisfy their conditions against expected values in order for the transaction to continue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#conditional_criteria SpIdpConnection#conditional_criteria}
  */
  readonly conditionalCriteria?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable;
  /**
  * A list of expression issuance criteria where the OGNL expressions must evaluate to true in order for the transaction to continue. Expressions must be enabled in PingFederate to use expression criteria.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#expression_criteria SpIdpConnection#expression_criteria}
  */
  readonly expressionCriteria?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    conditional_criteria: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaToTerraform, false)(struct!.conditionalCriteria),
    expression_criteria: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaToTerraform, false)(struct!.expressionCriteria),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    conditional_criteria: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaToHclTerraform, false)(struct!.conditionalCriteria),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaList",
    },
    expression_criteria: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaToHclTerraform, false)(struct!.expressionCriteria),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._conditionalCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.conditionalCriteria = this._conditionalCriteria?.internalValue;
    }
    if (this._expressionCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expressionCriteria = this._expressionCriteria?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._conditionalCriteria.internalValue = undefined;
      this._expressionCriteria.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._conditionalCriteria.internalValue = value.conditionalCriteria;
      this._expressionCriteria.internalValue = value.expressionCriteria;
    }
  }

  // conditional_criteria - computed: true, optional: true, required: false
  private _conditionalCriteria = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteriaList(this, "conditional_criteria", true);
  public get conditionalCriteria() {
    return this._conditionalCriteria;
  }
  public putConditionalCriteria(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable) {
    this._conditionalCriteria.internalValue = value;
  }
  public resetConditionalCriteria() {
    this._conditionalCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionalCriteriaInput() {
    return this._conditionalCriteria.internalValue;
  }

  // expression_criteria - computed: true, optional: true, required: false
  private _expressionCriteria = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteriaList(this, "expression_criteria", true);
  public get expressionCriteria() {
    return this._expressionCriteria;
  }
  public putExpressionCriteria(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable) {
    this._expressionCriteria.internalValue = value;
  }
  public resetExpressionCriteria() {
    this._expressionCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionCriteriaInput() {
    return this._expressionCriteria.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappings {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * A list of configured data stores to look up attributes from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_sources SpIdpConnection#attribute_sources}
  */
  readonly attributeSources?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSources[] | cdktf.IResolvable;
  /**
  * A reference to a resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#authentication_policy_contract_ref SpIdpConnection#authentication_policy_contract_ref}
  */
  readonly authenticationPolicyContractRef: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRef;
  /**
  * The issuance criteria that this transaction must meet before the corresponding attribute contract is fulfilled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#issuance_criteria SpIdpConnection#issuance_criteria}
  */
  readonly issuanceCriteria?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteria;
  /**
  * Restricts this mapping to specific virtual entity IDs. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#restrict_virtual_server_ids SpIdpConnection#restrict_virtual_server_ids}
  */
  readonly restrictVirtualServerIds?: boolean | cdktf.IResolvable;
  /**
  * The list of virtual server IDs that this mapping is restricted to. The default value is an empty set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#restricted_virtual_server_ids SpIdpConnection#restricted_virtual_server_ids}
  */
  readonly restrictedVirtualServerIds?: string[];
}

export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    attribute_sources: cdktf.listMapper(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesToTerraform, false)(struct!.attributeSources),
    authentication_policy_contract_ref: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRefToTerraform(struct!.authenticationPolicyContractRef),
    issuance_criteria: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaToTerraform(struct!.issuanceCriteria),
    restrict_virtual_server_ids: cdktf.booleanToTerraform(struct!.restrictVirtualServerIds),
    restricted_virtual_server_ids: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.restrictedVirtualServerIds),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentMap",
    },
    attribute_sources: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesToHclTerraform, false)(struct!.attributeSources),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesList",
    },
    authentication_policy_contract_ref: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRefToHclTerraform(struct!.authenticationPolicyContractRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRef",
    },
    issuance_criteria: {
      value: spIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaToHclTerraform(struct!.issuanceCriteria),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteria",
    },
    restrict_virtual_server_ids: {
      value: cdktf.booleanToHclTerraform(struct!.restrictVirtualServerIds),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    restricted_virtual_server_ids: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.restrictedVirtualServerIds),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._attributeSources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeSources = this._attributeSources?.internalValue;
    }
    if (this._authenticationPolicyContractRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationPolicyContractRef = this._authenticationPolicyContractRef?.internalValue;
    }
    if (this._issuanceCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuanceCriteria = this._issuanceCriteria?.internalValue;
    }
    if (this._restrictVirtualServerIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.restrictVirtualServerIds = this._restrictVirtualServerIds;
    }
    if (this._restrictedVirtualServerIds !== undefined) {
      hasAnyValues = true;
      internalValueResult.restrictedVirtualServerIds = this._restrictedVirtualServerIds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._attributeSources.internalValue = undefined;
      this._authenticationPolicyContractRef.internalValue = undefined;
      this._issuanceCriteria.internalValue = undefined;
      this._restrictVirtualServerIds = undefined;
      this._restrictedVirtualServerIds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._attributeSources.internalValue = value.attributeSources;
      this._authenticationPolicyContractRef.internalValue = value.authenticationPolicyContractRef;
      this._issuanceCriteria.internalValue = value.issuanceCriteria;
      this._restrictVirtualServerIds = value.restrictVirtualServerIds;
      this._restrictedVirtualServerIds = value.restrictedVirtualServerIds;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: false, required: true
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // attribute_sources - computed: true, optional: true, required: false
  private _attributeSources = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSourcesList(this, "attribute_sources", true);
  public get attributeSources() {
    return this._attributeSources;
  }
  public putAttributeSources(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAttributeSources[] | cdktf.IResolvable) {
    this._attributeSources.internalValue = value;
  }
  public resetAttributeSources() {
    this._attributeSources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeSourcesInput() {
    return this._attributeSources.internalValue;
  }

  // authentication_policy_contract_ref - computed: true, optional: false, required: true
  private _authenticationPolicyContractRef = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRefOutputReference(this, "authentication_policy_contract_ref");
  public get authenticationPolicyContractRef() {
    return this._authenticationPolicyContractRef;
  }
  public putAuthenticationPolicyContractRef(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsAuthenticationPolicyContractRef) {
    this._authenticationPolicyContractRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationPolicyContractRefInput() {
    return this._authenticationPolicyContractRef.internalValue;
  }

  // issuance_criteria - computed: true, optional: true, required: false
  private _issuanceCriteria = new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteriaOutputReference(this, "issuance_criteria");
  public get issuanceCriteria() {
    return this._issuanceCriteria;
  }
  public putIssuanceCriteria(value: SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsIssuanceCriteria) {
    this._issuanceCriteria.internalValue = value;
  }
  public resetIssuanceCriteria() {
    this._issuanceCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuanceCriteriaInput() {
    return this._issuanceCriteria.internalValue;
  }

  // restrict_virtual_server_ids - computed: true, optional: true, required: false
  private _restrictVirtualServerIds?: boolean | cdktf.IResolvable; 
  public get restrictVirtualServerIds() {
    return this.getBooleanAttribute('restrict_virtual_server_ids');
  }
  public set restrictVirtualServerIds(value: boolean | cdktf.IResolvable) {
    this._restrictVirtualServerIds = value;
  }
  public resetRestrictVirtualServerIds() {
    this._restrictVirtualServerIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restrictVirtualServerIdsInput() {
    return this._restrictVirtualServerIds;
  }

  // restricted_virtual_server_ids - computed: true, optional: true, required: false
  private _restrictedVirtualServerIds?: string[]; 
  public get restrictedVirtualServerIds() {
    return cdktf.Fn.tolist(this.getListAttribute('restricted_virtual_server_ids'));
  }
  public set restrictedVirtualServerIds(value: string[]) {
    this._restrictedVirtualServerIds = value;
  }
  public resetRestrictedVirtualServerIds() {
    this._restrictedVirtualServerIds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get restrictedVirtualServerIdsInput() {
    return this._restrictedVirtualServerIds;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthenticationPolicyContractMappingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoAuthnContextMappings {
  /**
  * The local authentication context value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#local SpIdpConnection#local}
  */
  readonly local?: string;
  /**
  * The remote authentication context value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#remote SpIdpConnection#remote}
  */
  readonly remote?: string;
}

export function spIdpConnectionIdpBrowserSsoAuthnContextMappingsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthnContextMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    local: cdktf.stringToTerraform(struct!.local),
    remote: cdktf.stringToTerraform(struct!.remote),
  }
}


export function spIdpConnectionIdpBrowserSsoAuthnContextMappingsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoAuthnContextMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    local: {
      value: cdktf.stringToHclTerraform(struct!.local),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remote: {
      value: cdktf.stringToHclTerraform(struct!.remote),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoAuthnContextMappingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoAuthnContextMappings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._local !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local;
    }
    if (this._remote !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoAuthnContextMappings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._local = undefined;
      this._remote = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._local = value.local;
      this._remote = value.remote;
    }
  }

  // local - computed: false, optional: true, required: false
  private _local?: string; 
  public get local() {
    return this.getStringAttribute('local');
  }
  public set local(value: string) {
    this._local = value;
  }
  public resetLocal() {
    this._local = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local;
  }

  // remote - computed: false, optional: true, required: false
  private _remote?: string; 
  public get remote() {
    return this.getStringAttribute('remote');
  }
  public set remote(value: string) {
    this._remote = value;
  }
  public resetRemote() {
    this._remote = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote;
  }
}

export class SpIdpConnectionIdpBrowserSsoAuthnContextMappingsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoAuthnContextMappings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoAuthnContextMappingsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoAuthnContextMappingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoDecryptionPolicy {
  /**
  * Specify whether the incoming SAML assertion is encrypted for an IdP connection. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#assertion_encrypted SpIdpConnection#assertion_encrypted}
  */
  readonly assertionEncrypted?: boolean | cdktf.IResolvable;
  /**
  * Specify whether one or more incoming SAML attributes are encrypted for an IdP connection. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attributes_encrypted SpIdpConnection#attributes_encrypted}
  */
  readonly attributesEncrypted?: boolean | cdktf.IResolvable;
  /**
  * Encrypt the Subject Name ID in SLO messages to the IdP. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#slo_encrypt_subject_name_id SpIdpConnection#slo_encrypt_subject_name_id}
  */
  readonly sloEncryptSubjectNameId?: boolean | cdktf.IResolvable;
  /**
  * Allow encrypted Subject Name ID in SLO messages from the IdP. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#slo_subject_name_id_encrypted SpIdpConnection#slo_subject_name_id_encrypted}
  */
  readonly sloSubjectNameIdEncrypted?: boolean | cdktf.IResolvable;
  /**
  * Specify whether the incoming Subject Name ID is encrypted for an IdP connection. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#subject_name_id_encrypted SpIdpConnection#subject_name_id_encrypted}
  */
  readonly subjectNameIdEncrypted?: boolean | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoDecryptionPolicyToTerraform(struct?: SpIdpConnectionIdpBrowserSsoDecryptionPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assertion_encrypted: cdktf.booleanToTerraform(struct!.assertionEncrypted),
    attributes_encrypted: cdktf.booleanToTerraform(struct!.attributesEncrypted),
    slo_encrypt_subject_name_id: cdktf.booleanToTerraform(struct!.sloEncryptSubjectNameId),
    slo_subject_name_id_encrypted: cdktf.booleanToTerraform(struct!.sloSubjectNameIdEncrypted),
    subject_name_id_encrypted: cdktf.booleanToTerraform(struct!.subjectNameIdEncrypted),
  }
}


export function spIdpConnectionIdpBrowserSsoDecryptionPolicyToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoDecryptionPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assertion_encrypted: {
      value: cdktf.booleanToHclTerraform(struct!.assertionEncrypted),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    attributes_encrypted: {
      value: cdktf.booleanToHclTerraform(struct!.attributesEncrypted),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    slo_encrypt_subject_name_id: {
      value: cdktf.booleanToHclTerraform(struct!.sloEncryptSubjectNameId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    slo_subject_name_id_encrypted: {
      value: cdktf.booleanToHclTerraform(struct!.sloSubjectNameIdEncrypted),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    subject_name_id_encrypted: {
      value: cdktf.booleanToHclTerraform(struct!.subjectNameIdEncrypted),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoDecryptionPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoDecryptionPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assertionEncrypted !== undefined) {
      hasAnyValues = true;
      internalValueResult.assertionEncrypted = this._assertionEncrypted;
    }
    if (this._attributesEncrypted !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributesEncrypted = this._attributesEncrypted;
    }
    if (this._sloEncryptSubjectNameId !== undefined) {
      hasAnyValues = true;
      internalValueResult.sloEncryptSubjectNameId = this._sloEncryptSubjectNameId;
    }
    if (this._sloSubjectNameIdEncrypted !== undefined) {
      hasAnyValues = true;
      internalValueResult.sloSubjectNameIdEncrypted = this._sloSubjectNameIdEncrypted;
    }
    if (this._subjectNameIdEncrypted !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectNameIdEncrypted = this._subjectNameIdEncrypted;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoDecryptionPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assertionEncrypted = undefined;
      this._attributesEncrypted = undefined;
      this._sloEncryptSubjectNameId = undefined;
      this._sloSubjectNameIdEncrypted = undefined;
      this._subjectNameIdEncrypted = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assertionEncrypted = value.assertionEncrypted;
      this._attributesEncrypted = value.attributesEncrypted;
      this._sloEncryptSubjectNameId = value.sloEncryptSubjectNameId;
      this._sloSubjectNameIdEncrypted = value.sloSubjectNameIdEncrypted;
      this._subjectNameIdEncrypted = value.subjectNameIdEncrypted;
    }
  }

  // assertion_encrypted - computed: true, optional: true, required: false
  private _assertionEncrypted?: boolean | cdktf.IResolvable; 
  public get assertionEncrypted() {
    return this.getBooleanAttribute('assertion_encrypted');
  }
  public set assertionEncrypted(value: boolean | cdktf.IResolvable) {
    this._assertionEncrypted = value;
  }
  public resetAssertionEncrypted() {
    this._assertionEncrypted = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assertionEncryptedInput() {
    return this._assertionEncrypted;
  }

  // attributes_encrypted - computed: true, optional: true, required: false
  private _attributesEncrypted?: boolean | cdktf.IResolvable; 
  public get attributesEncrypted() {
    return this.getBooleanAttribute('attributes_encrypted');
  }
  public set attributesEncrypted(value: boolean | cdktf.IResolvable) {
    this._attributesEncrypted = value;
  }
  public resetAttributesEncrypted() {
    this._attributesEncrypted = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesEncryptedInput() {
    return this._attributesEncrypted;
  }

  // slo_encrypt_subject_name_id - computed: true, optional: true, required: false
  private _sloEncryptSubjectNameId?: boolean | cdktf.IResolvable; 
  public get sloEncryptSubjectNameId() {
    return this.getBooleanAttribute('slo_encrypt_subject_name_id');
  }
  public set sloEncryptSubjectNameId(value: boolean | cdktf.IResolvable) {
    this._sloEncryptSubjectNameId = value;
  }
  public resetSloEncryptSubjectNameId() {
    this._sloEncryptSubjectNameId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sloEncryptSubjectNameIdInput() {
    return this._sloEncryptSubjectNameId;
  }

  // slo_subject_name_id_encrypted - computed: true, optional: true, required: false
  private _sloSubjectNameIdEncrypted?: boolean | cdktf.IResolvable; 
  public get sloSubjectNameIdEncrypted() {
    return this.getBooleanAttribute('slo_subject_name_id_encrypted');
  }
  public set sloSubjectNameIdEncrypted(value: boolean | cdktf.IResolvable) {
    this._sloSubjectNameIdEncrypted = value;
  }
  public resetSloSubjectNameIdEncrypted() {
    this._sloSubjectNameIdEncrypted = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sloSubjectNameIdEncryptedInput() {
    return this._sloSubjectNameIdEncrypted;
  }

  // subject_name_id_encrypted - computed: true, optional: true, required: false
  private _subjectNameIdEncrypted?: boolean | cdktf.IResolvable; 
  public get subjectNameIdEncrypted() {
    return this.getBooleanAttribute('subject_name_id_encrypted');
  }
  public set subjectNameIdEncrypted(value: boolean | cdktf.IResolvable) {
    this._subjectNameIdEncrypted = value;
  }
  public resetSubjectNameIdEncrypted() {
    this._subjectNameIdEncrypted = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectNameIdEncryptedInput() {
    return this._subjectNameIdEncrypted;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContract {
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContractToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContract): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContractToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContract): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContractOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContract | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContract | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // masked - computed: true, optional: false, required: false
  public get masked() {
    return this.getBooleanAttribute('masked');
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContractList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContractOutputReference {
    return new SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContractOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributes {
  /**
  * Specify whether to use only attributes from the SAML Assertion or retrieve additional attributes from the IdP. The default is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#do_attribute_query SpIdpConnection#do_attribute_query}
  */
  readonly doAttributeQuery?: boolean | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    do_attribute_query: cdktf.booleanToTerraform(struct!.doAttributeQuery),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    do_attribute_query: {
      value: cdktf.booleanToHclTerraform(struct!.doAttributeQuery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._doAttributeQuery !== undefined) {
      hasAnyValues = true;
      internalValueResult.doAttributeQuery = this._doAttributeQuery;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._doAttributeQuery = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._doAttributeQuery = value.doAttributeQuery;
    }
  }

  // attribute_contract - computed: true, optional: false, required: false
  private _attributeContract = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesAttributeContractList(this, "attribute_contract", true);
  public get attributeContract() {
    return this._attributeContract;
  }

  // do_attribute_query - computed: true, optional: true, required: false
  private _doAttributeQuery?: boolean | cdktf.IResolvable; 
  public get doAttributeQuery() {
    return this.getBooleanAttribute('do_attribute_query');
  }
  public set doAttributeQuery(value: boolean | cdktf.IResolvable) {
    this._doAttributeQuery = value;
  }
  public resetDoAttributeQuery() {
    this._doAttributeQuery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get doAttributeQueryInput() {
    return this._doAttributeQuery;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `ACCOUNT_LINK`, `ACTOR_TOKEN`, `ADAPTER`, `ASSERTION`, `ATTRIBUTE_QUERY`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `FRAGMENT`, `IDENTITY_STORE_GROUP`, `IDENTITY_STORE_USER`, `IDP_CONNECTION`, `INPUTS`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `LOCAL_IDENTITY_PROFILE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `OAUTH_PERSISTENT_GRANT`, `PASSWORD_CREDENTIAL_VALIDATOR`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `REQUEST`, `SCIM_GROUP`, `SCIM_USER`, `SUBJECT_TOKEN`, `TEXT`, `TOKEN`, `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `TRACKED_HTTP_PARAMS`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMapping {
  /**
  * A key that is meant to reference a source from which an attribute can be retrieved. This model is usually paired with a value which, depending on the SourceType, can be a hardcoded value or a reference to an attribute name specific to that SourceType. Not all values are applicable - a validation error will be returned for incorrect values.<br>For each SourceType, the value should be:<br>ACCOUNT_LINK - If account linking was enabled for the browser SSO, the value must be 'Local User ID', unless it has been overridden in PingFederate's server configuration.<br>ADAPTER - The value is one of the attributes of the IdP Adapter.<br>ASSERTION - The value is one of the attributes coming from the SAML assertion.<br>AUTHENTICATION_POLICY_CONTRACT - The value is one of the attributes coming from an authentication policy contract.<br>LOCAL_IDENTITY_PROFILE - The value is one of the fields coming from a local identity profile.<br>CONTEXT - The value must be one of the following ['TargetResource' or 'OAuthScopes' or 'ClientId' or 'AuthenticationCtx' or 'ClientIp' or 'Locale' or 'StsBasicAuthUsername' or 'StsSSLClientCertSubjectDN' or 'StsSSLClientCertChain' or 'VirtualServerId' or 'AuthenticatingAuthority' or 'DefaultPersistentGrantLifetime'.]<br>CLAIMS - Attributes provided by the OIDC Provider.<br>CUSTOM_DATA_STORE - The value is one of the attributes returned by this custom data store.<br>EXPRESSION - The value is an OGNL expression.<br>EXTENDED_CLIENT_METADATA - The value is from an OAuth extended client metadata parameter. This source type is deprecated and has been replaced by EXTENDED_PROPERTIES.<br>EXTENDED_PROPERTIES - The value is from an OAuth Client's extended property.<br>IDP_CONNECTION - The value is one of the attributes passed in by the IdP connection.<br>JDBC_DATA_STORE - The value is one of the column names returned from the JDBC attribute source.<br>LDAP_DATA_STORE - The value is one of the LDAP attributes supported by your LDAP data store.<br>MAPPED_ATTRIBUTES - The value is the name of one of the mapped attributes that is defined in the associated attribute mapping.<br>OAUTH_PERSISTENT_GRANT - The value is one of the attributes from the persistent grant.<br>PASSWORD_CREDENTIAL_VALIDATOR - The value is one of the attributes of the PCV.<br>NO_MAPPING - A placeholder value to indicate that an attribute currently has no mapped source.TEXT - A hardcoded value that is used to populate the corresponding attribute.<br>TOKEN - The value is one of the token attributes.<br>REQUEST - The value is from the request context such as the CIBA identity hint contract or the request contract for Ws-Trust.<br>TRACKED_HTTP_PARAMS - The value is from the original request parameters.<br>SUBJECT_TOKEN - The value is one of the OAuth 2.0 Token exchange subject_token attributes.<br>ACTOR_TOKEN - The value is one of the OAuth 2.0 Token exchange actor_token attributes.<br>TOKEN_EXCHANGE_PROCESSOR_POLICY - The value is one of the attributes coming from a Token Exchange Processor policy.<br>FRAGMENT - The value is one of the attributes coming from an authentication policy fragment.<br>INPUTS - The value is one of the attributes coming from an attribute defined in the input authentication policy contract for an authentication policy fragment.<br>ATTRIBUTE_QUERY - The value is one of the user attributes queried from an Attribute Authority.<br>IDENTITY_STORE_USER - The value is one of the attributes from a user identity store provisioner for SCIM processing.<br>IDENTITY_STORE_GROUP - The value is one of the attributes from a group identity store provisioner for SCIM processing.<br>SCIM_USER - The value is one of the attributes passed in from the SCIM user request.<br>SCIM_GROUP - The value is one of the attributes passed in from the SCIM group request.<br>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMapping | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMapping | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: false, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMapping } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingOutputReference {
    return new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedure {
  /**
  * Lists the table structure that stores information within a database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#schema SpIdpConnection#schema}
  */
  readonly schema: string;
  /**
  * The name of the database stored procedure.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#stored_procedure SpIdpConnection#stored_procedure}
  */
  readonly storedProcedure: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedureToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    schema: cdktf.stringToTerraform(struct!.schema),
    stored_procedure: cdktf.stringToTerraform(struct!.storedProcedure),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedureToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedure | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stored_procedure: {
      value: cdktf.stringToHclTerraform(struct!.storedProcedure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedureOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedure | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._storedProcedure !== undefined) {
      hasAnyValues = true;
      internalValueResult.storedProcedure = this._storedProcedure;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedure | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._schema = undefined;
      this._storedProcedure = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._schema = value.schema;
      this._storedProcedure = value.storedProcedure;
    }
  }

  // schema - computed: false, optional: false, required: true
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // stored_procedure - computed: false, optional: false, required: true
  private _storedProcedure?: string; 
  public get storedProcedure() {
    return this.getStringAttribute('stored_procedure');
  }
  public set storedProcedure(value: string) {
    this._storedProcedure = value;
  }
  // Temporarily expose input value. Use with caution.
  public get storedProcedureInput() {
    return this._storedProcedure;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTable {
  /**
  * Lists the table structure that stores information within a database.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#schema SpIdpConnection#schema}
  */
  readonly schema: string;
  /**
  * The name of the database table.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#table_name SpIdpConnection#table_name}
  */
  readonly tableName: string;
  /**
  * The database column that uniquely identifies the provisioned user on the SP side.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#unique_id_column SpIdpConnection#unique_id_column}
  */
  readonly uniqueIdColumn: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTableToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    schema: cdktf.stringToTerraform(struct!.schema),
    table_name: cdktf.stringToTerraform(struct!.tableName),
    unique_id_column: cdktf.stringToTerraform(struct!.uniqueIdColumn),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTableToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTable | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    table_name: {
      value: cdktf.stringToHclTerraform(struct!.tableName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    unique_id_column: {
      value: cdktf.stringToHclTerraform(struct!.uniqueIdColumn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTableOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTable | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._tableName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tableName = this._tableName;
    }
    if (this._uniqueIdColumn !== undefined) {
      hasAnyValues = true;
      internalValueResult.uniqueIdColumn = this._uniqueIdColumn;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTable | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._schema = undefined;
      this._tableName = undefined;
      this._uniqueIdColumn = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._schema = value.schema;
      this._tableName = value.tableName;
      this._uniqueIdColumn = value.uniqueIdColumn;
    }
  }

  // schema - computed: false, optional: false, required: true
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // table_name - computed: false, optional: false, required: true
  private _tableName?: string; 
  public get tableName() {
    return this.getStringAttribute('table_name');
  }
  public set tableName(value: string) {
    this._tableName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tableNameInput() {
    return this._tableName;
  }

  // unique_id_column - computed: false, optional: false, required: true
  private _uniqueIdColumn?: string; 
  public get uniqueIdColumn() {
    return this.getStringAttribute('unique_id_column');
  }
  public set uniqueIdColumn(value: string) {
    this._uniqueIdColumn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get uniqueIdColumnInput() {
    return this._uniqueIdColumn;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethod {
  /**
  * The Stored Procedure SQL method. The procedure is always called for all SSO tokens and `event_trigger` will always be `ALL_SAML_ASSERTIONS`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#stored_procedure SpIdpConnection#stored_procedure}
  */
  readonly storedProcedure?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedure;
  /**
  * The Table SQL method.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#table SpIdpConnection#table}
  */
  readonly table?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTable;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethod | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    stored_procedure: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedureToTerraform(struct!.storedProcedure),
    table: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTableToTerraform(struct!.table),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethod | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    stored_procedure: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedureToHclTerraform(struct!.storedProcedure),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedure",
    },
    table: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTableToHclTerraform(struct!.table),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTable",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethod | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._storedProcedure?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storedProcedure = this._storedProcedure?.internalValue;
    }
    if (this._table?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.table = this._table?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethod | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._storedProcedure.internalValue = undefined;
      this._table.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._storedProcedure.internalValue = value.storedProcedure;
      this._table.internalValue = value.table;
    }
  }

  // stored_procedure - computed: false, optional: true, required: false
  private _storedProcedure = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedureOutputReference(this, "stored_procedure");
  public get storedProcedure() {
    return this._storedProcedure;
  }
  public putStoredProcedure(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodStoredProcedure) {
    this._storedProcedure.internalValue = value;
  }
  public resetStoredProcedure() {
    this._storedProcedure.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storedProcedureInput() {
    return this._storedProcedure.internalValue;
  }

  // table - computed: false, optional: true, required: false
  private _table = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTableOutputReference(this, "table");
  public get table() {
    return this._table;
  }
  public putTable(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodTable) {
    this._table.internalValue = value;
  }
  public resetTable() {
    this._table.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tableInput() {
    return this._table.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbc {
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRef;
  /**
  * The user repository attribute mapping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#jit_repository_attribute_mapping SpIdpConnection#jit_repository_attribute_mapping}
  */
  readonly jitRepositoryAttributeMapping: { [key: string]: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMapping } | cdktf.IResolvable;
  /**
  * The method to map attributes from the assertion directly to database table columns or to stored-procedure parameters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#sql_method SpIdpConnection#sql_method}
  */
  readonly sqlMethod: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethod;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_store_ref: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRefToTerraform(struct!.dataStoreRef),
    jit_repository_attribute_mapping: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingToTerraform)(struct!.jitRepositoryAttributeMapping),
    sql_method: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodToTerraform(struct!.sqlMethod),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRef",
    },
    jit_repository_attribute_mapping: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingToHclTerraform)(struct!.jitRepositoryAttributeMapping),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingMap",
    },
    sql_method: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodToHclTerraform(struct!.sqlMethod),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethod",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._jitRepositoryAttributeMapping?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jitRepositoryAttributeMapping = this._jitRepositoryAttributeMapping?.internalValue;
    }
    if (this._sqlMethod?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sqlMethod = this._sqlMethod?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._jitRepositoryAttributeMapping.internalValue = undefined;
      this._sqlMethod.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._jitRepositoryAttributeMapping.internalValue = value.jitRepositoryAttributeMapping;
      this._sqlMethod.internalValue = value.sqlMethod;
    }
  }

  // data_store_ref - computed: false, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // jit_repository_attribute_mapping - computed: false, optional: false, required: true
  private _jitRepositoryAttributeMapping = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMappingMap(this, "jit_repository_attribute_mapping");
  public get jitRepositoryAttributeMapping() {
    return this._jitRepositoryAttributeMapping;
  }
  public putJitRepositoryAttributeMapping(value: { [key: string]: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcJitRepositoryAttributeMapping } | cdktf.IResolvable) {
    this._jitRepositoryAttributeMapping.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get jitRepositoryAttributeMappingInput() {
    return this._jitRepositoryAttributeMapping.internalValue;
  }

  // sql_method - computed: false, optional: false, required: true
  private _sqlMethod = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethodOutputReference(this, "sql_method");
  public get sqlMethod() {
    return this._sqlMethod;
  }
  public putSqlMethod(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcSqlMethod) {
    this._sqlMethod.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlMethodInput() {
    return this._sqlMethod.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `ACCOUNT_LINK`, `ACTOR_TOKEN`, `ADAPTER`, `ASSERTION`, `ATTRIBUTE_QUERY`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `FRAGMENT`, `IDENTITY_STORE_GROUP`, `IDENTITY_STORE_USER`, `IDP_CONNECTION`, `INPUTS`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `LOCAL_IDENTITY_PROFILE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `OAUTH_PERSISTENT_GRANT`, `PASSWORD_CREDENTIAL_VALIDATOR`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `REQUEST`, `SCIM_GROUP`, `SCIM_USER`, `SUBJECT_TOKEN`, `TEXT`, `TOKEN`, `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `TRACKED_HTTP_PARAMS`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMapping {
  /**
  * A key that is meant to reference a source from which an attribute can be retrieved. This model is usually paired with a value which, depending on the SourceType, can be a hardcoded value or a reference to an attribute name specific to that SourceType. Not all values are applicable - a validation error will be returned for incorrect values.<br>For each SourceType, the value should be:<br>ACCOUNT_LINK - If account linking was enabled for the browser SSO, the value must be 'Local User ID', unless it has been overridden in PingFederate's server configuration.<br>ADAPTER - The value is one of the attributes of the IdP Adapter.<br>ASSERTION - The value is one of the attributes coming from the SAML assertion.<br>AUTHENTICATION_POLICY_CONTRACT - The value is one of the attributes coming from an authentication policy contract.<br>LOCAL_IDENTITY_PROFILE - The value is one of the fields coming from a local identity profile.<br>CONTEXT - The value must be one of the following ['TargetResource' or 'OAuthScopes' or 'ClientId' or 'AuthenticationCtx' or 'ClientIp' or 'Locale' or 'StsBasicAuthUsername' or 'StsSSLClientCertSubjectDN' or 'StsSSLClientCertChain' or 'VirtualServerId' or 'AuthenticatingAuthority' or 'DefaultPersistentGrantLifetime'.]<br>CLAIMS - Attributes provided by the OIDC Provider.<br>CUSTOM_DATA_STORE - The value is one of the attributes returned by this custom data store.<br>EXPRESSION - The value is an OGNL expression.<br>EXTENDED_CLIENT_METADATA - The value is from an OAuth extended client metadata parameter. This source type is deprecated and has been replaced by EXTENDED_PROPERTIES.<br>EXTENDED_PROPERTIES - The value is from an OAuth Client's extended property.<br>IDP_CONNECTION - The value is one of the attributes passed in by the IdP connection.<br>JDBC_DATA_STORE - The value is one of the column names returned from the JDBC attribute source.<br>LDAP_DATA_STORE - The value is one of the LDAP attributes supported by your LDAP data store.<br>MAPPED_ATTRIBUTES - The value is the name of one of the mapped attributes that is defined in the associated attribute mapping.<br>OAUTH_PERSISTENT_GRANT - The value is one of the attributes from the persistent grant.<br>PASSWORD_CREDENTIAL_VALIDATOR - The value is one of the attributes of the PCV.<br>NO_MAPPING - A placeholder value to indicate that an attribute currently has no mapped source.TEXT - A hardcoded value that is used to populate the corresponding attribute.<br>TOKEN - The value is one of the token attributes.<br>REQUEST - The value is from the request context such as the CIBA identity hint contract or the request contract for Ws-Trust.<br>TRACKED_HTTP_PARAMS - The value is from the original request parameters.<br>SUBJECT_TOKEN - The value is one of the OAuth 2.0 Token exchange subject_token attributes.<br>ACTOR_TOKEN - The value is one of the OAuth 2.0 Token exchange actor_token attributes.<br>TOKEN_EXCHANGE_PROCESSOR_POLICY - The value is one of the attributes coming from a Token Exchange Processor policy.<br>FRAGMENT - The value is one of the attributes coming from an authentication policy fragment.<br>INPUTS - The value is one of the attributes coming from an attribute defined in the input authentication policy contract for an authentication policy fragment.<br>ATTRIBUTE_QUERY - The value is one of the user attributes queried from an Attribute Authority.<br>IDENTITY_STORE_USER - The value is one of the attributes from a user identity store provisioner for SCIM processing.<br>IDENTITY_STORE_GROUP - The value is one of the attributes from a group identity store provisioner for SCIM processing.<br>SCIM_USER - The value is one of the attributes passed in from the SCIM user request.<br>SCIM_GROUP - The value is one of the attributes passed in from the SCIM group request.<br>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMapping | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMapping | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: false, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMapping } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingOutputReference {
    return new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdap {
  /**
  * The base DN to search from. If not specified, the search will start at the LDAP's root.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#base_dn SpIdpConnection#base_dn}
  */
  readonly baseDn?: string;
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRef;
  /**
  * The user repository attribute mapping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#jit_repository_attribute_mapping SpIdpConnection#jit_repository_attribute_mapping}
  */
  readonly jitRepositoryAttributeMapping: { [key: string]: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMapping } | cdktf.IResolvable;
  /**
  * The expression that results in a unique user identifier, when combined with the Base DN.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#unique_user_id_filter SpIdpConnection#unique_user_id_filter}
  */
  readonly uniqueUserIdFilter: string;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_dn: cdktf.stringToTerraform(struct!.baseDn),
    data_store_ref: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRefToTerraform(struct!.dataStoreRef),
    jit_repository_attribute_mapping: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingToTerraform)(struct!.jitRepositoryAttributeMapping),
    unique_user_id_filter: cdktf.stringToTerraform(struct!.uniqueUserIdFilter),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_dn: {
      value: cdktf.stringToHclTerraform(struct!.baseDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRef",
    },
    jit_repository_attribute_mapping: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingToHclTerraform)(struct!.jitRepositoryAttributeMapping),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingMap",
    },
    unique_user_id_filter: {
      value: cdktf.stringToHclTerraform(struct!.uniqueUserIdFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseDn = this._baseDn;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._jitRepositoryAttributeMapping?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jitRepositoryAttributeMapping = this._jitRepositoryAttributeMapping?.internalValue;
    }
    if (this._uniqueUserIdFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.uniqueUserIdFilter = this._uniqueUserIdFilter;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseDn = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._jitRepositoryAttributeMapping.internalValue = undefined;
      this._uniqueUserIdFilter = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseDn = value.baseDn;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._jitRepositoryAttributeMapping.internalValue = value.jitRepositoryAttributeMapping;
      this._uniqueUserIdFilter = value.uniqueUserIdFilter;
    }
  }

  // base_dn - computed: false, optional: true, required: false
  private _baseDn?: string; 
  public get baseDn() {
    return this.getStringAttribute('base_dn');
  }
  public set baseDn(value: string) {
    this._baseDn = value;
  }
  public resetBaseDn() {
    this._baseDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseDnInput() {
    return this._baseDn;
  }

  // data_store_ref - computed: false, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // jit_repository_attribute_mapping - computed: false, optional: false, required: true
  private _jitRepositoryAttributeMapping = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMappingMap(this, "jit_repository_attribute_mapping");
  public get jitRepositoryAttributeMapping() {
    return this._jitRepositoryAttributeMapping;
  }
  public putJitRepositoryAttributeMapping(value: { [key: string]: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapJitRepositoryAttributeMapping } | cdktf.IResolvable) {
    this._jitRepositoryAttributeMapping.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get jitRepositoryAttributeMappingInput() {
    return this._jitRepositoryAttributeMapping.internalValue;
  }

  // unique_user_id_filter - computed: false, optional: false, required: true
  private _uniqueUserIdFilter?: string; 
  public get uniqueUserIdFilter() {
    return this.getStringAttribute('unique_user_id_filter');
  }
  public set uniqueUserIdFilter(value: string) {
    this._uniqueUserIdFilter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get uniqueUserIdFilterInput() {
    return this._uniqueUserIdFilter;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepository {
  /**
  * JDBC data store user repository.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#jdbc SpIdpConnection#jdbc}
  */
  readonly jdbc?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbc;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#ldap SpIdpConnection#ldap}
  */
  readonly ldap?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdap;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepository | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jdbc: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcToTerraform(struct!.jdbc),
    ldap: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapToTerraform(struct!.ldap),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepository | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jdbc: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcToHclTerraform(struct!.jdbc),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbc",
    },
    ldap: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapToHclTerraform(struct!.ldap),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepository | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jdbc?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jdbc = this._jdbc?.internalValue;
    }
    if (this._ldap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldap = this._ldap?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepository | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jdbc.internalValue = undefined;
      this._ldap.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jdbc.internalValue = value.jdbc;
      this._ldap.internalValue = value.ldap;
    }
  }

  // jdbc - computed: false, optional: true, required: false
  private _jdbc = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbcOutputReference(this, "jdbc");
  public get jdbc() {
    return this._jdbc;
  }
  public putJdbc(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryJdbc) {
    this._jdbc.internalValue = value;
  }
  public resetJdbc() {
    this._jdbc.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jdbcInput() {
    return this._jdbc.internalValue;
  }

  // ldap - computed: false, optional: true, required: false
  private _ldap = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdapOutputReference(this, "ldap");
  public get ldap() {
    return this._ldap;
  }
  public putLdap(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryLdap) {
    this._ldap.internalValue = value;
  }
  public resetLdap() {
    this._ldap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapInput() {
    return this._ldap.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoJitProvisioning {
  /**
  * Specify behavior when provisioning request fails. The default is `CONTINUE_SSO`. Options are `ABORT_SSO`, `CONTINUE_SSO`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#error_handling SpIdpConnection#error_handling}
  */
  readonly errorHandling?: string;
  /**
  * Specify when provisioning occurs during assertion processing. The default is `NEW_USER_ONLY`. Options are `ALL_SAML_ASSERTIONS`, `NEW_USER_ONLY`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#event_trigger SpIdpConnection#event_trigger}
  */
  readonly eventTrigger?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#user_attributes SpIdpConnection#user_attributes}
  */
  readonly userAttributes: SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributes;
  /**
  * Jit Provisioning user repository data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#user_repository SpIdpConnection#user_repository}
  */
  readonly userRepository: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepository;
}

export function spIdpConnectionIdpBrowserSsoJitProvisioningToTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioning | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    error_handling: cdktf.stringToTerraform(struct!.errorHandling),
    event_trigger: cdktf.stringToTerraform(struct!.eventTrigger),
    user_attributes: spIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesToTerraform(struct!.userAttributes),
    user_repository: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryToTerraform(struct!.userRepository),
  }
}


export function spIdpConnectionIdpBrowserSsoJitProvisioningToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoJitProvisioning | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    error_handling: {
      value: cdktf.stringToHclTerraform(struct!.errorHandling),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_trigger: {
      value: cdktf.stringToHclTerraform(struct!.eventTrigger),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_attributes: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesToHclTerraform(struct!.userAttributes),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributes",
    },
    user_repository: {
      value: spIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryToHclTerraform(struct!.userRepository),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepository",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoJitProvisioningOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoJitProvisioning | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._errorHandling !== undefined) {
      hasAnyValues = true;
      internalValueResult.errorHandling = this._errorHandling;
    }
    if (this._eventTrigger !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventTrigger = this._eventTrigger;
    }
    if (this._userAttributes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.userAttributes = this._userAttributes?.internalValue;
    }
    if (this._userRepository?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.userRepository = this._userRepository?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoJitProvisioning | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._errorHandling = undefined;
      this._eventTrigger = undefined;
      this._userAttributes.internalValue = undefined;
      this._userRepository.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._errorHandling = value.errorHandling;
      this._eventTrigger = value.eventTrigger;
      this._userAttributes.internalValue = value.userAttributes;
      this._userRepository.internalValue = value.userRepository;
    }
  }

  // error_handling - computed: true, optional: true, required: false
  private _errorHandling?: string; 
  public get errorHandling() {
    return this.getStringAttribute('error_handling');
  }
  public set errorHandling(value: string) {
    this._errorHandling = value;
  }
  public resetErrorHandling() {
    this._errorHandling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorHandlingInput() {
    return this._errorHandling;
  }

  // event_trigger - computed: true, optional: true, required: false
  private _eventTrigger?: string; 
  public get eventTrigger() {
    return this.getStringAttribute('event_trigger');
  }
  public set eventTrigger(value: string) {
    this._eventTrigger = value;
  }
  public resetEventTrigger() {
    this._eventTrigger = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventTriggerInput() {
    return this._eventTrigger;
  }

  // user_attributes - computed: false, optional: false, required: true
  private _userAttributes = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributesOutputReference(this, "user_attributes");
  public get userAttributes() {
    return this._userAttributes;
  }
  public putUserAttributes(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserAttributes) {
    this._userAttributes.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userAttributesInput() {
    return this._userAttributes.internalValue;
  }

  // user_repository - computed: false, optional: false, required: true
  private _userRepository = new SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepositoryOutputReference(this, "user_repository");
  public get userRepository() {
    return this._userRepository;
  }
  public putUserRepository(value: SpIdpConnectionIdpBrowserSsoJitProvisioningUserRepository) {
    this._userRepository.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userRepositoryInput() {
    return this._userRepository.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoMessageCustomizations {
  /**
  * The context in which the customization will be applied. Depending on the connection type and protocol, this can either be `assertion`, `authn-response` or `authn-request`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#context_name SpIdpConnection#context_name}
  */
  readonly contextName?: string;
  /**
  * The OGNL expression that will be executed. Refer to the Admin Manual for a list of variables provided by PingFederate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#message_expression SpIdpConnection#message_expression}
  */
  readonly messageExpression?: string;
}

export function spIdpConnectionIdpBrowserSsoMessageCustomizationsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoMessageCustomizations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context_name: cdktf.stringToTerraform(struct!.contextName),
    message_expression: cdktf.stringToTerraform(struct!.messageExpression),
  }
}


export function spIdpConnectionIdpBrowserSsoMessageCustomizationsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoMessageCustomizations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context_name: {
      value: cdktf.stringToHclTerraform(struct!.contextName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_expression: {
      value: cdktf.stringToHclTerraform(struct!.messageExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoMessageCustomizationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoMessageCustomizations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contextName !== undefined) {
      hasAnyValues = true;
      internalValueResult.contextName = this._contextName;
    }
    if (this._messageExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageExpression = this._messageExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoMessageCustomizations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contextName = undefined;
      this._messageExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contextName = value.contextName;
      this._messageExpression = value.messageExpression;
    }
  }

  // context_name - computed: false, optional: true, required: false
  private _contextName?: string; 
  public get contextName() {
    return this.getStringAttribute('context_name');
  }
  public set contextName(value: string) {
    this._contextName = value;
  }
  public resetContextName() {
    this._contextName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextNameInput() {
    return this._contextName;
  }

  // message_expression - computed: false, optional: true, required: false
  private _messageExpression?: string; 
  public get messageExpression() {
    return this.getStringAttribute('message_expression');
  }
  public set messageExpression(value: string) {
    this._messageExpression = value;
  }
  public resetMessageExpression() {
    this._messageExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageExpressionInput() {
    return this._messageExpression;
  }
}

export class SpIdpConnectionIdpBrowserSsoMessageCustomizationsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoMessageCustomizations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoMessageCustomizationsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoMessageCustomizationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoOauthAuthenticationPolicyContractRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoOauthAuthenticationPolicyContractRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoOauthAuthenticationPolicyContractRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoOauthAuthenticationPolicyContractRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoOauthAuthenticationPolicyContractRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoOauthAuthenticationPolicyContractRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoOauthAuthenticationPolicyContractRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoOauthAuthenticationPolicyContractRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `ACTOR_TOKEN`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `ATTRIBUTE_QUERY`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `EXPRESSION`, `FRAGMENT`, `IDENTITY_STORE_GROUP`, `IDENTITY_STORE_USER`, `IDP_CONNECTION`, `INPUTS`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `LOCAL_IDENTITY_PROFILE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `OAUTH_PERSISTENT_GRANT`, `PASSWORD_CREDENTIAL_VALIDATOR`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `REQUEST`, `SCIM_GROUP`, `SCIM_USER`, `SUBJECT_TOKEN`, `TEXT`, `TOKEN`, `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `TRACKED_HTTP_PARAMS`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValue {
  /**
  * A key that is meant to reference a source from which an attribute can be retrieved. This model is usually paired with a value which, depending on the SourceType, can be a hardcoded value or a reference to an attribute name specific to that SourceType. Not all values are applicable - a validation error will be returned for incorrect values.<br>For each SourceType, the value should be:<br>ACCOUNT_LINK - If account linking was enabled for the browser SSO, the value must be 'Local User ID', unless it has been overridden in PingFederate's server configuration.<br>ADAPTER - The value is one of the attributes of the IdP Adapter.<br>ASSERTION - The value is one of the attributes coming from the SAML assertion.<br>AUTHENTICATION_POLICY_CONTRACT - The value is one of the attributes coming from an authentication policy contract.<br>LOCAL_IDENTITY_PROFILE - The value is one of the fields coming from a local identity profile.<br>CONTEXT - The value must be one of the following ['TargetResource' or 'OAuthScopes' or 'ClientId' or 'AuthenticationCtx' or 'ClientIp' or 'Locale' or 'StsBasicAuthUsername' or 'StsSSLClientCertSubjectDN' or 'StsSSLClientCertChain' or 'VirtualServerId' or 'AuthenticatingAuthority' or 'DefaultPersistentGrantLifetime'.]<br>CLAIMS - Attributes provided by the OIDC Provider.<br>CUSTOM_DATA_STORE - The value is one of the attributes returned by this custom data store.<br>EXPRESSION - The value is an OGNL expression.<br>EXTENDED_CLIENT_METADATA - The value is from an OAuth extended client metadata parameter. This source type is deprecated and has been replaced by EXTENDED_PROPERTIES.<br>EXTENDED_PROPERTIES - The value is from an OAuth Client's extended property.<br>IDP_CONNECTION - The value is one of the attributes passed in by the IdP connection.<br>JDBC_DATA_STORE - The value is one of the column names returned from the JDBC attribute source.<br>LDAP_DATA_STORE - The value is one of the LDAP attributes supported by your LDAP data store.<br>MAPPED_ATTRIBUTES - The value is the name of one of the mapped attributes that is defined in the associated attribute mapping.<br>OAUTH_PERSISTENT_GRANT - The value is one of the attributes from the persistent grant.<br>PASSWORD_CREDENTIAL_VALIDATOR - The value is one of the attributes of the PCV.<br>NO_MAPPING - A placeholder value to indicate that an attribute currently has no mapped source.TEXT - A hardcoded value that is used to populate the corresponding attribute.<br>TOKEN - The value is one of the token attributes.<br>REQUEST - The value is from the request context such as the CIBA identity hint contract or the request contract for Ws-Trust.<br>TRACKED_HTTP_PARAMS - The value is from the original request parameters.<br>SUBJECT_TOKEN - The value is one of the OAuth 2.0 Token exchange subject_token attributes.<br>ACTOR_TOKEN - The value is one of the OAuth 2.0 Token exchange actor_token attributes.<br>TOKEN_EXCHANGE_PROCESSOR_POLICY - The value is one of the attributes coming from a Token Exchange Processor policy.<br>FRAGMENT - The value is one of the attributes coming from an authentication policy fragment.<br>INPUTS - The value is one of the attributes coming from an attribute defined in the input authentication policy contract for an authentication policy fragment.<br>ATTRIBUTE_QUERY - The value is one of the user attributes queried from an Attribute Authority.<br>IDENTITY_STORE_USER - The value is one of the attributes from a user identity store provisioner for SCIM processing.<br>IDENTITY_STORE_GROUP - The value is one of the attributes from a group identity store provisioner for SCIM processing.<br>SCIM_USER - The value is one of the attributes passed in from the SCIM user request.<br>SCIM_GROUP - The value is one of the attributes passed in from the SCIM group request.<br>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueToTerraform(struct?: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValue): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValue): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValue | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValue | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParameters {
  /**
  * Indicates whether the parameter value can be overridden by an Application Endpoint parameter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#application_endpoint_override SpIdpConnection#application_endpoint_override}
  */
  readonly applicationEndpointOverride: boolean | cdktf.IResolvable;
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_value SpIdpConnection#attribute_value}
  */
  readonly attributeValue: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValue;
  /**
  * Request parameter name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * A request parameter value. A parameter can have either a value or a attribute value but not both. Value set here will be converted to an attribute value of source type TEXT. An empty value will be converted to attribute value of source type NO_MAPPING.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersToTerraform(struct?: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    application_endpoint_override: cdktf.booleanToTerraform(struct!.applicationEndpointOverride),
    attribute_value: spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueToTerraform(struct!.attributeValue),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    application_endpoint_override: {
      value: cdktf.booleanToHclTerraform(struct!.applicationEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    attribute_value: {
      value: spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueToHclTerraform(struct!.attributeValue),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValue",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._applicationEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.applicationEndpointOverride = this._applicationEndpointOverride;
    }
    if (this._attributeValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeValue = this._attributeValue?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._applicationEndpointOverride = undefined;
      this._attributeValue.internalValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._applicationEndpointOverride = value.applicationEndpointOverride;
      this._attributeValue.internalValue = value.attributeValue;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // application_endpoint_override - computed: true, optional: false, required: true
  private _applicationEndpointOverride?: boolean | cdktf.IResolvable; 
  public get applicationEndpointOverride() {
    return this.getBooleanAttribute('application_endpoint_override');
  }
  public set applicationEndpointOverride(value: boolean | cdktf.IResolvable) {
    this._applicationEndpointOverride = value;
  }
  // Temporarily expose input value. Use with caution.
  public get applicationEndpointOverrideInput() {
    return this._applicationEndpointOverride;
  }

  // attribute_value - computed: true, optional: false, required: true
  private _attributeValue = new SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValueOutputReference(this, "attribute_value");
  public get attributeValue() {
    return this._attributeValue;
  }
  public putAttributeValue(value: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersAttributeValue) {
    this._attributeValue.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeValueInput() {
    return this._attributeValue.internalValue;
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersOutputReference {
    return new SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoOidcProviderSettings {
  /**
  * The claim `aud`, that goes into the JWT body if specified. This is only used for client secret jwt and private key jwt auth schemes. Supported in PingFederate `12.3` and later.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#audience SpIdpConnection#audience}
  */
  readonly audience?: string;
  /**
  * The OpenID Connect Authentication Scheme. This is required for Authentication using Code Flow. Options are `BASIC`, `CLIENT_SECRET_JWT`, `POST`, `PRIVATE_KEY_JWT`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#authentication_scheme SpIdpConnection#authentication_scheme}
  */
  readonly authenticationScheme?: string;
  /**
  * The authentication signing algorithm for token endpoint PRIVATE_KEY_JWT or CLIENT_SECRET_JWT authentication. Asymmetric algorithms are allowed for PRIVATE_KEY_JWT and symmetric algorithms are allowed for CLIENT_SECRET_JWT. For RSASSA-PSS signing algorithm, PingFederate must be integrated with a hardware security module (HSM) or Java 11. Options are `NONE`, `ES256`, `ES384`, `ES512`, `HS256`, `HS384`, `HS512`, `PS256`, `PS384`, `PS512` `RS256`, `RS384`, `RS512`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#authentication_signing_algorithm SpIdpConnection#authentication_signing_algorithm}
  */
  readonly authenticationSigningAlgorithm?: string;
  /**
  * URL of the OpenID Provider's OAuth 2.0 Authorization Endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#authorization_endpoint SpIdpConnection#authorization_endpoint}
  */
  readonly authorizationEndpoint: string;
  /**
  * Enable Proof Key for Code Exchange (PKCE). When enabled, the client sends an SHA-256 code challenge and corresponding code verifier to the OpenID Provider during the authorization code flow. The default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#enable_pkce SpIdpConnection#enable_pkce}
  */
  readonly enablePkce?: boolean | cdktf.IResolvable;
  /**
  * Include the claim `nbf` in the JWT body. This is only used for client secret jwt and private key jwt auth schemes. Supported in PingFederate `12.3` and later. Default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#include_not_before_claim SpIdpConnection#include_not_before_claim}
  */
  readonly includeNotBeforeClaim?: boolean | cdktf.IResolvable;
  /**
  * URL of the OpenID Provider's JSON Web Key Set [JWK] document.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#jwks_url SpIdpConnection#jwks_url}
  */
  readonly jwksUrl: string;
  /**
  * The OpenId Connect JWT Secured Authorization Response Mode (JARM). The supported values are: <br>  `DISABLED`: Authorization responses will not be encoded using JARM. This is the default value. <br>  `QUERY_JWT`: query.jwt <br> `FORM_POST_JWT`: form_post.jwt <br><br> Note: `QUERY_JWT` must not be used in conjunction with loginType POST or  POST_AT unless the response JWT is encrypted to prevent token leakage in the URL. Supported in PingFederate `12.1` and later.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#jwt_secured_authorization_response_mode_type SpIdpConnection#jwt_secured_authorization_response_mode_type}
  */
  readonly jwtSecuredAuthorizationResponseModeType?: string;
  /**
  * The lifetime of the JWT in minutes. This is only used for client secret jwt and private key jwt auth schemes. Supported in PingFederate 12.3 and later.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#lifetime SpIdpConnection#lifetime}
  */
  readonly lifetime?: string;
  /**
  * The OpenID Connect login type. These values maps to: 
  *  CODE: Authentication using Code Flow 
  *   POST: Authentication using Form Post 
  *   POST_AT: Authentication using Form Post with Access Token. Options are `CODE`, `POST`, `POST_AT`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#login_type SpIdpConnection#login_type}
  */
  readonly loginType: string;
  /**
  * URL of the OpenID Provider's RP-Initiated Logout Endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#logout_endpoint SpIdpConnection#logout_endpoint}
  */
  readonly logoutEndpoint?: string;
  /**
  * URL of the OpenID Provider's OAuth 2.0 Pushed Authorization Request Endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#pushed_authorization_request_endpoint SpIdpConnection#pushed_authorization_request_endpoint}
  */
  readonly pushedAuthorizationRequestEndpoint?: string;
  /**
  * A list of request parameters. Request parameters with same name but different attribute values are treated as a multi-valued request parameter.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#request_parameters SpIdpConnection#request_parameters}
  */
  readonly requestParameters?: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParameters[] | cdktf.IResolvable;
  /**
  * The request signing algorithm. Required only if you wish to use signed requests. Only asymmetric algorithms are allowed. For RSASSA-PSS signing algorithm, PingFederate must be integrated with a hardware security module (HSM) or Java 11. Options are `ES256`, `ES384`, `ES512`, `HS256`, `HS384`, `HS512`, `NONE`, `PS256`, `PS384`, `PS512`, `RS256`, `RS384`, `RS512`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#request_signing_algorithm SpIdpConnection#request_signing_algorithm}
  */
  readonly requestSigningAlgorithm?: string;
  /**
  * Space separated scope values that the OpenID Provider supports.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#scopes SpIdpConnection#scopes}
  */
  readonly scopes: string;
  /**
  * URL of the OpenID Provider's OAuth 2.0 Token Endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#token_endpoint SpIdpConnection#token_endpoint}
  */
  readonly tokenEndpoint?: string;
  /**
  * Determines whether PingFederate tracks a logout entry when a user signs in, so that the user session can later be terminated via a logout request from the OP. This setting must also be enabled in order for PingFederate to send an RP-initiated logout request to the OP during SLO. Default value is `false`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#track_user_sessions_for_logout SpIdpConnection#track_user_sessions_for_logout}
  */
  readonly trackUserSessionsForLogout?: boolean | cdktf.IResolvable;
  /**
  * The header `typ`, that goes into the JWT header if specified. This is only used for client secret jwt and private key jwt auth schemes. Supported in PingFederate `12.3` and later.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type?: string;
  /**
  * URL of the OpenID Provider's UserInfo Endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#user_info_endpoint SpIdpConnection#user_info_endpoint}
  */
  readonly userInfoEndpoint?: string;
}

export function spIdpConnectionIdpBrowserSsoOidcProviderSettingsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoOidcProviderSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audience: cdktf.stringToTerraform(struct!.audience),
    authentication_scheme: cdktf.stringToTerraform(struct!.authenticationScheme),
    authentication_signing_algorithm: cdktf.stringToTerraform(struct!.authenticationSigningAlgorithm),
    authorization_endpoint: cdktf.stringToTerraform(struct!.authorizationEndpoint),
    enable_pkce: cdktf.booleanToTerraform(struct!.enablePkce),
    include_not_before_claim: cdktf.booleanToTerraform(struct!.includeNotBeforeClaim),
    jwks_url: cdktf.stringToTerraform(struct!.jwksUrl),
    jwt_secured_authorization_response_mode_type: cdktf.stringToTerraform(struct!.jwtSecuredAuthorizationResponseModeType),
    lifetime: cdktf.stringToTerraform(struct!.lifetime),
    login_type: cdktf.stringToTerraform(struct!.loginType),
    logout_endpoint: cdktf.stringToTerraform(struct!.logoutEndpoint),
    pushed_authorization_request_endpoint: cdktf.stringToTerraform(struct!.pushedAuthorizationRequestEndpoint),
    request_parameters: cdktf.listMapper(spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersToTerraform, false)(struct!.requestParameters),
    request_signing_algorithm: cdktf.stringToTerraform(struct!.requestSigningAlgorithm),
    scopes: cdktf.stringToTerraform(struct!.scopes),
    token_endpoint: cdktf.stringToTerraform(struct!.tokenEndpoint),
    track_user_sessions_for_logout: cdktf.booleanToTerraform(struct!.trackUserSessionsForLogout),
    type: cdktf.stringToTerraform(struct!.type),
    user_info_endpoint: cdktf.stringToTerraform(struct!.userInfoEndpoint),
  }
}


export function spIdpConnectionIdpBrowserSsoOidcProviderSettingsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoOidcProviderSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audience: {
      value: cdktf.stringToHclTerraform(struct!.audience),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_scheme: {
      value: cdktf.stringToHclTerraform(struct!.authenticationScheme),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_signing_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.authenticationSigningAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authorization_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.authorizationEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_pkce: {
      value: cdktf.booleanToHclTerraform(struct!.enablePkce),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    include_not_before_claim: {
      value: cdktf.booleanToHclTerraform(struct!.includeNotBeforeClaim),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    jwks_url: {
      value: cdktf.stringToHclTerraform(struct!.jwksUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jwt_secured_authorization_response_mode_type: {
      value: cdktf.stringToHclTerraform(struct!.jwtSecuredAuthorizationResponseModeType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    lifetime: {
      value: cdktf.stringToHclTerraform(struct!.lifetime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_type: {
      value: cdktf.stringToHclTerraform(struct!.loginType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    logout_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.logoutEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pushed_authorization_request_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.pushedAuthorizationRequestEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_parameters: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersToHclTerraform, false)(struct!.requestParameters),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersList",
    },
    request_signing_algorithm: {
      value: cdktf.stringToHclTerraform(struct!.requestSigningAlgorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    scopes: {
      value: cdktf.stringToHclTerraform(struct!.scopes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.tokenEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    track_user_sessions_for_logout: {
      value: cdktf.booleanToHclTerraform(struct!.trackUserSessionsForLogout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_info_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.userInfoEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoOidcProviderSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoOidcProviderSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audience !== undefined) {
      hasAnyValues = true;
      internalValueResult.audience = this._audience;
    }
    if (this._authenticationScheme !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationScheme = this._authenticationScheme;
    }
    if (this._authenticationSigningAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationSigningAlgorithm = this._authenticationSigningAlgorithm;
    }
    if (this._authorizationEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationEndpoint = this._authorizationEndpoint;
    }
    if (this._enablePkce !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePkce = this._enablePkce;
    }
    if (this._includeNotBeforeClaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeNotBeforeClaim = this._includeNotBeforeClaim;
    }
    if (this._jwksUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwksUrl = this._jwksUrl;
    }
    if (this._jwtSecuredAuthorizationResponseModeType !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwtSecuredAuthorizationResponseModeType = this._jwtSecuredAuthorizationResponseModeType;
    }
    if (this._lifetime !== undefined) {
      hasAnyValues = true;
      internalValueResult.lifetime = this._lifetime;
    }
    if (this._loginType !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginType = this._loginType;
    }
    if (this._logoutEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.logoutEndpoint = this._logoutEndpoint;
    }
    if (this._pushedAuthorizationRequestEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.pushedAuthorizationRequestEndpoint = this._pushedAuthorizationRequestEndpoint;
    }
    if (this._requestParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestParameters = this._requestParameters?.internalValue;
    }
    if (this._requestSigningAlgorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestSigningAlgorithm = this._requestSigningAlgorithm;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenEndpoint = this._tokenEndpoint;
    }
    if (this._trackUserSessionsForLogout !== undefined) {
      hasAnyValues = true;
      internalValueResult.trackUserSessionsForLogout = this._trackUserSessionsForLogout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._userInfoEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.userInfoEndpoint = this._userInfoEndpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoOidcProviderSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audience = undefined;
      this._authenticationScheme = undefined;
      this._authenticationSigningAlgorithm = undefined;
      this._authorizationEndpoint = undefined;
      this._enablePkce = undefined;
      this._includeNotBeforeClaim = undefined;
      this._jwksUrl = undefined;
      this._jwtSecuredAuthorizationResponseModeType = undefined;
      this._lifetime = undefined;
      this._loginType = undefined;
      this._logoutEndpoint = undefined;
      this._pushedAuthorizationRequestEndpoint = undefined;
      this._requestParameters.internalValue = undefined;
      this._requestSigningAlgorithm = undefined;
      this._scopes = undefined;
      this._tokenEndpoint = undefined;
      this._trackUserSessionsForLogout = undefined;
      this._type = undefined;
      this._userInfoEndpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audience = value.audience;
      this._authenticationScheme = value.authenticationScheme;
      this._authenticationSigningAlgorithm = value.authenticationSigningAlgorithm;
      this._authorizationEndpoint = value.authorizationEndpoint;
      this._enablePkce = value.enablePkce;
      this._includeNotBeforeClaim = value.includeNotBeforeClaim;
      this._jwksUrl = value.jwksUrl;
      this._jwtSecuredAuthorizationResponseModeType = value.jwtSecuredAuthorizationResponseModeType;
      this._lifetime = value.lifetime;
      this._loginType = value.loginType;
      this._logoutEndpoint = value.logoutEndpoint;
      this._pushedAuthorizationRequestEndpoint = value.pushedAuthorizationRequestEndpoint;
      this._requestParameters.internalValue = value.requestParameters;
      this._requestSigningAlgorithm = value.requestSigningAlgorithm;
      this._scopes = value.scopes;
      this._tokenEndpoint = value.tokenEndpoint;
      this._trackUserSessionsForLogout = value.trackUserSessionsForLogout;
      this._type = value.type;
      this._userInfoEndpoint = value.userInfoEndpoint;
    }
  }

  // audience - computed: false, optional: true, required: false
  private _audience?: string; 
  public get audience() {
    return this.getStringAttribute('audience');
  }
  public set audience(value: string) {
    this._audience = value;
  }
  public resetAudience() {
    this._audience = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audienceInput() {
    return this._audience;
  }

  // authentication_scheme - computed: false, optional: true, required: false
  private _authenticationScheme?: string; 
  public get authenticationScheme() {
    return this.getStringAttribute('authentication_scheme');
  }
  public set authenticationScheme(value: string) {
    this._authenticationScheme = value;
  }
  public resetAuthenticationScheme() {
    this._authenticationScheme = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationSchemeInput() {
    return this._authenticationScheme;
  }

  // authentication_signing_algorithm - computed: false, optional: true, required: false
  private _authenticationSigningAlgorithm?: string; 
  public get authenticationSigningAlgorithm() {
    return this.getStringAttribute('authentication_signing_algorithm');
  }
  public set authenticationSigningAlgorithm(value: string) {
    this._authenticationSigningAlgorithm = value;
  }
  public resetAuthenticationSigningAlgorithm() {
    this._authenticationSigningAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationSigningAlgorithmInput() {
    return this._authenticationSigningAlgorithm;
  }

  // authorization_endpoint - computed: false, optional: false, required: true
  private _authorizationEndpoint?: string; 
  public get authorizationEndpoint() {
    return this.getStringAttribute('authorization_endpoint');
  }
  public set authorizationEndpoint(value: string) {
    this._authorizationEndpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationEndpointInput() {
    return this._authorizationEndpoint;
  }

  // back_channel_logout_uri - computed: true, optional: false, required: false
  public get backChannelLogoutUri() {
    return this.getStringAttribute('back_channel_logout_uri');
  }

  // enable_pkce - computed: true, optional: true, required: false
  private _enablePkce?: boolean | cdktf.IResolvable; 
  public get enablePkce() {
    return this.getBooleanAttribute('enable_pkce');
  }
  public set enablePkce(value: boolean | cdktf.IResolvable) {
    this._enablePkce = value;
  }
  public resetEnablePkce() {
    this._enablePkce = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePkceInput() {
    return this._enablePkce;
  }

  // front_channel_logout_uri - computed: true, optional: false, required: false
  public get frontChannelLogoutUri() {
    return this.getStringAttribute('front_channel_logout_uri');
  }

  // include_not_before_claim - computed: true, optional: true, required: false
  private _includeNotBeforeClaim?: boolean | cdktf.IResolvable; 
  public get includeNotBeforeClaim() {
    return this.getBooleanAttribute('include_not_before_claim');
  }
  public set includeNotBeforeClaim(value: boolean | cdktf.IResolvable) {
    this._includeNotBeforeClaim = value;
  }
  public resetIncludeNotBeforeClaim() {
    this._includeNotBeforeClaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeNotBeforeClaimInput() {
    return this._includeNotBeforeClaim;
  }

  // jwks_url - computed: false, optional: false, required: true
  private _jwksUrl?: string; 
  public get jwksUrl() {
    return this.getStringAttribute('jwks_url');
  }
  public set jwksUrl(value: string) {
    this._jwksUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get jwksUrlInput() {
    return this._jwksUrl;
  }

  // jwt_secured_authorization_response_mode_type - computed: true, optional: true, required: false
  private _jwtSecuredAuthorizationResponseModeType?: string; 
  public get jwtSecuredAuthorizationResponseModeType() {
    return this.getStringAttribute('jwt_secured_authorization_response_mode_type');
  }
  public set jwtSecuredAuthorizationResponseModeType(value: string) {
    this._jwtSecuredAuthorizationResponseModeType = value;
  }
  public resetJwtSecuredAuthorizationResponseModeType() {
    this._jwtSecuredAuthorizationResponseModeType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtSecuredAuthorizationResponseModeTypeInput() {
    return this._jwtSecuredAuthorizationResponseModeType;
  }

  // lifetime - computed: false, optional: true, required: false
  private _lifetime?: string; 
  public get lifetime() {
    return this.getStringAttribute('lifetime');
  }
  public set lifetime(value: string) {
    this._lifetime = value;
  }
  public resetLifetime() {
    this._lifetime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lifetimeInput() {
    return this._lifetime;
  }

  // login_type - computed: false, optional: false, required: true
  private _loginType?: string; 
  public get loginType() {
    return this.getStringAttribute('login_type');
  }
  public set loginType(value: string) {
    this._loginType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get loginTypeInput() {
    return this._loginType;
  }

  // logout_endpoint - computed: false, optional: true, required: false
  private _logoutEndpoint?: string; 
  public get logoutEndpoint() {
    return this.getStringAttribute('logout_endpoint');
  }
  public set logoutEndpoint(value: string) {
    this._logoutEndpoint = value;
  }
  public resetLogoutEndpoint() {
    this._logoutEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logoutEndpointInput() {
    return this._logoutEndpoint;
  }

  // post_logout_redirect_uri - computed: true, optional: false, required: false
  public get postLogoutRedirectUri() {
    return this.getStringAttribute('post_logout_redirect_uri');
  }

  // pushed_authorization_request_endpoint - computed: false, optional: true, required: false
  private _pushedAuthorizationRequestEndpoint?: string; 
  public get pushedAuthorizationRequestEndpoint() {
    return this.getStringAttribute('pushed_authorization_request_endpoint');
  }
  public set pushedAuthorizationRequestEndpoint(value: string) {
    this._pushedAuthorizationRequestEndpoint = value;
  }
  public resetPushedAuthorizationRequestEndpoint() {
    this._pushedAuthorizationRequestEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pushedAuthorizationRequestEndpointInput() {
    return this._pushedAuthorizationRequestEndpoint;
  }

  // redirect_uri - computed: true, optional: false, required: false
  public get redirectUri() {
    return this.getStringAttribute('redirect_uri');
  }

  // request_parameters - computed: true, optional: true, required: false
  private _requestParameters = new SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParametersList(this, "request_parameters", true);
  public get requestParameters() {
    return this._requestParameters;
  }
  public putRequestParameters(value: SpIdpConnectionIdpBrowserSsoOidcProviderSettingsRequestParameters[] | cdktf.IResolvable) {
    this._requestParameters.internalValue = value;
  }
  public resetRequestParameters() {
    this._requestParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestParametersInput() {
    return this._requestParameters.internalValue;
  }

  // request_signing_algorithm - computed: false, optional: true, required: false
  private _requestSigningAlgorithm?: string; 
  public get requestSigningAlgorithm() {
    return this.getStringAttribute('request_signing_algorithm');
  }
  public set requestSigningAlgorithm(value: string) {
    this._requestSigningAlgorithm = value;
  }
  public resetRequestSigningAlgorithm() {
    this._requestSigningAlgorithm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestSigningAlgorithmInput() {
    return this._requestSigningAlgorithm;
  }

  // scopes - computed: false, optional: false, required: true
  private _scopes?: string; 
  public get scopes() {
    return this.getStringAttribute('scopes');
  }
  public set scopes(value: string) {
    this._scopes = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_endpoint - computed: false, optional: true, required: false
  private _tokenEndpoint?: string; 
  public get tokenEndpoint() {
    return this.getStringAttribute('token_endpoint');
  }
  public set tokenEndpoint(value: string) {
    this._tokenEndpoint = value;
  }
  public resetTokenEndpoint() {
    this._tokenEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenEndpointInput() {
    return this._tokenEndpoint;
  }

  // track_user_sessions_for_logout - computed: true, optional: true, required: false
  private _trackUserSessionsForLogout?: boolean | cdktf.IResolvable; 
  public get trackUserSessionsForLogout() {
    return this.getBooleanAttribute('track_user_sessions_for_logout');
  }
  public set trackUserSessionsForLogout(value: boolean | cdktf.IResolvable) {
    this._trackUserSessionsForLogout = value;
  }
  public resetTrackUserSessionsForLogout() {
    this._trackUserSessionsForLogout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get trackUserSessionsForLogoutInput() {
    return this._trackUserSessionsForLogout;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // user_info_endpoint - computed: false, optional: true, required: false
  private _userInfoEndpoint?: string; 
  public get userInfoEndpoint() {
    return this.getStringAttribute('user_info_endpoint');
  }
  public set userInfoEndpoint(value: string) {
    this._userInfoEndpoint = value;
  }
  public resetUserInfoEndpoint() {
    this._userInfoEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInfoEndpointInput() {
    return this._userInfoEndpoint;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSloServiceEndpoints {
  /**
  * The binding of this endpoint, if applicable - usually only required for SAML 2.0 endpoints. Options are `ARTIFACT`, `POST`, `REDIRECT`, `SOAP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#binding SpIdpConnection#binding}
  */
  readonly binding?: string;
  /**
  * The absolute or relative URL to which logout responses are sent. A relative URL can be specified if a base URL for the connection has been defined.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#response_url SpIdpConnection#response_url}
  */
  readonly responseUrl?: string;
  /**
  * The absolute or relative URL of the endpoint. A relative URL can be specified if a base URL for the connection has been defined.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#url SpIdpConnection#url}
  */
  readonly url: string;
}

export function spIdpConnectionIdpBrowserSsoSloServiceEndpointsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSloServiceEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    binding: cdktf.stringToTerraform(struct!.binding),
    response_url: cdktf.stringToTerraform(struct!.responseUrl),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function spIdpConnectionIdpBrowserSsoSloServiceEndpointsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSloServiceEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    binding: {
      value: cdktf.stringToHclTerraform(struct!.binding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_url: {
      value: cdktf.stringToHclTerraform(struct!.responseUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSloServiceEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSloServiceEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._binding !== undefined) {
      hasAnyValues = true;
      internalValueResult.binding = this._binding;
    }
    if (this._responseUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseUrl = this._responseUrl;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSloServiceEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._binding = undefined;
      this._responseUrl = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._binding = value.binding;
      this._responseUrl = value.responseUrl;
      this._url = value.url;
    }
  }

  // binding - computed: false, optional: true, required: false
  private _binding?: string; 
  public get binding() {
    return this.getStringAttribute('binding');
  }
  public set binding(value: string) {
    this._binding = value;
  }
  public resetBinding() {
    this._binding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingInput() {
    return this._binding;
  }

  // response_url - computed: false, optional: true, required: false
  private _responseUrl?: string; 
  public get responseUrl() {
    return this.getStringAttribute('response_url');
  }
  public set responseUrl(value: string) {
    this._responseUrl = value;
  }
  public resetResponseUrl() {
    this._responseUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseUrlInput() {
    return this._responseUrl;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}

export class SpIdpConnectionIdpBrowserSsoSloServiceEndpointsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoSloServiceEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoSloServiceEndpointsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSloServiceEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `ACTOR_TOKEN`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `ATTRIBUTE_QUERY`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `EXPRESSION`, `FRAGMENT`, `IDENTITY_STORE_GROUP`, `IDENTITY_STORE_USER`, `IDP_CONNECTION`, `INPUTS`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `LOCAL_IDENTITY_PROFILE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `OAUTH_PERSISTENT_GRANT`, `PASSWORD_CREDENTIAL_VALIDATOR`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `REQUEST`, `SCIM_GROUP`, `SCIM_USER`, `SUBJECT_TOKEN`, `TEXT`, `TOKEN`, `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `TRACKED_HTTP_PARAMS`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillment {
  /**
  * A key that is meant to reference a source from which an attribute can be retrieved. This model is usually paired with a value which, depending on the SourceType, can be a hardcoded value or a reference to an attribute name specific to that SourceType. Not all values are applicable - a validation error will be returned for incorrect values.<br>For each SourceType, the value should be:<br>ACCOUNT_LINK - If account linking was enabled for the browser SSO, the value must be 'Local User ID', unless it has been overridden in PingFederate's server configuration.<br>ADAPTER - The value is one of the attributes of the IdP Adapter.<br>ASSERTION - The value is one of the attributes coming from the SAML assertion.<br>AUTHENTICATION_POLICY_CONTRACT - The value is one of the attributes coming from an authentication policy contract.<br>LOCAL_IDENTITY_PROFILE - The value is one of the fields coming from a local identity profile.<br>CONTEXT - The value must be one of the following ['TargetResource' or 'OAuthScopes' or 'ClientId' or 'AuthenticationCtx' or 'ClientIp' or 'Locale' or 'StsBasicAuthUsername' or 'StsSSLClientCertSubjectDN' or 'StsSSLClientCertChain' or 'VirtualServerId' or 'AuthenticatingAuthority' or 'DefaultPersistentGrantLifetime'.]<br>CLAIMS - Attributes provided by the OIDC Provider.<br>CUSTOM_DATA_STORE - The value is one of the attributes returned by this custom data store.<br>EXPRESSION - The value is an OGNL expression.<br>EXTENDED_CLIENT_METADATA - The value is from an OAuth extended client metadata parameter. This source type is deprecated and has been replaced by EXTENDED_PROPERTIES.<br>EXTENDED_PROPERTIES - The value is from an OAuth Client's extended property.<br>IDP_CONNECTION - The value is one of the attributes passed in by the IdP connection.<br>JDBC_DATA_STORE - The value is one of the column names returned from the JDBC attribute source.<br>LDAP_DATA_STORE - The value is one of the LDAP attributes supported by your LDAP data store.<br>MAPPED_ATTRIBUTES - The value is the name of one of the mapped attributes that is defined in the associated attribute mapping.<br>OAUTH_PERSISTENT_GRANT - The value is one of the attributes from the persistent grant.<br>PASSWORD_CREDENTIAL_VALIDATOR - The value is one of the attributes of the PCV.<br>NO_MAPPING - A placeholder value to indicate that an attribute currently has no mapped source.TEXT - A hardcoded value that is used to populate the corresponding attribute.<br>TOKEN - The value is one of the token attributes.<br>REQUEST - The value is from the request context such as the CIBA identity hint contract or the request contract for Ws-Trust.<br>TRACKED_HTTP_PARAMS - The value is from the original request parameters.<br>SUBJECT_TOKEN - The value is one of the OAuth 2.0 Token exchange subject_token attributes.<br>ACTOR_TOKEN - The value is one of the OAuth 2.0 Token exchange actor_token attributes.<br>TOKEN_EXCHANGE_PROCESSOR_POLICY - The value is one of the attributes coming from a Token Exchange Processor policy.<br>FRAGMENT - The value is one of the attributes coming from an authentication policy fragment.<br>INPUTS - The value is one of the attributes coming from an attribute defined in the input authentication policy contract for an authentication policy fragment.<br>ATTRIBUTE_QUERY - The value is one of the user attributes queried from an Attribute Authority.<br>IDENTITY_STORE_USER - The value is one of the attributes from a user identity store provisioner for SCIM processing.<br>IDENTITY_STORE_GROUP - The value is one of the attributes from a group identity store provisioner for SCIM processing.<br>SCIM_USER - The value is one of the attributes passed in from the SCIM user request.<br>SCIM_GROUP - The value is one of the attributes passed in from the SCIM group request.<br>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: false, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFields {
  /**
  * The name of this field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#name SpIdpConnection#name}
  */
  readonly name: string;
  /**
  * The value of this field. Whether or not the value is required will be determined by plugin validation checks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * The list of fields that can be used to filter a request to the custom data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#filter_fields SpIdpConnection#filter_fields}
  */
  readonly filterFields?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable;
  /**
  * The ID that defines this attribute source. Only alphanumeric characters allowed. Note: Required for OpenID Connect policy attribute sources, OAuth IdP adapter mappings, OAuth access token mappings and APC-to-SP Adapter Mappings. IdP Connections will ignore this property since it only allows one attribute source to be defined per mapping. IdP-to-SP Adapter Mappings can contain multiple attribute sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    data_store_ref: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    filter_fields: cdktf.listMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsToTerraform, false)(struct!.filterFields),
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter_fields: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsToHclTerraform, false)(struct!.filterFields),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filterFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterFields = this._filterFields?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._filterFields.internalValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._filterFields.internalValue = value.filterFields;
      this._id = value.id;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter_fields - computed: true, optional: true, required: false
  private _filterFields = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFieldsList(this, "filter_fields", true);
  public get filterFields() {
    return this._filterFields;
  }
  public putFilterFields(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceFilterFields[] | cdktf.IResolvable) {
    this._filterFields.internalValue = value;
  }
  public resetFilterFields() {
    this._filterFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterFieldsInput() {
    return this._filterFields.internalValue;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: false
  public get type() {
    return this.getStringAttribute('type');
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * A list of column names used to construct the SQL query to retrieve data from the specified table in the datastore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#column_names SpIdpConnection#column_names}
  */
  readonly columnNames?: string[];
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * The JDBC WHERE clause used to query your data store to locate a user record.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#filter SpIdpConnection#filter}
  */
  readonly filter: string;
  /**
  * The ID that defines this attribute source. Only alphanumeric characters allowed. Note: Required for OpenID Connect policy attribute sources, OAuth IdP adapter mappings, OAuth access token mappings and APC-to-SP Adapter Mappings. IdP Connections will ignore this property since it only allows one attribute source to be defined per mapping. IdP-to-SP Adapter Mappings can contain multiple attribute sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Lists the table structure that stores information within a database. Some databases, such as Oracle, require a schema for a JDBC query. Other databases, such as MySQL, do not require a schema.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#schema SpIdpConnection#schema}
  */
  readonly schema?: string;
  /**
  * The name of the database table. The name is used to construct the SQL query to retrieve data from the data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#table SpIdpConnection#table}
  */
  readonly table: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    column_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.columnNames),
    data_store_ref: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
    id: cdktf.stringToTerraform(struct!.id),
    schema: cdktf.stringToTerraform(struct!.schema),
    table: cdktf.stringToTerraform(struct!.table),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap",
    },
    column_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.columnNames),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    schema: {
      value: cdktf.stringToHclTerraform(struct!.schema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    table: {
      value: cdktf.stringToHclTerraform(struct!.table),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._columnNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnNames = this._columnNames;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._schema !== undefined) {
      hasAnyValues = true;
      internalValueResult.schema = this._schema;
    }
    if (this._table !== undefined) {
      hasAnyValues = true;
      internalValueResult.table = this._table;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._columnNames = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._filter = undefined;
      this._id = undefined;
      this._schema = undefined;
      this._table = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._columnNames = value.columnNames;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._filter = value.filter;
      this._id = value.id;
      this._schema = value.schema;
      this._table = value.table;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // column_names - computed: true, optional: true, required: false
  private _columnNames?: string[]; 
  public get columnNames() {
    return cdktf.Fn.tolist(this.getListAttribute('column_names'));
  }
  public set columnNames(value: string[]) {
    this._columnNames = value;
  }
  public resetColumnNames() {
    this._columnNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnNamesInput() {
    return this._columnNames;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: true, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // schema - computed: true, optional: true, required: false
  private _schema?: string; 
  public get schema() {
    return this.getStringAttribute('schema');
  }
  public set schema(value: string) {
    this._schema = value;
  }
  public resetSchema() {
    this._schema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaInput() {
    return this._schema;
  }

  // table - computed: true, optional: false, required: true
  private _table?: string; 
  public get table() {
    return this.getStringAttribute('table');
  }
  public set table(value: string) {
    this._table = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tableInput() {
    return this._table;
  }

  // type - computed: true, optional: false, required: false
  public get type() {
    return this.getStringAttribute('type');
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillment {
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource;
  /**
  * The value for this attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value?: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    source: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    source: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettings {
  /**
  * Get the encoding type for this attribute. If not specified, the default is BASE64.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#binary_encoding SpIdpConnection#binary_encoding}
  */
  readonly binaryEncoding?: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    binary_encoding: cdktf.stringToTerraform(struct!.binaryEncoding),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    binary_encoding: {
      value: cdktf.stringToHclTerraform(struct!.binaryEncoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._binaryEncoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.binaryEncoding = this._binaryEncoding;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._binaryEncoding = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._binaryEncoding = value.binaryEncoding;
    }
  }

  // binary_encoding - computed: true, optional: true, required: false
  private _binaryEncoding?: string; 
  public get binaryEncoding() {
    return this.getStringAttribute('binary_encoding');
  }
  public set binaryEncoding(value: string) {
    this._binaryEncoding = value;
  }
  public resetBinaryEncoding() {
    this._binaryEncoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get binaryEncodingInput() {
    return this._binaryEncoding;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap extends cdktf.ComplexMap {
  public internalValue? : { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRef {
  /**
  * The ID of the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRefToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRefToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRef): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRef | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRef | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
    }
  }

  // id - computed: true, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSource {
  /**
  * Defines how an attribute in an attribute contract should be populated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment?: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * The base DN to search from. If not specified, the search will start at the LDAP's root.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#base_dn SpIdpConnection#base_dn}
  */
  readonly baseDn?: string;
  /**
  * The advanced settings for binary LDAP attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#binary_attribute_settings SpIdpConnection#binary_attribute_settings}
  */
  readonly binaryAttributeSettings?: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable;
  /**
  * Reference to the associated data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#data_store_ref SpIdpConnection#data_store_ref}
  */
  readonly dataStoreRef: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRef;
  /**
  * The description of this attribute source. The description needs to be unique amongst the attribute sources for the mapping.<br>Note: Required for APC-to-SP Adapter Mappings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#description SpIdpConnection#description}
  */
  readonly description?: string;
  /**
  * The ID that defines this attribute source. Only alphanumeric characters allowed. Note: Required for OpenID Connect policy attribute sources, OAuth IdP adapter mappings, OAuth access token mappings and APC-to-SP Adapter Mappings. IdP Connections will ignore this property since it only allows one attribute source to be defined per mapping. IdP-to-SP Adapter Mappings can contain multiple attribute sources.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Set this to true to return transitive group memberships for the 'memberOf' attribute.  This only applies for Active Directory data sources.  All other data sources will be set to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#member_of_nested_group SpIdpConnection#member_of_nested_group}
  */
  readonly memberOfNestedGroup?: boolean | cdktf.IResolvable;
  /**
  * A list of LDAP attributes returned from search and available for mapping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_attributes SpIdpConnection#search_attributes}
  */
  readonly searchAttributes?: string[];
  /**
  * The LDAP filter that will be used to lookup the objects from the directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_filter SpIdpConnection#search_filter}
  */
  readonly searchFilter: string;
  /**
  * Determines the node depth of the query.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#search_scope SpIdpConnection#search_scope}
  */
  readonly searchScope: string;
  /**
  * The data store type of this attribute source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    base_dn: cdktf.stringToTerraform(struct!.baseDn),
    binary_attribute_settings: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToTerraform)(struct!.binaryAttributeSettings),
    data_store_ref: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRefToTerraform(struct!.dataStoreRef),
    description: cdktf.stringToTerraform(struct!.description),
    id: cdktf.stringToTerraform(struct!.id),
    member_of_nested_group: cdktf.booleanToTerraform(struct!.memberOfNestedGroup),
    search_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.searchAttributes),
    search_filter: cdktf.stringToTerraform(struct!.searchFilter),
    search_scope: cdktf.stringToTerraform(struct!.searchScope),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap",
    },
    base_dn: {
      value: cdktf.stringToHclTerraform(struct!.baseDn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    binary_attribute_settings: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsToHclTerraform)(struct!.binaryAttributeSettings),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap",
    },
    data_store_ref: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRefToHclTerraform(struct!.dataStoreRef),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRef",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    member_of_nested_group: {
      value: cdktf.booleanToHclTerraform(struct!.memberOfNestedGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    search_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.searchAttributes),
      isBlock: false,
      type: "set",
      storageClassType: "stringList",
    },
    search_filter: {
      value: cdktf.stringToHclTerraform(struct!.searchFilter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_scope: {
      value: cdktf.stringToHclTerraform(struct!.searchScope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._baseDn !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseDn = this._baseDn;
    }
    if (this._binaryAttributeSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.binaryAttributeSettings = this._binaryAttributeSettings?.internalValue;
    }
    if (this._dataStoreRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataStoreRef = this._dataStoreRef?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._memberOfNestedGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.memberOfNestedGroup = this._memberOfNestedGroup;
    }
    if (this._searchAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchAttributes = this._searchAttributes;
    }
    if (this._searchFilter !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchFilter = this._searchFilter;
    }
    if (this._searchScope !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchScope = this._searchScope;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._baseDn = undefined;
      this._binaryAttributeSettings.internalValue = undefined;
      this._dataStoreRef.internalValue = undefined;
      this._description = undefined;
      this._id = undefined;
      this._memberOfNestedGroup = undefined;
      this._searchAttributes = undefined;
      this._searchFilter = undefined;
      this._searchScope = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._baseDn = value.baseDn;
      this._binaryAttributeSettings.internalValue = value.binaryAttributeSettings;
      this._dataStoreRef.internalValue = value.dataStoreRef;
      this._description = value.description;
      this._id = value.id;
      this._memberOfNestedGroup = value.memberOfNestedGroup;
      this._searchAttributes = value.searchAttributes;
      this._searchFilter = value.searchFilter;
      this._searchScope = value.searchScope;
      this._type = value.type;
    }
  }

  // attribute_contract_fulfillment - computed: true, optional: true, required: false
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  public resetAttributeContractFulfillment() {
    this._attributeContractFulfillment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // base_dn - computed: true, optional: true, required: false
  private _baseDn?: string; 
  public get baseDn() {
    return this.getStringAttribute('base_dn');
  }
  public set baseDn(value: string) {
    this._baseDn = value;
  }
  public resetBaseDn() {
    this._baseDn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseDnInput() {
    return this._baseDn;
  }

  // binary_attribute_settings - computed: true, optional: true, required: false
  private _binaryAttributeSettings = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettingsMap(this, "binary_attribute_settings");
  public get binaryAttributeSettings() {
    return this._binaryAttributeSettings;
  }
  public putBinaryAttributeSettings(value: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceBinaryAttributeSettings } | cdktf.IResolvable) {
    this._binaryAttributeSettings.internalValue = value;
  }
  public resetBinaryAttributeSettings() {
    this._binaryAttributeSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get binaryAttributeSettingsInput() {
    return this._binaryAttributeSettings.internalValue;
  }

  // data_store_ref - computed: true, optional: false, required: true
  private _dataStoreRef = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRefOutputReference(this, "data_store_ref");
  public get dataStoreRef() {
    return this._dataStoreRef;
  }
  public putDataStoreRef(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceDataStoreRef) {
    this._dataStoreRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataStoreRefInput() {
    return this._dataStoreRef.internalValue;
  }

  // description - computed: true, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // member_of_nested_group - computed: true, optional: true, required: false
  private _memberOfNestedGroup?: boolean | cdktf.IResolvable; 
  public get memberOfNestedGroup() {
    return this.getBooleanAttribute('member_of_nested_group');
  }
  public set memberOfNestedGroup(value: boolean | cdktf.IResolvable) {
    this._memberOfNestedGroup = value;
  }
  public resetMemberOfNestedGroup() {
    this._memberOfNestedGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memberOfNestedGroupInput() {
    return this._memberOfNestedGroup;
  }

  // search_attributes - computed: true, optional: true, required: false
  private _searchAttributes?: string[]; 
  public get searchAttributes() {
    return cdktf.Fn.tolist(this.getListAttribute('search_attributes'));
  }
  public set searchAttributes(value: string[]) {
    this._searchAttributes = value;
  }
  public resetSearchAttributes() {
    this._searchAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchAttributesInput() {
    return this._searchAttributes;
  }

  // search_filter - computed: true, optional: false, required: true
  private _searchFilter?: string; 
  public get searchFilter() {
    return this.getStringAttribute('search_filter');
  }
  public set searchFilter(value: string) {
    this._searchFilter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get searchFilterInput() {
    return this._searchFilter;
  }

  // search_scope - computed: true, optional: false, required: true
  private _searchScope?: string; 
  public get searchScope() {
    return this.getStringAttribute('search_scope');
  }
  public set searchScope(value: string) {
    this._searchScope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get searchScopeInput() {
    return this._searchScope;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSources {
  /**
  * The configured settings used to look up attributes from a custom data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#custom_attribute_source SpIdpConnection#custom_attribute_source}
  */
  readonly customAttributeSource?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSource;
  /**
  * The configured settings used to look up attributes from a JDBC data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#jdbc_attribute_source SpIdpConnection#jdbc_attribute_source}
  */
  readonly jdbcAttributeSource?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSource;
  /**
  * The configured settings used to look up attributes from a LDAP data store.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#ldap_attribute_source SpIdpConnection#ldap_attribute_source}
  */
  readonly ldapAttributeSource?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSource;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_attribute_source: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceToTerraform(struct!.customAttributeSource),
    jdbc_attribute_source: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceToTerraform(struct!.jdbcAttributeSource),
    ldap_attribute_source: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceToTerraform(struct!.ldapAttributeSource),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceToHclTerraform(struct!.customAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSource",
    },
    jdbc_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceToHclTerraform(struct!.jdbcAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSource",
    },
    ldap_attribute_source: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceToHclTerraform(struct!.ldapAttributeSource),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAttributeSource = this._customAttributeSource?.internalValue;
    }
    if (this._jdbcAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jdbcAttributeSource = this._jdbcAttributeSource?.internalValue;
    }
    if (this._ldapAttributeSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldapAttributeSource = this._ldapAttributeSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customAttributeSource.internalValue = undefined;
      this._jdbcAttributeSource.internalValue = undefined;
      this._ldapAttributeSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customAttributeSource.internalValue = value.customAttributeSource;
      this._jdbcAttributeSource.internalValue = value.jdbcAttributeSource;
      this._ldapAttributeSource.internalValue = value.ldapAttributeSource;
    }
  }

  // custom_attribute_source - computed: true, optional: true, required: false
  private _customAttributeSource = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSourceOutputReference(this, "custom_attribute_source");
  public get customAttributeSource() {
    return this._customAttributeSource;
  }
  public putCustomAttributeSource(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesCustomAttributeSource) {
    this._customAttributeSource.internalValue = value;
  }
  public resetCustomAttributeSource() {
    this._customAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customAttributeSourceInput() {
    return this._customAttributeSource.internalValue;
  }

  // jdbc_attribute_source - computed: true, optional: true, required: false
  private _jdbcAttributeSource = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSourceOutputReference(this, "jdbc_attribute_source");
  public get jdbcAttributeSource() {
    return this._jdbcAttributeSource;
  }
  public putJdbcAttributeSource(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesJdbcAttributeSource) {
    this._jdbcAttributeSource.internalValue = value;
  }
  public resetJdbcAttributeSource() {
    this._jdbcAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jdbcAttributeSourceInput() {
    return this._jdbcAttributeSource.internalValue;
  }

  // ldap_attribute_source - computed: true, optional: true, required: false
  private _ldapAttributeSource = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSourceOutputReference(this, "ldap_attribute_source");
  public get ldapAttributeSource() {
    return this._ldapAttributeSource;
  }
  public putLdapAttributeSource(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesLdapAttributeSource) {
    this._ldapAttributeSource.internalValue = value;
  }
  public resetLdapAttributeSource() {
    this._ldapAttributeSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapAttributeSourceInput() {
    return this._ldapAttributeSource.internalValue;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSources[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSource {
  /**
  * The attribute source ID that refers to the attribute source that this key references. In some resources, the ID is optional and will be ignored. In these cases the ID should be omitted. If the source type is not an attribute source then the ID can be omitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#id SpIdpConnection#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The source type of this key. Options are `TOKEN_EXCHANGE_PROCESSOR_POLICY`, `ACCOUNT_LINK`, `ADAPTER`, `ASSERTION`, `CONTEXT`, `CUSTOM_DATA_STORE`, `EXPRESSION`, `JDBC_DATA_STORE`, `LDAP_DATA_STORE`, `PING_ONE_LDAP_GATEWAY_DATA_STORE`, `MAPPED_ATTRIBUTES`, `NO_MAPPING`, `TEXT`, `TOKEN`, `REQUEST`, `OAUTH_PERSISTENT_GRANT`, `SUBJECT_TOKEN`, `ACTOR_TOKEN`, `PASSWORD_CREDENTIAL_VALIDATOR`, `IDP_CONNECTION`, `AUTHENTICATION_POLICY_CONTRACT`, `CLAIMS`, `LOCAL_IDENTITY_PROFILE`, `EXTENDED_CLIENT_METADATA`, `EXTENDED_PROPERTIES`, `TRACKED_HTTP_PARAMS`, `FRAGMENT`, `INPUTS`, `ATTRIBUTE_QUERY`, `IDENTITY_STORE_USER`, `IDENTITY_STORE_GROUP`, `SCIM_USER`, `SCIM_GROUP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#type SpIdpConnection#type}
  */
  readonly type: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSourceToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSourceToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSource): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSource | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSource | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._id = undefined;
      this._type = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: true, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteria {
  /**
  * The name of the attribute to use in this issuance criterion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_name SpIdpConnection#attribute_name}
  */
  readonly attributeName: string;
  /**
  * The condition that will be applied to the source attribute's value and the expected value. Options are `EQUALS`, `EQUALS_CASE_INSENSITIVE`, `EQUALS_DN`, `NOT_EQUAL`, `NOT_EQUAL_CASE_INSENSITIVE`, `NOT_EQUAL_DN`, `MULTIVALUE_CONTAINS`, `MULTIVALUE_CONTAINS_CASE_INSENSITIVE`, `MULTIVALUE_CONTAINS_DN`, `MULTIVALUE_DOES_NOT_CONTAIN`, `MULTIVALUE_DOES_NOT_CONTAIN_CASE_INSENSITIVE`, `MULTIVALUE_DOES_NOT_CONTAIN_DN`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#condition SpIdpConnection#condition}
  */
  readonly condition: string;
  /**
  * The error result to return if this issuance criterion fails. This error result will show up in the PingFederate server logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#error_result SpIdpConnection#error_result}
  */
  readonly errorResult?: string;
  /**
  * The attribute value source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#source SpIdpConnection#source}
  */
  readonly source: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSource;
  /**
  * The expected value of this issuance criterion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#value SpIdpConnection#value}
  */
  readonly value: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_name: cdktf.stringToTerraform(struct!.attributeName),
    condition: cdktf.stringToTerraform(struct!.condition),
    error_result: cdktf.stringToTerraform(struct!.errorResult),
    source: spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSourceToTerraform(struct!.source),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.attributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    condition: {
      value: cdktf.stringToHclTerraform(struct!.condition),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    error_result: {
      value: cdktf.stringToHclTerraform(struct!.errorResult),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSourceToHclTerraform(struct!.source),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSource",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeName = this._attributeName;
    }
    if (this._condition !== undefined) {
      hasAnyValues = true;
      internalValueResult.condition = this._condition;
    }
    if (this._errorResult !== undefined) {
      hasAnyValues = true;
      internalValueResult.errorResult = this._errorResult;
    }
    if (this._source?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeName = undefined;
      this._condition = undefined;
      this._errorResult = undefined;
      this._source.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeName = value.attributeName;
      this._condition = value.condition;
      this._errorResult = value.errorResult;
      this._source.internalValue = value.source;
      this._value = value.value;
    }
  }

  // attribute_name - computed: true, optional: false, required: true
  private _attributeName?: string; 
  public get attributeName() {
    return this.getStringAttribute('attribute_name');
  }
  public set attributeName(value: string) {
    this._attributeName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeNameInput() {
    return this._attributeName;
  }

  // condition - computed: true, optional: false, required: true
  private _condition?: string; 
  public get condition() {
    return this.getStringAttribute('condition');
  }
  public set condition(value: string) {
    this._condition = value;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionInput() {
    return this._condition;
  }

  // error_result - computed: true, optional: true, required: false
  private _errorResult?: string; 
  public get errorResult() {
    return this.getStringAttribute('error_result');
  }
  public set errorResult(value: string) {
    this._errorResult = value;
  }
  public resetErrorResult() {
    this._errorResult = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorResultInput() {
    return this._errorResult;
  }

  // source - computed: true, optional: false, required: true
  private _source = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSourceOutputReference(this, "source");
  public get source() {
    return this._source;
  }
  public putSource(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaSource) {
    this._source.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source.internalValue;
  }

  // value - computed: true, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteria {
  /**
  * The error result to return if this issuance criterion fails. This error result will show up in the PingFederate server logs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#error_result SpIdpConnection#error_result}
  */
  readonly errorResult?: string;
  /**
  * The OGNL expression to evaluate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#expression SpIdpConnection#expression}
  */
  readonly expression: string;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    error_result: cdktf.stringToTerraform(struct!.errorResult),
    expression: cdktf.stringToTerraform(struct!.expression),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    error_result: {
      value: cdktf.stringToHclTerraform(struct!.errorResult),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expression: {
      value: cdktf.stringToHclTerraform(struct!.expression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._errorResult !== undefined) {
      hasAnyValues = true;
      internalValueResult.errorResult = this._errorResult;
    }
    if (this._expression !== undefined) {
      hasAnyValues = true;
      internalValueResult.expression = this._expression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._errorResult = undefined;
      this._expression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._errorResult = value.errorResult;
      this._expression = value.expression;
    }
  }

  // error_result - computed: true, optional: true, required: false
  private _errorResult?: string; 
  public get errorResult() {
    return this.getStringAttribute('error_result');
  }
  public set errorResult(value: string) {
    this._errorResult = value;
  }
  public resetErrorResult() {
    this._errorResult = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorResultInput() {
    return this._errorResult;
  }

  // expression - computed: true, optional: false, required: true
  private _expression?: string; 
  public get expression() {
    return this.getStringAttribute('expression');
  }
  public set expression(value: string) {
    this._expression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionInput() {
    return this._expression;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteria {
  /**
  * A list of conditional issuance criteria where existing attributes must satisfy their conditions against expected values in order for the transaction to continue.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#conditional_criteria SpIdpConnection#conditional_criteria}
  */
  readonly conditionalCriteria?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable;
  /**
  * A list of expression issuance criteria where the OGNL expressions must evaluate to true in order for the transaction to continue. Expressions must be enabled in PingFederate to use expression criteria.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#expression_criteria SpIdpConnection#expression_criteria}
  */
  readonly expressionCriteria?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    conditional_criteria: cdktf.listMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaToTerraform, false)(struct!.conditionalCriteria),
    expression_criteria: cdktf.listMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaToTerraform, false)(struct!.expressionCriteria),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteria | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    conditional_criteria: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaToHclTerraform, false)(struct!.conditionalCriteria),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaList",
    },
    expression_criteria: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaToHclTerraform, false)(struct!.expressionCriteria),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteria | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._conditionalCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.conditionalCriteria = this._conditionalCriteria?.internalValue;
    }
    if (this._expressionCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expressionCriteria = this._expressionCriteria?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteria | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._conditionalCriteria.internalValue = undefined;
      this._expressionCriteria.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._conditionalCriteria.internalValue = value.conditionalCriteria;
      this._expressionCriteria.internalValue = value.expressionCriteria;
    }
  }

  // conditional_criteria - computed: true, optional: true, required: false
  private _conditionalCriteria = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteriaList(this, "conditional_criteria", true);
  public get conditionalCriteria() {
    return this._conditionalCriteria;
  }
  public putConditionalCriteria(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaConditionalCriteria[] | cdktf.IResolvable) {
    this._conditionalCriteria.internalValue = value;
  }
  public resetConditionalCriteria() {
    this._conditionalCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionalCriteriaInput() {
    return this._conditionalCriteria.internalValue;
  }

  // expression_criteria - computed: true, optional: true, required: false
  private _expressionCriteria = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteriaList(this, "expression_criteria", true);
  public get expressionCriteria() {
    return this._expressionCriteria;
  }
  public putExpressionCriteria(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaExpressionCriteria[] | cdktf.IResolvable) {
    this._expressionCriteria.internalValue = value;
  }
  public resetExpressionCriteria() {
    this._expressionCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionCriteriaInput() {
    return this._expressionCriteria.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoOauthMapping {
  /**
  * A list of mappings from attribute names to their fulfillment values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_contract_fulfillment SpIdpConnection#attribute_contract_fulfillment}
  */
  readonly attributeContractFulfillment: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillment } | cdktf.IResolvable;
  /**
  * A list of configured data stores to look up attributes from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#attribute_sources SpIdpConnection#attribute_sources}
  */
  readonly attributeSources?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSources[] | cdktf.IResolvable;
  /**
  * The issuance criteria that this transaction must meet before the corresponding attribute contract is fulfilled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#issuance_criteria SpIdpConnection#issuance_criteria}
  */
  readonly issuanceCriteria?: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteria;
}

export function spIdpConnectionIdpBrowserSsoSsoOauthMappingToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute_contract_fulfillment: cdktf.hashMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentToTerraform)(struct!.attributeContractFulfillment),
    attribute_sources: cdktf.listMapper(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesToTerraform, false)(struct!.attributeSources),
    issuance_criteria: spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaToTerraform(struct!.issuanceCriteria),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoOauthMappingToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoOauthMapping | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute_contract_fulfillment: {
      value: cdktf.hashMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentToHclTerraform)(struct!.attributeContractFulfillment),
      isBlock: true,
      type: "map",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentMap",
    },
    attribute_sources: {
      value: cdktf.listMapperHcl(spIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesToHclTerraform, false)(struct!.attributeSources),
      isBlock: true,
      type: "set",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesList",
    },
    issuance_criteria: {
      value: spIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaToHclTerraform(struct!.issuanceCriteria),
      isBlock: true,
      type: "struct",
      storageClassType: "SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteria",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoOauthMappingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoOauthMapping | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributeContractFulfillment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeContractFulfillment = this._attributeContractFulfillment?.internalValue;
    }
    if (this._attributeSources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributeSources = this._attributeSources?.internalValue;
    }
    if (this._issuanceCriteria?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuanceCriteria = this._issuanceCriteria?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoOauthMapping | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = undefined;
      this._attributeSources.internalValue = undefined;
      this._issuanceCriteria.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributeContractFulfillment.internalValue = value.attributeContractFulfillment;
      this._attributeSources.internalValue = value.attributeSources;
      this._issuanceCriteria.internalValue = value.issuanceCriteria;
    }
  }

  // attribute_contract_fulfillment - computed: false, optional: false, required: true
  private _attributeContractFulfillment = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillmentMap(this, "attribute_contract_fulfillment");
  public get attributeContractFulfillment() {
    return this._attributeContractFulfillment;
  }
  public putAttributeContractFulfillment(value: { [key: string]: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeContractFulfillment } | cdktf.IResolvable) {
    this._attributeContractFulfillment.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeContractFulfillmentInput() {
    return this._attributeContractFulfillment.internalValue;
  }

  // attribute_sources - computed: true, optional: true, required: false
  private _attributeSources = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSourcesList(this, "attribute_sources", true);
  public get attributeSources() {
    return this._attributeSources;
  }
  public putAttributeSources(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingAttributeSources[] | cdktf.IResolvable) {
    this._attributeSources.internalValue = value;
  }
  public resetAttributeSources() {
    this._attributeSources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeSourcesInput() {
    return this._attributeSources.internalValue;
  }

  // issuance_criteria - computed: true, optional: true, required: false
  private _issuanceCriteria = new SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteriaOutputReference(this, "issuance_criteria");
  public get issuanceCriteria() {
    return this._issuanceCriteria;
  }
  public putIssuanceCriteria(value: SpIdpConnectionIdpBrowserSsoSsoOauthMappingIssuanceCriteria) {
    this._issuanceCriteria.internalValue = value;
  }
  public resetIssuanceCriteria() {
    this._issuanceCriteria.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuanceCriteriaInput() {
    return this._issuanceCriteria.internalValue;
  }
}
export interface SpIdpConnectionIdpBrowserSsoSsoServiceEndpoints {
  /**
  * The binding of this endpoint, if applicable - usually only required for SAML 2.0 endpoints. Options are `ARTIFACT`, `POST`, `REDIRECT`, `SOAP`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#binding SpIdpConnection#binding}
  */
  readonly binding?: string;
  /**
  * The absolute or relative URL of the endpoint. A relative URL can be specified if a base URL for the connection has been defined.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#url SpIdpConnection#url}
  */
  readonly url: string;
}

export function spIdpConnectionIdpBrowserSsoSsoServiceEndpointsToTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoServiceEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    binding: cdktf.stringToTerraform(struct!.binding),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function spIdpConnectionIdpBrowserSsoSsoServiceEndpointsToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoSsoServiceEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    binding: {
      value: cdktf.stringToHclTerraform(struct!.binding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoSsoServiceEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoSsoServiceEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._binding !== undefined) {
      hasAnyValues = true;
      internalValueResult.binding = this._binding;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoSsoServiceEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._binding = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._binding = value.binding;
      this._url = value.url;
    }
  }

  // binding - computed: false, optional: true, required: false
  private _binding?: string; 
  public get binding() {
    return this.getStringAttribute('binding');
  }
  public set binding(value: string) {
    this._binding = value;
  }
  public resetBinding() {
    this._binding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingInput() {
    return this._binding;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}

export class SpIdpConnectionIdpBrowserSsoSsoServiceEndpointsList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoSsoServiceEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoSsoServiceEndpointsOutputReference {
    return new SpIdpConnectionIdpBrowserSsoSsoServiceEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SpIdpConnectionIdpBrowserSsoUrlWhitelistEntries {
  /**
  * Allow Any Query/Fragment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#allow_query_and_fragment SpIdpConnection#allow_query_and_fragment}
  */
  readonly allowQueryAndFragment?: boolean | cdktf.IResolvable;
  /**
  * Require HTTPS
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#require_https SpIdpConnection#require_https}
  */
  readonly requireHttps?: boolean | cdktf.IResolvable;
  /**
  * Valid Domain Name (leading wildcard '*.' allowed)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#valid_domain SpIdpConnection#valid_domain}
  */
  readonly validDomain?: string;
  /**
  * Valid Path (leave blank to allow any path)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/pingidentity/pingfederate/1.6.2/docs/resources/sp_idp_connection#valid_path SpIdpConnection#valid_path}
  */
  readonly validPath?: string;
}

export function spIdpConnectionIdpBrowserSsoUrlWhitelistEntriesToTerraform(struct?: SpIdpConnectionIdpBrowserSsoUrlWhitelistEntries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_query_and_fragment: cdktf.booleanToTerraform(struct!.allowQueryAndFragment),
    require_https: cdktf.booleanToTerraform(struct!.requireHttps),
    valid_domain: cdktf.stringToTerraform(struct!.validDomain),
    valid_path: cdktf.stringToTerraform(struct!.validPath),
  }
}


export function spIdpConnectionIdpBrowserSsoUrlWhitelistEntriesToHclTerraform(struct?: SpIdpConnectionIdpBrowserSsoUrlWhitelistEntries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_query_and_fragment: {
      value: cdktf.booleanToHclTerraform(struct!.allowQueryAndFragment),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    require_https: {
      value: cdktf.booleanToHclTerraform(struct!.requireHttps),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    valid_domain: {
      value: cdktf.stringToHclTerraform(struct!.validDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    valid_path: {
      value: cdktf.stringToHclTerraform(struct!.validPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SpIdpConnectionIdpBrowserSsoUrlWhitelistEntriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SpIdpConnectionIdpBrowserSsoUrlWhitelistEntries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowQueryAndFragment !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowQueryAndFragment = this._allowQueryAndFragment;
    }
    if (this._requireHttps !== undefined) {
      hasAnyValues = true;
      internalValueResult.requireHttps = this._requireHttps;
    }
    if (this._validDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.validDomain = this._validDomain;
    }
    if (this._validPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.validPath = this._validPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SpIdpConnectionIdpBrowserSsoUrlWhitelistEntries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowQueryAndFragment = undefined;
      this._requireHttps = undefined;
      this._validDomain = undefined;
      this._validPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowQueryAndFragment = value.allowQueryAndFragment;
      this._requireHttps = value.requireHttps;
      this._validDomain = value.validDomain;
      this._validPath = value.validPath;
    }
  }

  // allow_query_and_fragment - computed: false, optional: true, required: false
  private _allowQueryAndFragment?: boolean | cdktf.IResolvable; 
  public get allowQueryAndFragment() {
    return this.getBooleanAttribute('allow_query_and_fragment');
  }
  public set allowQueryAndFragment(value: boolean | cdktf.IResolvable) {
    this._allowQueryAndFragment = value;
  }
  public resetAllowQueryAndFragment() {
    this._allowQueryAndFragment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowQueryAndFragmentInput() {
    return this._allowQueryAndFragment;
  }

  // require_https - computed: false, optional: true, required: false
  private _requireHttps?: boolean | cdktf.IResolvable; 
  public get requireHttps() {
    return this.getBooleanAttribute('require_https');
  }
  public set requireHttps(value: boolean | cdktf.IResolvable) {
    this._requireHttps = value;
  }
  public resetRequireHttps() {
    this._requireHttps = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requireHttpsInput() {
    return this._requireHttps;
  }

  // valid_domain - computed: false, optional: true, required: false
  private _validDomain?: string; 
  public get validDomain() {
    return this.getStringAttribute('valid_domain');
  }
  public set validDomain(value: string) {
    this._validDomain = value;
  }
  public resetValidDomain() {
    this._validDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validDomainInput() {
    return this._validDomain;
  }

  // valid_path - computed: true, optional: true, required: false
  private _validPath?: string; 
  public get validPath() {
    return this.getStringAttribute('valid_path');
  }
  public set validPath(value: string) {
    this._validPath = value;
  }
  public resetValidPath() {
    this._validPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validPathInput() {
    return this._validPath;
  }
}

export class SpIdpConnectionIdpBrowserSsoUrlWhitelistEntriesList extends cdktf.ComplexList {
  public internalValue? : SpIdpConnectionIdpBrowserSsoUrlWhitelistEntries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SpIdpConnectionIdpBrowserSsoUrlWhitelistEntriesOutputReference {
    return new SpIdpConnectionIdpBrowserSsoUrlWhitelistEntriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
