// https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface FunctionRuntimePolicyConfig extends cdktf.TerraformMetaArguments {
  /**
  * Indicates the application scope of the service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#application_scopes FunctionRuntimePolicy#application_scopes}
  */
  readonly applicationScopes?: string[];
  /**
  * Block deployment from disallowed images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#block_disallowed_images FunctionRuntimePolicy#block_disallowed_images}
  */
  readonly blockDisallowedImages?: boolean | cdktf.IResolvable;
  /**
  * Block fileless execution attempts.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#block_fileless_exec FunctionRuntimePolicy#block_fileless_exec}
  */
  readonly blockFilelessExec?: boolean | cdktf.IResolvable;
  /**
  * Block non-compliant serverless functions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#block_non_compliant_workloads FunctionRuntimePolicy#block_non_compliant_workloads}
  */
  readonly blockNonCompliantWorkloads?: boolean | cdktf.IResolvable;
  /**
  * The description of the function runtime policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#description FunctionRuntimePolicy#description}
  */
  readonly description?: string;
  /**
  * Enable detection of crypto mining via DNS monitoring
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enable_crypto_mining_dns FunctionRuntimePolicy#enable_crypto_mining_dns}
  */
  readonly enableCryptoMiningDns?: boolean | cdktf.IResolvable;
  /**
  * Indicates if the runtime policy is enabled or not.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enabled FunctionRuntimePolicy#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Indicates that policy should effect function execution (not just for audit).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enforce FunctionRuntimePolicy#enforce}
  */
  readonly enforce?: boolean | cdktf.IResolvable;
  /**
  * Indicates the number of days after which the runtime policy will be changed to enforce mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enforce_after_days FunctionRuntimePolicy#enforce_after_days}
  */
  readonly enforceAfterDays?: number;
  /**
  * List of excluded application scopes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#exclude_application_scopes FunctionRuntimePolicy#exclude_application_scopes}
  */
  readonly excludeApplicationScopes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#id FunctionRuntimePolicy#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Indicates if audit check is enabled
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#is_audit_checked FunctionRuntimePolicy#is_audit_checked}
  */
  readonly isAuditChecked?: boolean | cdktf.IResolvable;
  /**
  * Indicates if the policy was auto-generated
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#is_auto_generated FunctionRuntimePolicy#is_auto_generated}
  */
  readonly isAutoGenerated?: boolean | cdktf.IResolvable;
  /**
  * Indicates if this is an out-of-the-box policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#is_ootb_policy FunctionRuntimePolicy#is_ootb_policy}
  */
  readonly isOotbPolicy?: boolean | cdktf.IResolvable;
  /**
  * Name of the function runtime policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#name FunctionRuntimePolicy#name}
  */
  readonly name: string;
  /**
  * Type of runtime policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#runtime_type FunctionRuntimePolicy#runtime_type}
  */
  readonly runtimeType?: string;
  /**
  * Logical expression of how to compute the dependency of the scope variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#scope_expression FunctionRuntimePolicy#scope_expression}
  */
  readonly scopeExpression?: string;
  /**
  * Policy type identifier
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#type FunctionRuntimePolicy#type}
  */
  readonly type?: string;
  /**
  * Version of the function runtime policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#version FunctionRuntimePolicy#version}
  */
  readonly version?: string;
  /**
  * allowed_executables block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#allowed_executables FunctionRuntimePolicy#allowed_executables}
  */
  readonly allowedExecutables?: FunctionRuntimePolicyAllowedExecutables[] | cdktf.IResolvable;
  /**
  * drift_prevention block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#drift_prevention FunctionRuntimePolicy#drift_prevention}
  */
  readonly driftPrevention?: FunctionRuntimePolicyDriftPrevention[] | cdktf.IResolvable;
  /**
  * executable_blacklist block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#executable_blacklist FunctionRuntimePolicy#executable_blacklist}
  */
  readonly executableBlacklist?: FunctionRuntimePolicyExecutableBlacklistStruct[] | cdktf.IResolvable;
  /**
  * file_integrity_monitoring block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#file_integrity_monitoring FunctionRuntimePolicy#file_integrity_monitoring}
  */
  readonly fileIntegrityMonitoring?: FunctionRuntimePolicyFileIntegrityMonitoring[] | cdktf.IResolvable;
  /**
  * malware_scan_options block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#malware_scan_options FunctionRuntimePolicy#malware_scan_options}
  */
  readonly malwareScanOptions?: FunctionRuntimePolicyMalwareScanOptions;
  /**
  * scope block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#scope FunctionRuntimePolicy#scope}
  */
  readonly scope?: FunctionRuntimePolicyScope[] | cdktf.IResolvable;
  /**
  * scope_variables block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#scope_variables FunctionRuntimePolicy#scope_variables}
  */
  readonly scopeVariables?: FunctionRuntimePolicyScopeVariablesA[] | cdktf.IResolvable;
  /**
  * tripwire block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#tripwire FunctionRuntimePolicy#tripwire}
  */
  readonly tripwire?: FunctionRuntimePolicyTripwire;
}
export interface FunctionRuntimePolicyAllowedExecutables {
  /**
  * List of allowed executables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#allow_executables FunctionRuntimePolicy#allow_executables}
  */
  readonly allowExecutables?: string[];
  /**
  * List of allowed root executables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#allow_root_executables FunctionRuntimePolicy#allow_root_executables}
  */
  readonly allowRootExecutables?: string[];
  /**
  * Whether allowed executables configuration is enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enabled FunctionRuntimePolicy#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Whether to treat executables separately.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#separate_executables FunctionRuntimePolicy#separate_executables}
  */
  readonly separateExecutables?: boolean | cdktf.IResolvable;
}

export function functionRuntimePolicyAllowedExecutablesToTerraform(struct?: FunctionRuntimePolicyAllowedExecutables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_executables: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowExecutables),
    allow_root_executables: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowRootExecutables),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    separate_executables: cdktf.booleanToTerraform(struct!.separateExecutables),
  }
}


export function functionRuntimePolicyAllowedExecutablesToHclTerraform(struct?: FunctionRuntimePolicyAllowedExecutables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_executables: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowExecutables),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allow_root_executables: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowRootExecutables),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    separate_executables: {
      value: cdktf.booleanToHclTerraform(struct!.separateExecutables),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyAllowedExecutablesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FunctionRuntimePolicyAllowedExecutables | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowExecutables !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowExecutables = this._allowExecutables;
    }
    if (this._allowRootExecutables !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowRootExecutables = this._allowRootExecutables;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._separateExecutables !== undefined) {
      hasAnyValues = true;
      internalValueResult.separateExecutables = this._separateExecutables;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyAllowedExecutables | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowExecutables = undefined;
      this._allowRootExecutables = undefined;
      this._enabled = undefined;
      this._separateExecutables = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowExecutables = value.allowExecutables;
      this._allowRootExecutables = value.allowRootExecutables;
      this._enabled = value.enabled;
      this._separateExecutables = value.separateExecutables;
    }
  }

  // allow_executables - computed: false, optional: true, required: false
  private _allowExecutables?: string[]; 
  public get allowExecutables() {
    return this.getListAttribute('allow_executables');
  }
  public set allowExecutables(value: string[]) {
    this._allowExecutables = value;
  }
  public resetAllowExecutables() {
    this._allowExecutables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowExecutablesInput() {
    return this._allowExecutables;
  }

  // allow_root_executables - computed: false, optional: true, required: false
  private _allowRootExecutables?: string[]; 
  public get allowRootExecutables() {
    return this.getListAttribute('allow_root_executables');
  }
  public set allowRootExecutables(value: string[]) {
    this._allowRootExecutables = value;
  }
  public resetAllowRootExecutables() {
    this._allowRootExecutables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowRootExecutablesInput() {
    return this._allowRootExecutables;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // separate_executables - computed: false, optional: true, required: false
  private _separateExecutables?: boolean | cdktf.IResolvable; 
  public get separateExecutables() {
    return this.getBooleanAttribute('separate_executables');
  }
  public set separateExecutables(value: boolean | cdktf.IResolvable) {
    this._separateExecutables = value;
  }
  public resetSeparateExecutables() {
    this._separateExecutables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get separateExecutablesInput() {
    return this._separateExecutables;
  }
}

export class FunctionRuntimePolicyAllowedExecutablesList extends cdktf.ComplexList {
  public internalValue? : FunctionRuntimePolicyAllowedExecutables[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FunctionRuntimePolicyAllowedExecutablesOutputReference {
    return new FunctionRuntimePolicyAllowedExecutablesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FunctionRuntimePolicyDriftPrevention {
  /**
  * Whether drift prevention is enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enabled FunctionRuntimePolicy#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Whether to lockdown execution drift.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#exec_lockdown FunctionRuntimePolicy#exec_lockdown}
  */
  readonly execLockdown?: boolean | cdktf.IResolvable;
  /**
  * List of items in the execution lockdown white list.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#exec_lockdown_white_list FunctionRuntimePolicy#exec_lockdown_white_list}
  */
  readonly execLockdownWhiteList?: string[];
  /**
  * Whether to lockdown image drift.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#image_lockdown FunctionRuntimePolicy#image_lockdown}
  */
  readonly imageLockdown?: boolean | cdktf.IResolvable;
}

export function functionRuntimePolicyDriftPreventionToTerraform(struct?: FunctionRuntimePolicyDriftPrevention | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    exec_lockdown: cdktf.booleanToTerraform(struct!.execLockdown),
    exec_lockdown_white_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.execLockdownWhiteList),
    image_lockdown: cdktf.booleanToTerraform(struct!.imageLockdown),
  }
}


export function functionRuntimePolicyDriftPreventionToHclTerraform(struct?: FunctionRuntimePolicyDriftPrevention | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    exec_lockdown: {
      value: cdktf.booleanToHclTerraform(struct!.execLockdown),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    exec_lockdown_white_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.execLockdownWhiteList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    image_lockdown: {
      value: cdktf.booleanToHclTerraform(struct!.imageLockdown),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyDriftPreventionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FunctionRuntimePolicyDriftPrevention | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._execLockdown !== undefined) {
      hasAnyValues = true;
      internalValueResult.execLockdown = this._execLockdown;
    }
    if (this._execLockdownWhiteList !== undefined) {
      hasAnyValues = true;
      internalValueResult.execLockdownWhiteList = this._execLockdownWhiteList;
    }
    if (this._imageLockdown !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageLockdown = this._imageLockdown;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyDriftPrevention | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._execLockdown = undefined;
      this._execLockdownWhiteList = undefined;
      this._imageLockdown = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._execLockdown = value.execLockdown;
      this._execLockdownWhiteList = value.execLockdownWhiteList;
      this._imageLockdown = value.imageLockdown;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // exec_lockdown - computed: false, optional: true, required: false
  private _execLockdown?: boolean | cdktf.IResolvable; 
  public get execLockdown() {
    return this.getBooleanAttribute('exec_lockdown');
  }
  public set execLockdown(value: boolean | cdktf.IResolvable) {
    this._execLockdown = value;
  }
  public resetExecLockdown() {
    this._execLockdown = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execLockdownInput() {
    return this._execLockdown;
  }

  // exec_lockdown_white_list - computed: false, optional: true, required: false
  private _execLockdownWhiteList?: string[]; 
  public get execLockdownWhiteList() {
    return this.getListAttribute('exec_lockdown_white_list');
  }
  public set execLockdownWhiteList(value: string[]) {
    this._execLockdownWhiteList = value;
  }
  public resetExecLockdownWhiteList() {
    this._execLockdownWhiteList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execLockdownWhiteListInput() {
    return this._execLockdownWhiteList;
  }

  // image_lockdown - computed: false, optional: true, required: false
  private _imageLockdown?: boolean | cdktf.IResolvable; 
  public get imageLockdown() {
    return this.getBooleanAttribute('image_lockdown');
  }
  public set imageLockdown(value: boolean | cdktf.IResolvable) {
    this._imageLockdown = value;
  }
  public resetImageLockdown() {
    this._imageLockdown = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageLockdownInput() {
    return this._imageLockdown;
  }
}

export class FunctionRuntimePolicyDriftPreventionList extends cdktf.ComplexList {
  public internalValue? : FunctionRuntimePolicyDriftPrevention[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FunctionRuntimePolicyDriftPreventionOutputReference {
    return new FunctionRuntimePolicyDriftPreventionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FunctionRuntimePolicyExecutableBlacklistStruct {
  /**
  * Whether the executable blacklist is enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enabled FunctionRuntimePolicy#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * List of blacklisted executables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#executables FunctionRuntimePolicy#executables}
  */
  readonly executables?: string[];
}

export function functionRuntimePolicyExecutableBlacklistStructToTerraform(struct?: FunctionRuntimePolicyExecutableBlacklistStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    executables: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.executables),
  }
}


export function functionRuntimePolicyExecutableBlacklistStructToHclTerraform(struct?: FunctionRuntimePolicyExecutableBlacklistStruct | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    executables: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.executables),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyExecutableBlacklistStructOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FunctionRuntimePolicyExecutableBlacklistStruct | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._executables !== undefined) {
      hasAnyValues = true;
      internalValueResult.executables = this._executables;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyExecutableBlacklistStruct | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._executables = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._executables = value.executables;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // executables - computed: false, optional: true, required: false
  private _executables?: string[]; 
  public get executables() {
    return this.getListAttribute('executables');
  }
  public set executables(value: string[]) {
    this._executables = value;
  }
  public resetExecutables() {
    this._executables = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get executablesInput() {
    return this._executables;
  }
}

export class FunctionRuntimePolicyExecutableBlacklistStructList extends cdktf.ComplexList {
  public internalValue? : FunctionRuntimePolicyExecutableBlacklistStruct[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FunctionRuntimePolicyExecutableBlacklistStructOutputReference {
    return new FunctionRuntimePolicyExecutableBlacklistStructOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FunctionRuntimePolicyFileIntegrityMonitoring {
  /**
  * If true, file integrity monitoring is enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enabled FunctionRuntimePolicy#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * List of paths to be excluded from monitoring.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#exceptional_monitored_files FunctionRuntimePolicy#exceptional_monitored_files}
  */
  readonly exceptionalMonitoredFiles?: string[];
  /**
  * List of processes to be excluded from monitoring.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#exceptional_monitored_files_processes FunctionRuntimePolicy#exceptional_monitored_files_processes}
  */
  readonly exceptionalMonitoredFilesProcesses?: string[];
  /**
  * List of users to be excluded from monitoring.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#exceptional_monitored_files_users FunctionRuntimePolicy#exceptional_monitored_files_users}
  */
  readonly exceptionalMonitoredFilesUsers?: string[];
  /**
  * List of paths to be monitored.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#monitored_files FunctionRuntimePolicy#monitored_files}
  */
  readonly monitoredFiles?: string[];
  /**
  * Whether to monitor file attribute operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#monitored_files_attributes FunctionRuntimePolicy#monitored_files_attributes}
  */
  readonly monitoredFilesAttributes?: boolean | cdktf.IResolvable;
  /**
  * Whether to monitor file create operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#monitored_files_create FunctionRuntimePolicy#monitored_files_create}
  */
  readonly monitoredFilesCreate?: boolean | cdktf.IResolvable;
  /**
  * Whether to monitor file delete operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#monitored_files_delete FunctionRuntimePolicy#monitored_files_delete}
  */
  readonly monitoredFilesDelete?: boolean | cdktf.IResolvable;
  /**
  * Whether to monitor file modify operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#monitored_files_modify FunctionRuntimePolicy#monitored_files_modify}
  */
  readonly monitoredFilesModify?: boolean | cdktf.IResolvable;
  /**
  * List of processes associated with monitored files.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#monitored_files_processes FunctionRuntimePolicy#monitored_files_processes}
  */
  readonly monitoredFilesProcesses?: string[];
  /**
  * Whether to monitor file read operations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#monitored_files_read FunctionRuntimePolicy#monitored_files_read}
  */
  readonly monitoredFilesRead?: boolean | cdktf.IResolvable;
  /**
  * List of users associated with monitored files.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#monitored_files_users FunctionRuntimePolicy#monitored_files_users}
  */
  readonly monitoredFilesUsers?: string[];
}

export function functionRuntimePolicyFileIntegrityMonitoringToTerraform(struct?: FunctionRuntimePolicyFileIntegrityMonitoring | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    exceptional_monitored_files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.exceptionalMonitoredFiles),
    exceptional_monitored_files_processes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.exceptionalMonitoredFilesProcesses),
    exceptional_monitored_files_users: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.exceptionalMonitoredFilesUsers),
    monitored_files: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoredFiles),
    monitored_files_attributes: cdktf.booleanToTerraform(struct!.monitoredFilesAttributes),
    monitored_files_create: cdktf.booleanToTerraform(struct!.monitoredFilesCreate),
    monitored_files_delete: cdktf.booleanToTerraform(struct!.monitoredFilesDelete),
    monitored_files_modify: cdktf.booleanToTerraform(struct!.monitoredFilesModify),
    monitored_files_processes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoredFilesProcesses),
    monitored_files_read: cdktf.booleanToTerraform(struct!.monitoredFilesRead),
    monitored_files_users: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.monitoredFilesUsers),
  }
}


export function functionRuntimePolicyFileIntegrityMonitoringToHclTerraform(struct?: FunctionRuntimePolicyFileIntegrityMonitoring | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    exceptional_monitored_files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.exceptionalMonitoredFiles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exceptional_monitored_files_processes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.exceptionalMonitoredFilesProcesses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exceptional_monitored_files_users: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.exceptionalMonitoredFilesUsers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    monitored_files: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoredFiles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    monitored_files_attributes: {
      value: cdktf.booleanToHclTerraform(struct!.monitoredFilesAttributes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitored_files_create: {
      value: cdktf.booleanToHclTerraform(struct!.monitoredFilesCreate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitored_files_delete: {
      value: cdktf.booleanToHclTerraform(struct!.monitoredFilesDelete),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitored_files_modify: {
      value: cdktf.booleanToHclTerraform(struct!.monitoredFilesModify),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitored_files_processes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoredFilesProcesses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    monitored_files_read: {
      value: cdktf.booleanToHclTerraform(struct!.monitoredFilesRead),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    monitored_files_users: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.monitoredFilesUsers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyFileIntegrityMonitoringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FunctionRuntimePolicyFileIntegrityMonitoring | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._exceptionalMonitoredFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.exceptionalMonitoredFiles = this._exceptionalMonitoredFiles;
    }
    if (this._exceptionalMonitoredFilesProcesses !== undefined) {
      hasAnyValues = true;
      internalValueResult.exceptionalMonitoredFilesProcesses = this._exceptionalMonitoredFilesProcesses;
    }
    if (this._exceptionalMonitoredFilesUsers !== undefined) {
      hasAnyValues = true;
      internalValueResult.exceptionalMonitoredFilesUsers = this._exceptionalMonitoredFilesUsers;
    }
    if (this._monitoredFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoredFiles = this._monitoredFiles;
    }
    if (this._monitoredFilesAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoredFilesAttributes = this._monitoredFilesAttributes;
    }
    if (this._monitoredFilesCreate !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoredFilesCreate = this._monitoredFilesCreate;
    }
    if (this._monitoredFilesDelete !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoredFilesDelete = this._monitoredFilesDelete;
    }
    if (this._monitoredFilesModify !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoredFilesModify = this._monitoredFilesModify;
    }
    if (this._monitoredFilesProcesses !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoredFilesProcesses = this._monitoredFilesProcesses;
    }
    if (this._monitoredFilesRead !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoredFilesRead = this._monitoredFilesRead;
    }
    if (this._monitoredFilesUsers !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoredFilesUsers = this._monitoredFilesUsers;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyFileIntegrityMonitoring | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enabled = undefined;
      this._exceptionalMonitoredFiles = undefined;
      this._exceptionalMonitoredFilesProcesses = undefined;
      this._exceptionalMonitoredFilesUsers = undefined;
      this._monitoredFiles = undefined;
      this._monitoredFilesAttributes = undefined;
      this._monitoredFilesCreate = undefined;
      this._monitoredFilesDelete = undefined;
      this._monitoredFilesModify = undefined;
      this._monitoredFilesProcesses = undefined;
      this._monitoredFilesRead = undefined;
      this._monitoredFilesUsers = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enabled = value.enabled;
      this._exceptionalMonitoredFiles = value.exceptionalMonitoredFiles;
      this._exceptionalMonitoredFilesProcesses = value.exceptionalMonitoredFilesProcesses;
      this._exceptionalMonitoredFilesUsers = value.exceptionalMonitoredFilesUsers;
      this._monitoredFiles = value.monitoredFiles;
      this._monitoredFilesAttributes = value.monitoredFilesAttributes;
      this._monitoredFilesCreate = value.monitoredFilesCreate;
      this._monitoredFilesDelete = value.monitoredFilesDelete;
      this._monitoredFilesModify = value.monitoredFilesModify;
      this._monitoredFilesProcesses = value.monitoredFilesProcesses;
      this._monitoredFilesRead = value.monitoredFilesRead;
      this._monitoredFilesUsers = value.monitoredFilesUsers;
    }
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // exceptional_monitored_files - computed: false, optional: true, required: false
  private _exceptionalMonitoredFiles?: string[]; 
  public get exceptionalMonitoredFiles() {
    return this.getListAttribute('exceptional_monitored_files');
  }
  public set exceptionalMonitoredFiles(value: string[]) {
    this._exceptionalMonitoredFiles = value;
  }
  public resetExceptionalMonitoredFiles() {
    this._exceptionalMonitoredFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptionalMonitoredFilesInput() {
    return this._exceptionalMonitoredFiles;
  }

  // exceptional_monitored_files_processes - computed: false, optional: true, required: false
  private _exceptionalMonitoredFilesProcesses?: string[]; 
  public get exceptionalMonitoredFilesProcesses() {
    return this.getListAttribute('exceptional_monitored_files_processes');
  }
  public set exceptionalMonitoredFilesProcesses(value: string[]) {
    this._exceptionalMonitoredFilesProcesses = value;
  }
  public resetExceptionalMonitoredFilesProcesses() {
    this._exceptionalMonitoredFilesProcesses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptionalMonitoredFilesProcessesInput() {
    return this._exceptionalMonitoredFilesProcesses;
  }

  // exceptional_monitored_files_users - computed: false, optional: true, required: false
  private _exceptionalMonitoredFilesUsers?: string[]; 
  public get exceptionalMonitoredFilesUsers() {
    return this.getListAttribute('exceptional_monitored_files_users');
  }
  public set exceptionalMonitoredFilesUsers(value: string[]) {
    this._exceptionalMonitoredFilesUsers = value;
  }
  public resetExceptionalMonitoredFilesUsers() {
    this._exceptionalMonitoredFilesUsers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exceptionalMonitoredFilesUsersInput() {
    return this._exceptionalMonitoredFilesUsers;
  }

  // monitored_files - computed: false, optional: true, required: false
  private _monitoredFiles?: string[]; 
  public get monitoredFiles() {
    return this.getListAttribute('monitored_files');
  }
  public set monitoredFiles(value: string[]) {
    this._monitoredFiles = value;
  }
  public resetMonitoredFiles() {
    this._monitoredFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoredFilesInput() {
    return this._monitoredFiles;
  }

  // monitored_files_attributes - computed: false, optional: true, required: false
  private _monitoredFilesAttributes?: boolean | cdktf.IResolvable; 
  public get monitoredFilesAttributes() {
    return this.getBooleanAttribute('monitored_files_attributes');
  }
  public set monitoredFilesAttributes(value: boolean | cdktf.IResolvable) {
    this._monitoredFilesAttributes = value;
  }
  public resetMonitoredFilesAttributes() {
    this._monitoredFilesAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoredFilesAttributesInput() {
    return this._monitoredFilesAttributes;
  }

  // monitored_files_create - computed: false, optional: true, required: false
  private _monitoredFilesCreate?: boolean | cdktf.IResolvable; 
  public get monitoredFilesCreate() {
    return this.getBooleanAttribute('monitored_files_create');
  }
  public set monitoredFilesCreate(value: boolean | cdktf.IResolvable) {
    this._monitoredFilesCreate = value;
  }
  public resetMonitoredFilesCreate() {
    this._monitoredFilesCreate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoredFilesCreateInput() {
    return this._monitoredFilesCreate;
  }

  // monitored_files_delete - computed: false, optional: true, required: false
  private _monitoredFilesDelete?: boolean | cdktf.IResolvable; 
  public get monitoredFilesDelete() {
    return this.getBooleanAttribute('monitored_files_delete');
  }
  public set monitoredFilesDelete(value: boolean | cdktf.IResolvable) {
    this._monitoredFilesDelete = value;
  }
  public resetMonitoredFilesDelete() {
    this._monitoredFilesDelete = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoredFilesDeleteInput() {
    return this._monitoredFilesDelete;
  }

  // monitored_files_modify - computed: false, optional: true, required: false
  private _monitoredFilesModify?: boolean | cdktf.IResolvable; 
  public get monitoredFilesModify() {
    return this.getBooleanAttribute('monitored_files_modify');
  }
  public set monitoredFilesModify(value: boolean | cdktf.IResolvable) {
    this._monitoredFilesModify = value;
  }
  public resetMonitoredFilesModify() {
    this._monitoredFilesModify = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoredFilesModifyInput() {
    return this._monitoredFilesModify;
  }

  // monitored_files_processes - computed: false, optional: true, required: false
  private _monitoredFilesProcesses?: string[]; 
  public get monitoredFilesProcesses() {
    return this.getListAttribute('monitored_files_processes');
  }
  public set monitoredFilesProcesses(value: string[]) {
    this._monitoredFilesProcesses = value;
  }
  public resetMonitoredFilesProcesses() {
    this._monitoredFilesProcesses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoredFilesProcessesInput() {
    return this._monitoredFilesProcesses;
  }

  // monitored_files_read - computed: false, optional: true, required: false
  private _monitoredFilesRead?: boolean | cdktf.IResolvable; 
  public get monitoredFilesRead() {
    return this.getBooleanAttribute('monitored_files_read');
  }
  public set monitoredFilesRead(value: boolean | cdktf.IResolvable) {
    this._monitoredFilesRead = value;
  }
  public resetMonitoredFilesRead() {
    this._monitoredFilesRead = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoredFilesReadInput() {
    return this._monitoredFilesRead;
  }

  // monitored_files_users - computed: false, optional: true, required: false
  private _monitoredFilesUsers?: string[]; 
  public get monitoredFilesUsers() {
    return this.getListAttribute('monitored_files_users');
  }
  public set monitoredFilesUsers(value: string[]) {
    this._monitoredFilesUsers = value;
  }
  public resetMonitoredFilesUsers() {
    this._monitoredFilesUsers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoredFilesUsersInput() {
    return this._monitoredFilesUsers;
  }
}

export class FunctionRuntimePolicyFileIntegrityMonitoringList extends cdktf.ComplexList {
  public internalValue? : FunctionRuntimePolicyFileIntegrityMonitoring[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FunctionRuntimePolicyFileIntegrityMonitoringOutputReference {
    return new FunctionRuntimePolicyFileIntegrityMonitoringOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FunctionRuntimePolicyMalwareScanOptions {
  /**
  * Set Action, Defaults to 'Alert' when empty
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#action FunctionRuntimePolicy#action}
  */
  readonly action?: string;
  /**
  * Defines if malware scanning is enabled or not
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enabled FunctionRuntimePolicy#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * List of directories to exclude from scanning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#exclude_directories FunctionRuntimePolicy#exclude_directories}
  */
  readonly excludeDirectories?: string[];
  /**
  * List of processes to exclude from scanning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#exclude_processes FunctionRuntimePolicy#exclude_processes}
  */
  readonly excludeProcesses?: string[];
  /**
  * Whether to enable file forensic collection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#file_forensic_collection FunctionRuntimePolicy#file_forensic_collection}
  */
  readonly fileForensicCollection?: boolean | cdktf.IResolvable;
  /**
  * List of directories to include in scanning.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#include_directories FunctionRuntimePolicy#include_directories}
  */
  readonly includeDirectories?: string[];
}

export function functionRuntimePolicyMalwareScanOptionsToTerraform(struct?: FunctionRuntimePolicyMalwareScanOptionsOutputReference | FunctionRuntimePolicyMalwareScanOptions): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action: cdktf.stringToTerraform(struct!.action),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    exclude_directories: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeDirectories),
    exclude_processes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeProcesses),
    file_forensic_collection: cdktf.booleanToTerraform(struct!.fileForensicCollection),
    include_directories: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.includeDirectories),
  }
}


export function functionRuntimePolicyMalwareScanOptionsToHclTerraform(struct?: FunctionRuntimePolicyMalwareScanOptionsOutputReference | FunctionRuntimePolicyMalwareScanOptions): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action: {
      value: cdktf.stringToHclTerraform(struct!.action),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    exclude_directories: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeDirectories),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exclude_processes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeProcesses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    file_forensic_collection: {
      value: cdktf.booleanToHclTerraform(struct!.fileForensicCollection),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    include_directories: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.includeDirectories),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyMalwareScanOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): FunctionRuntimePolicyMalwareScanOptions | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._action !== undefined) {
      hasAnyValues = true;
      internalValueResult.action = this._action;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._excludeDirectories !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeDirectories = this._excludeDirectories;
    }
    if (this._excludeProcesses !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeProcesses = this._excludeProcesses;
    }
    if (this._fileForensicCollection !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileForensicCollection = this._fileForensicCollection;
    }
    if (this._includeDirectories !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeDirectories = this._includeDirectories;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyMalwareScanOptions | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._action = undefined;
      this._enabled = undefined;
      this._excludeDirectories = undefined;
      this._excludeProcesses = undefined;
      this._fileForensicCollection = undefined;
      this._includeDirectories = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._action = value.action;
      this._enabled = value.enabled;
      this._excludeDirectories = value.excludeDirectories;
      this._excludeProcesses = value.excludeProcesses;
      this._fileForensicCollection = value.fileForensicCollection;
      this._includeDirectories = value.includeDirectories;
    }
  }

  // action - computed: false, optional: true, required: false
  private _action?: string; 
  public get action() {
    return this.getStringAttribute('action');
  }
  public set action(value: string) {
    this._action = value;
  }
  public resetAction() {
    this._action = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionInput() {
    return this._action;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // exclude_directories - computed: false, optional: true, required: false
  private _excludeDirectories?: string[]; 
  public get excludeDirectories() {
    return this.getListAttribute('exclude_directories');
  }
  public set excludeDirectories(value: string[]) {
    this._excludeDirectories = value;
  }
  public resetExcludeDirectories() {
    this._excludeDirectories = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeDirectoriesInput() {
    return this._excludeDirectories;
  }

  // exclude_processes - computed: false, optional: true, required: false
  private _excludeProcesses?: string[]; 
  public get excludeProcesses() {
    return this.getListAttribute('exclude_processes');
  }
  public set excludeProcesses(value: string[]) {
    this._excludeProcesses = value;
  }
  public resetExcludeProcesses() {
    this._excludeProcesses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeProcessesInput() {
    return this._excludeProcesses;
  }

  // file_forensic_collection - computed: false, optional: true, required: false
  private _fileForensicCollection?: boolean | cdktf.IResolvable; 
  public get fileForensicCollection() {
    return this.getBooleanAttribute('file_forensic_collection');
  }
  public set fileForensicCollection(value: boolean | cdktf.IResolvable) {
    this._fileForensicCollection = value;
  }
  public resetFileForensicCollection() {
    this._fileForensicCollection = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileForensicCollectionInput() {
    return this._fileForensicCollection;
  }

  // include_directories - computed: false, optional: true, required: false
  private _includeDirectories?: string[]; 
  public get includeDirectories() {
    return this.getListAttribute('include_directories');
  }
  public set includeDirectories(value: string[]) {
    this._includeDirectories = value;
  }
  public resetIncludeDirectories() {
    this._includeDirectories = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeDirectoriesInput() {
    return this._includeDirectories;
  }
}
export interface FunctionRuntimePolicyScopeVariables {
  /**
  * Variable attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#attribute FunctionRuntimePolicy#attribute}
  */
  readonly attribute: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#name FunctionRuntimePolicy#name}
  */
  readonly name?: string;
  /**
  * Variable value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#value FunctionRuntimePolicy#value}
  */
  readonly value: string;
}

export function functionRuntimePolicyScopeVariablesToTerraform(struct?: FunctionRuntimePolicyScopeVariables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute: cdktf.stringToTerraform(struct!.attribute),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function functionRuntimePolicyScopeVariablesToHclTerraform(struct?: FunctionRuntimePolicyScopeVariables | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute: {
      value: cdktf.stringToHclTerraform(struct!.attribute),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyScopeVariablesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FunctionRuntimePolicyScopeVariables | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attribute !== undefined) {
      hasAnyValues = true;
      internalValueResult.attribute = this._attribute;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyScopeVariables | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attribute = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attribute = value.attribute;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // attribute - computed: false, optional: false, required: true
  private _attribute?: string; 
  public get attribute() {
    return this.getStringAttribute('attribute');
  }
  public set attribute(value: string) {
    this._attribute = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeInput() {
    return this._attribute;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class FunctionRuntimePolicyScopeVariablesList extends cdktf.ComplexList {
  public internalValue? : FunctionRuntimePolicyScopeVariables[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FunctionRuntimePolicyScopeVariablesOutputReference {
    return new FunctionRuntimePolicyScopeVariablesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FunctionRuntimePolicyScope {
  /**
  * Scope expression.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#expression FunctionRuntimePolicy#expression}
  */
  readonly expression: string;
  /**
  * variables block
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#variables FunctionRuntimePolicy#variables}
  */
  readonly variables: FunctionRuntimePolicyScopeVariables[] | cdktf.IResolvable;
}

export function functionRuntimePolicyScopeToTerraform(struct?: FunctionRuntimePolicyScope | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expression: cdktf.stringToTerraform(struct!.expression),
    variables: cdktf.listMapper(functionRuntimePolicyScopeVariablesToTerraform, true)(struct!.variables),
  }
}


export function functionRuntimePolicyScopeToHclTerraform(struct?: FunctionRuntimePolicyScope | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expression: {
      value: cdktf.stringToHclTerraform(struct!.expression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    variables: {
      value: cdktf.listMapperHcl(functionRuntimePolicyScopeVariablesToHclTerraform, true)(struct!.variables),
      isBlock: true,
      type: "list",
      storageClassType: "FunctionRuntimePolicyScopeVariablesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyScopeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FunctionRuntimePolicyScope | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expression !== undefined) {
      hasAnyValues = true;
      internalValueResult.expression = this._expression;
    }
    if (this._variables?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.variables = this._variables?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyScope | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expression = undefined;
      this._variables.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expression = value.expression;
      this._variables.internalValue = value.variables;
    }
  }

  // expression - computed: false, optional: false, required: true
  private _expression?: string; 
  public get expression() {
    return this.getStringAttribute('expression');
  }
  public set expression(value: string) {
    this._expression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionInput() {
    return this._expression;
  }

  // variables - computed: false, optional: false, required: true
  private _variables = new FunctionRuntimePolicyScopeVariablesList(this, "variables", false);
  public get variables() {
    return this._variables;
  }
  public putVariables(value: FunctionRuntimePolicyScopeVariables[] | cdktf.IResolvable) {
    this._variables.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get variablesInput() {
    return this._variables.internalValue;
  }
}

export class FunctionRuntimePolicyScopeList extends cdktf.ComplexList {
  public internalValue? : FunctionRuntimePolicyScope[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FunctionRuntimePolicyScopeOutputReference {
    return new FunctionRuntimePolicyScopeOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FunctionRuntimePolicyScopeVariablesA {
  /**
  * Class of supported scope.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#attribute FunctionRuntimePolicy#attribute}
  */
  readonly attribute: string;
  /**
  * Name assigned to the attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#name FunctionRuntimePolicy#name}
  */
  readonly name?: string;
  /**
  * Value assigned to the attribute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#value FunctionRuntimePolicy#value}
  */
  readonly value: string;
}

export function functionRuntimePolicyScopeVariablesAToTerraform(struct?: FunctionRuntimePolicyScopeVariablesA | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attribute: cdktf.stringToTerraform(struct!.attribute),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function functionRuntimePolicyScopeVariablesAToHclTerraform(struct?: FunctionRuntimePolicyScopeVariablesA | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attribute: {
      value: cdktf.stringToHclTerraform(struct!.attribute),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyScopeVariablesAOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): FunctionRuntimePolicyScopeVariablesA | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attribute !== undefined) {
      hasAnyValues = true;
      internalValueResult.attribute = this._attribute;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyScopeVariablesA | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attribute = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attribute = value.attribute;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // attribute - computed: false, optional: false, required: true
  private _attribute?: string; 
  public get attribute() {
    return this.getStringAttribute('attribute');
  }
  public set attribute(value: string) {
    this._attribute = value;
  }
  // Temporarily expose input value. Use with caution.
  public get attributeInput() {
    return this._attribute;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class FunctionRuntimePolicyScopeVariablesAList extends cdktf.ComplexList {
  public internalValue? : FunctionRuntimePolicyScopeVariablesA[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): FunctionRuntimePolicyScopeVariablesAOutputReference {
    return new FunctionRuntimePolicyScopeVariablesAOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface FunctionRuntimePolicyTripwire {
  /**
  * List of options to apply the honeypot on (Environment Variable, Layer, File)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#apply_on FunctionRuntimePolicy#apply_on}
  */
  readonly applyOn?: string[];
  /**
  * Whether the honeypot is enabled.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#enabled FunctionRuntimePolicy#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Serverless application name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#serverless_app FunctionRuntimePolicy#serverless_app}
  */
  readonly serverlessApp?: string;
  /**
  * Honeypot User ID (Access Key)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#user_id FunctionRuntimePolicy#user_id}
  */
  readonly userId?: string;
  /**
  * Honeypot User Password (Secret Key)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#user_password FunctionRuntimePolicy#user_password}
  */
  readonly userPassword?: string;
}

export function functionRuntimePolicyTripwireToTerraform(struct?: FunctionRuntimePolicyTripwireOutputReference | FunctionRuntimePolicyTripwire): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apply_on: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.applyOn),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    serverless_app: cdktf.stringToTerraform(struct!.serverlessApp),
    user_id: cdktf.stringToTerraform(struct!.userId),
    user_password: cdktf.stringToTerraform(struct!.userPassword),
  }
}


export function functionRuntimePolicyTripwireToHclTerraform(struct?: FunctionRuntimePolicyTripwireOutputReference | FunctionRuntimePolicyTripwire): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apply_on: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.applyOn),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    serverless_app: {
      value: cdktf.stringToHclTerraform(struct!.serverlessApp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_id: {
      value: cdktf.stringToHclTerraform(struct!.userId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_password: {
      value: cdktf.stringToHclTerraform(struct!.userPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class FunctionRuntimePolicyTripwireOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false, 0);
  }

  public get internalValue(): FunctionRuntimePolicyTripwire | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._applyOn !== undefined) {
      hasAnyValues = true;
      internalValueResult.applyOn = this._applyOn;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._serverlessApp !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverlessApp = this._serverlessApp;
    }
    if (this._userId !== undefined) {
      hasAnyValues = true;
      internalValueResult.userId = this._userId;
    }
    if (this._userPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.userPassword = this._userPassword;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: FunctionRuntimePolicyTripwire | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this._applyOn = undefined;
      this._enabled = undefined;
      this._serverlessApp = undefined;
      this._userId = undefined;
      this._userPassword = undefined;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this._applyOn = value.applyOn;
      this._enabled = value.enabled;
      this._serverlessApp = value.serverlessApp;
      this._userId = value.userId;
      this._userPassword = value.userPassword;
    }
  }

  // apply_on - computed: false, optional: true, required: false
  private _applyOn?: string[]; 
  public get applyOn() {
    return this.getListAttribute('apply_on');
  }
  public set applyOn(value: string[]) {
    this._applyOn = value;
  }
  public resetApplyOn() {
    this._applyOn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applyOnInput() {
    return this._applyOn;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // serverless_app - computed: false, optional: true, required: false
  private _serverlessApp?: string; 
  public get serverlessApp() {
    return this.getStringAttribute('serverless_app');
  }
  public set serverlessApp(value: string) {
    this._serverlessApp = value;
  }
  public resetServerlessApp() {
    this._serverlessApp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverlessAppInput() {
    return this._serverlessApp;
  }

  // user_id - computed: false, optional: true, required: false
  private _userId?: string; 
  public get userId() {
    return this.getStringAttribute('user_id');
  }
  public set userId(value: string) {
    this._userId = value;
  }
  public resetUserId() {
    this._userId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userIdInput() {
    return this._userId;
  }

  // user_password - computed: false, optional: true, required: false
  private _userPassword?: string; 
  public get userPassword() {
    return this.getStringAttribute('user_password');
  }
  public set userPassword(value: string) {
    this._userPassword = value;
  }
  public resetUserPassword() {
    this._userPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userPasswordInput() {
    return this._userPassword;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy aquasec_function_runtime_policy}
*/
export class FunctionRuntimePolicy extends cdktf.TerraformResource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "aquasec_function_runtime_policy";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a FunctionRuntimePolicy resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the FunctionRuntimePolicy to import
  * @param importFromId The id of the existing FunctionRuntimePolicy that should be imported. Refer to the {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the FunctionRuntimePolicy to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "aquasec_function_runtime_policy", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/aquasecurity/aquasec/0.11.0/docs/resources/function_runtime_policy aquasec_function_runtime_policy} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options FunctionRuntimePolicyConfig
  */
  public constructor(scope: Construct, id: string, config: FunctionRuntimePolicyConfig) {
    super(scope, id, {
      terraformResourceType: 'aquasec_function_runtime_policy',
      terraformGeneratorMetadata: {
        providerName: 'aquasec',
        providerVersion: '0.11.0'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._applicationScopes = config.applicationScopes;
    this._blockDisallowedImages = config.blockDisallowedImages;
    this._blockFilelessExec = config.blockFilelessExec;
    this._blockNonCompliantWorkloads = config.blockNonCompliantWorkloads;
    this._description = config.description;
    this._enableCryptoMiningDns = config.enableCryptoMiningDns;
    this._enabled = config.enabled;
    this._enforce = config.enforce;
    this._enforceAfterDays = config.enforceAfterDays;
    this._excludeApplicationScopes = config.excludeApplicationScopes;
    this._id = config.id;
    this._isAuditChecked = config.isAuditChecked;
    this._isAutoGenerated = config.isAutoGenerated;
    this._isOotbPolicy = config.isOotbPolicy;
    this._name = config.name;
    this._runtimeType = config.runtimeType;
    this._scopeExpression = config.scopeExpression;
    this._type = config.type;
    this._version = config.version;
    this._allowedExecutables.internalValue = config.allowedExecutables;
    this._driftPrevention.internalValue = config.driftPrevention;
    this._executableBlacklist.internalValue = config.executableBlacklist;
    this._fileIntegrityMonitoring.internalValue = config.fileIntegrityMonitoring;
    this._malwareScanOptions.internalValue = config.malwareScanOptions;
    this._scope.internalValue = config.scope;
    this._scopeVariables.internalValue = config.scopeVariables;
    this._tripwire.internalValue = config.tripwire;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // application_scopes - computed: true, optional: true, required: false
  private _applicationScopes?: string[]; 
  public get applicationScopes() {
    return this.getListAttribute('application_scopes');
  }
  public set applicationScopes(value: string[]) {
    this._applicationScopes = value;
  }
  public resetApplicationScopes() {
    this._applicationScopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applicationScopesInput() {
    return this._applicationScopes;
  }

  // author - computed: true, optional: false, required: false
  public get author() {
    return this.getStringAttribute('author');
  }

  // block_disallowed_images - computed: false, optional: true, required: false
  private _blockDisallowedImages?: boolean | cdktf.IResolvable; 
  public get blockDisallowedImages() {
    return this.getBooleanAttribute('block_disallowed_images');
  }
  public set blockDisallowedImages(value: boolean | cdktf.IResolvable) {
    this._blockDisallowedImages = value;
  }
  public resetBlockDisallowedImages() {
    this._blockDisallowedImages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockDisallowedImagesInput() {
    return this._blockDisallowedImages;
  }

  // block_fileless_exec - computed: false, optional: true, required: false
  private _blockFilelessExec?: boolean | cdktf.IResolvable; 
  public get blockFilelessExec() {
    return this.getBooleanAttribute('block_fileless_exec');
  }
  public set blockFilelessExec(value: boolean | cdktf.IResolvable) {
    this._blockFilelessExec = value;
  }
  public resetBlockFilelessExec() {
    this._blockFilelessExec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockFilelessExecInput() {
    return this._blockFilelessExec;
  }

  // block_non_compliant_workloads - computed: false, optional: true, required: false
  private _blockNonCompliantWorkloads?: boolean | cdktf.IResolvable; 
  public get blockNonCompliantWorkloads() {
    return this.getBooleanAttribute('block_non_compliant_workloads');
  }
  public set blockNonCompliantWorkloads(value: boolean | cdktf.IResolvable) {
    this._blockNonCompliantWorkloads = value;
  }
  public resetBlockNonCompliantWorkloads() {
    this._blockNonCompliantWorkloads = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get blockNonCompliantWorkloadsInput() {
    return this._blockNonCompliantWorkloads;
  }

  // created - computed: true, optional: false, required: false
  public get created() {
    return this.getStringAttribute('created');
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enable_crypto_mining_dns - computed: false, optional: true, required: false
  private _enableCryptoMiningDns?: boolean | cdktf.IResolvable; 
  public get enableCryptoMiningDns() {
    return this.getBooleanAttribute('enable_crypto_mining_dns');
  }
  public set enableCryptoMiningDns(value: boolean | cdktf.IResolvable) {
    this._enableCryptoMiningDns = value;
  }
  public resetEnableCryptoMiningDns() {
    this._enableCryptoMiningDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableCryptoMiningDnsInput() {
    return this._enableCryptoMiningDns;
  }

  // enabled - computed: false, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // enforce - computed: false, optional: true, required: false
  private _enforce?: boolean | cdktf.IResolvable; 
  public get enforce() {
    return this.getBooleanAttribute('enforce');
  }
  public set enforce(value: boolean | cdktf.IResolvable) {
    this._enforce = value;
  }
  public resetEnforce() {
    this._enforce = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforceInput() {
    return this._enforce;
  }

  // enforce_after_days - computed: false, optional: true, required: false
  private _enforceAfterDays?: number; 
  public get enforceAfterDays() {
    return this.getNumberAttribute('enforce_after_days');
  }
  public set enforceAfterDays(value: number) {
    this._enforceAfterDays = value;
  }
  public resetEnforceAfterDays() {
    this._enforceAfterDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enforceAfterDaysInput() {
    return this._enforceAfterDays;
  }

  // exclude_application_scopes - computed: false, optional: true, required: false
  private _excludeApplicationScopes?: string[]; 
  public get excludeApplicationScopes() {
    return this.getListAttribute('exclude_application_scopes');
  }
  public set excludeApplicationScopes(value: string[]) {
    this._excludeApplicationScopes = value;
  }
  public resetExcludeApplicationScopes() {
    this._excludeApplicationScopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeApplicationScopesInput() {
    return this._excludeApplicationScopes;
  }

  // id - computed: true, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // is_audit_checked - computed: false, optional: true, required: false
  private _isAuditChecked?: boolean | cdktf.IResolvable; 
  public get isAuditChecked() {
    return this.getBooleanAttribute('is_audit_checked');
  }
  public set isAuditChecked(value: boolean | cdktf.IResolvable) {
    this._isAuditChecked = value;
  }
  public resetIsAuditChecked() {
    this._isAuditChecked = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isAuditCheckedInput() {
    return this._isAuditChecked;
  }

  // is_auto_generated - computed: false, optional: true, required: false
  private _isAutoGenerated?: boolean | cdktf.IResolvable; 
  public get isAutoGenerated() {
    return this.getBooleanAttribute('is_auto_generated');
  }
  public set isAutoGenerated(value: boolean | cdktf.IResolvable) {
    this._isAutoGenerated = value;
  }
  public resetIsAutoGenerated() {
    this._isAutoGenerated = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isAutoGeneratedInput() {
    return this._isAutoGenerated;
  }

  // is_ootb_policy - computed: false, optional: true, required: false
  private _isOotbPolicy?: boolean | cdktf.IResolvable; 
  public get isOotbPolicy() {
    return this.getBooleanAttribute('is_ootb_policy');
  }
  public set isOotbPolicy(value: boolean | cdktf.IResolvable) {
    this._isOotbPolicy = value;
  }
  public resetIsOotbPolicy() {
    this._isOotbPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isOotbPolicyInput() {
    return this._isOotbPolicy;
  }

  // lastupdate - computed: true, optional: false, required: false
  public get lastupdate() {
    return this.getNumberAttribute('lastupdate');
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // runtime_type - computed: false, optional: true, required: false
  private _runtimeType?: string; 
  public get runtimeType() {
    return this.getStringAttribute('runtime_type');
  }
  public set runtimeType(value: string) {
    this._runtimeType = value;
  }
  public resetRuntimeType() {
    this._runtimeType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeTypeInput() {
    return this._runtimeType;
  }

  // scope_expression - computed: true, optional: true, required: false
  private _scopeExpression?: string; 
  public get scopeExpression() {
    return this.getStringAttribute('scope_expression');
  }
  public set scopeExpression(value: string) {
    this._scopeExpression = value;
  }
  public resetScopeExpression() {
    this._scopeExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeExpressionInput() {
    return this._scopeExpression;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // updated - computed: true, optional: false, required: false
  public get updated() {
    return this.getStringAttribute('updated');
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }

  // allowed_executables - computed: false, optional: true, required: false
  private _allowedExecutables = new FunctionRuntimePolicyAllowedExecutablesList(this, "allowed_executables", false);
  public get allowedExecutables() {
    return this._allowedExecutables;
  }
  public putAllowedExecutables(value: FunctionRuntimePolicyAllowedExecutables[] | cdktf.IResolvable) {
    this._allowedExecutables.internalValue = value;
  }
  public resetAllowedExecutables() {
    this._allowedExecutables.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedExecutablesInput() {
    return this._allowedExecutables.internalValue;
  }

  // drift_prevention - computed: false, optional: true, required: false
  private _driftPrevention = new FunctionRuntimePolicyDriftPreventionList(this, "drift_prevention", false);
  public get driftPrevention() {
    return this._driftPrevention;
  }
  public putDriftPrevention(value: FunctionRuntimePolicyDriftPrevention[] | cdktf.IResolvable) {
    this._driftPrevention.internalValue = value;
  }
  public resetDriftPrevention() {
    this._driftPrevention.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get driftPreventionInput() {
    return this._driftPrevention.internalValue;
  }

  // executable_blacklist - computed: false, optional: true, required: false
  private _executableBlacklist = new FunctionRuntimePolicyExecutableBlacklistStructList(this, "executable_blacklist", false);
  public get executableBlacklist() {
    return this._executableBlacklist;
  }
  public putExecutableBlacklist(value: FunctionRuntimePolicyExecutableBlacklistStruct[] | cdktf.IResolvable) {
    this._executableBlacklist.internalValue = value;
  }
  public resetExecutableBlacklist() {
    this._executableBlacklist.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get executableBlacklistInput() {
    return this._executableBlacklist.internalValue;
  }

  // file_integrity_monitoring - computed: false, optional: true, required: false
  private _fileIntegrityMonitoring = new FunctionRuntimePolicyFileIntegrityMonitoringList(this, "file_integrity_monitoring", false);
  public get fileIntegrityMonitoring() {
    return this._fileIntegrityMonitoring;
  }
  public putFileIntegrityMonitoring(value: FunctionRuntimePolicyFileIntegrityMonitoring[] | cdktf.IResolvable) {
    this._fileIntegrityMonitoring.internalValue = value;
  }
  public resetFileIntegrityMonitoring() {
    this._fileIntegrityMonitoring.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileIntegrityMonitoringInput() {
    return this._fileIntegrityMonitoring.internalValue;
  }

  // malware_scan_options - computed: false, optional: true, required: false
  private _malwareScanOptions = new FunctionRuntimePolicyMalwareScanOptionsOutputReference(this, "malware_scan_options");
  public get malwareScanOptions() {
    return this._malwareScanOptions;
  }
  public putMalwareScanOptions(value: FunctionRuntimePolicyMalwareScanOptions) {
    this._malwareScanOptions.internalValue = value;
  }
  public resetMalwareScanOptions() {
    this._malwareScanOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get malwareScanOptionsInput() {
    return this._malwareScanOptions.internalValue;
  }

  // scope - computed: false, optional: true, required: false
  private _scope = new FunctionRuntimePolicyScopeList(this, "scope", false);
  public get scope() {
    return this._scope;
  }
  public putScope(value: FunctionRuntimePolicyScope[] | cdktf.IResolvable) {
    this._scope.internalValue = value;
  }
  public resetScope() {
    this._scope.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope.internalValue;
  }

  // scope_variables - computed: false, optional: true, required: false
  private _scopeVariables = new FunctionRuntimePolicyScopeVariablesAList(this, "scope_variables", false);
  public get scopeVariables() {
    return this._scopeVariables;
  }
  public putScopeVariables(value: FunctionRuntimePolicyScopeVariablesA[] | cdktf.IResolvable) {
    this._scopeVariables.internalValue = value;
  }
  public resetScopeVariables() {
    this._scopeVariables.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeVariablesInput() {
    return this._scopeVariables.internalValue;
  }

  // tripwire - computed: false, optional: true, required: false
  private _tripwire = new FunctionRuntimePolicyTripwireOutputReference(this, "tripwire");
  public get tripwire() {
    return this._tripwire;
  }
  public putTripwire(value: FunctionRuntimePolicyTripwire) {
    this._tripwire.internalValue = value;
  }
  public resetTripwire() {
    this._tripwire.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tripwireInput() {
    return this._tripwire.internalValue;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      application_scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(this._applicationScopes),
      block_disallowed_images: cdktf.booleanToTerraform(this._blockDisallowedImages),
      block_fileless_exec: cdktf.booleanToTerraform(this._blockFilelessExec),
      block_non_compliant_workloads: cdktf.booleanToTerraform(this._blockNonCompliantWorkloads),
      description: cdktf.stringToTerraform(this._description),
      enable_crypto_mining_dns: cdktf.booleanToTerraform(this._enableCryptoMiningDns),
      enabled: cdktf.booleanToTerraform(this._enabled),
      enforce: cdktf.booleanToTerraform(this._enforce),
      enforce_after_days: cdktf.numberToTerraform(this._enforceAfterDays),
      exclude_application_scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(this._excludeApplicationScopes),
      id: cdktf.stringToTerraform(this._id),
      is_audit_checked: cdktf.booleanToTerraform(this._isAuditChecked),
      is_auto_generated: cdktf.booleanToTerraform(this._isAutoGenerated),
      is_ootb_policy: cdktf.booleanToTerraform(this._isOotbPolicy),
      name: cdktf.stringToTerraform(this._name),
      runtime_type: cdktf.stringToTerraform(this._runtimeType),
      scope_expression: cdktf.stringToTerraform(this._scopeExpression),
      type: cdktf.stringToTerraform(this._type),
      version: cdktf.stringToTerraform(this._version),
      allowed_executables: cdktf.listMapper(functionRuntimePolicyAllowedExecutablesToTerraform, true)(this._allowedExecutables.internalValue),
      drift_prevention: cdktf.listMapper(functionRuntimePolicyDriftPreventionToTerraform, true)(this._driftPrevention.internalValue),
      executable_blacklist: cdktf.listMapper(functionRuntimePolicyExecutableBlacklistStructToTerraform, true)(this._executableBlacklist.internalValue),
      file_integrity_monitoring: cdktf.listMapper(functionRuntimePolicyFileIntegrityMonitoringToTerraform, true)(this._fileIntegrityMonitoring.internalValue),
      malware_scan_options: functionRuntimePolicyMalwareScanOptionsToTerraform(this._malwareScanOptions.internalValue),
      scope: cdktf.listMapper(functionRuntimePolicyScopeToTerraform, true)(this._scope.internalValue),
      scope_variables: cdktf.listMapper(functionRuntimePolicyScopeVariablesAToTerraform, true)(this._scopeVariables.internalValue),
      tripwire: functionRuntimePolicyTripwireToTerraform(this._tripwire.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      application_scopes: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._applicationScopes),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      block_disallowed_images: {
        value: cdktf.booleanToHclTerraform(this._blockDisallowedImages),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      block_fileless_exec: {
        value: cdktf.booleanToHclTerraform(this._blockFilelessExec),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      block_non_compliant_workloads: {
        value: cdktf.booleanToHclTerraform(this._blockNonCompliantWorkloads),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      description: {
        value: cdktf.stringToHclTerraform(this._description),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      enable_crypto_mining_dns: {
        value: cdktf.booleanToHclTerraform(this._enableCryptoMiningDns),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      enabled: {
        value: cdktf.booleanToHclTerraform(this._enabled),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      enforce: {
        value: cdktf.booleanToHclTerraform(this._enforce),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      enforce_after_days: {
        value: cdktf.numberToHclTerraform(this._enforceAfterDays),
        isBlock: false,
        type: "simple",
        storageClassType: "number",
      },
      exclude_application_scopes: {
        value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(this._excludeApplicationScopes),
        isBlock: false,
        type: "list",
        storageClassType: "stringList",
      },
      id: {
        value: cdktf.stringToHclTerraform(this._id),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      is_audit_checked: {
        value: cdktf.booleanToHclTerraform(this._isAuditChecked),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      is_auto_generated: {
        value: cdktf.booleanToHclTerraform(this._isAutoGenerated),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      is_ootb_policy: {
        value: cdktf.booleanToHclTerraform(this._isOotbPolicy),
        isBlock: false,
        type: "simple",
        storageClassType: "boolean",
      },
      name: {
        value: cdktf.stringToHclTerraform(this._name),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      runtime_type: {
        value: cdktf.stringToHclTerraform(this._runtimeType),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      scope_expression: {
        value: cdktf.stringToHclTerraform(this._scopeExpression),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      type: {
        value: cdktf.stringToHclTerraform(this._type),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      version: {
        value: cdktf.stringToHclTerraform(this._version),
        isBlock: false,
        type: "simple",
        storageClassType: "string",
      },
      allowed_executables: {
        value: cdktf.listMapperHcl(functionRuntimePolicyAllowedExecutablesToHclTerraform, true)(this._allowedExecutables.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "FunctionRuntimePolicyAllowedExecutablesList",
      },
      drift_prevention: {
        value: cdktf.listMapperHcl(functionRuntimePolicyDriftPreventionToHclTerraform, true)(this._driftPrevention.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "FunctionRuntimePolicyDriftPreventionList",
      },
      executable_blacklist: {
        value: cdktf.listMapperHcl(functionRuntimePolicyExecutableBlacklistStructToHclTerraform, true)(this._executableBlacklist.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "FunctionRuntimePolicyExecutableBlacklistStructList",
      },
      file_integrity_monitoring: {
        value: cdktf.listMapperHcl(functionRuntimePolicyFileIntegrityMonitoringToHclTerraform, true)(this._fileIntegrityMonitoring.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "FunctionRuntimePolicyFileIntegrityMonitoringList",
      },
      malware_scan_options: {
        value: functionRuntimePolicyMalwareScanOptionsToHclTerraform(this._malwareScanOptions.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "FunctionRuntimePolicyMalwareScanOptionsList",
      },
      scope: {
        value: cdktf.listMapperHcl(functionRuntimePolicyScopeToHclTerraform, true)(this._scope.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "FunctionRuntimePolicyScopeList",
      },
      scope_variables: {
        value: cdktf.listMapperHcl(functionRuntimePolicyScopeVariablesAToHclTerraform, true)(this._scopeVariables.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "FunctionRuntimePolicyScopeVariablesAList",
      },
      tripwire: {
        value: functionRuntimePolicyTripwireToHclTerraform(this._tripwire.internalValue),
        isBlock: true,
        type: "list",
        storageClassType: "FunctionRuntimePolicyTripwireList",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
